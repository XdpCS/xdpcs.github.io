[{"content":"","date":"18 November 2022","permalink":"/projects/solidity-learning/","section":"Projects","summary":"","title":"Solidity-Learning"},{"content":"","date":"25 December 2020","permalink":"/projects/hdu-computer-organization-and-architecture-experiment/","section":"Projects","summary":"","title":"杭电计算机组成实验"},{"content":"","date":null,"permalink":"/blogs/","section":"Blog","summary":"","title":"Blog"},{"content":"","date":null,"permalink":"/tags/golang/","section":"Tags","summary":"","title":"Golang"},{"content":"痛点 #例子 #package main import \u0026#34;fmt\u0026#34; type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func main() { t := \u0026amp;TreeNode{ Val: 1, Left: \u0026amp;TreeNode{ Val: 2, }, Right: \u0026amp;TreeNode{ Val: 3, }, } fmt.Println(t) } 输出 #\u0026amp;{1 0x14000126018 0x14000126030} 我们从上述的例子可以看到，我们无法打印出结构体内部的Left和Right，只能打印出他们的地址\n解决办法 #使用程序库 #https://github.com/XdpCs/print-value\n例子 #package main import ( \u0026#34;fmt\u0026#34; print \u0026#34;github.com/XdpCs/print-value\u0026#34; ) type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func main() { t := \u0026amp;TreeNode{ Val: 1, Left: \u0026amp;TreeNode{ Val: 2, }, Right: \u0026amp;TreeNode{ Val: 3, }, } fmt.Println(print.Print(t)) } 结果 #TreeNode{Val:1,Left:TreeNode{Val:2,Left:nil,Right:nil},Right:TreeNode{Val:3,Left:nil,Right:nil}} ","date":"9 November 2023","permalink":"/blogs/go/print_value/","section":"Blog","summary":"痛点 #例子 #package main import \u0026#34;fmt\u0026#34; type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func main() { t := \u0026amp;TreeNode{ Val: 1, Left: \u0026amp;TreeNode{ Val: 2, }, Right: \u0026amp;TreeNode{ Val: 3, }, } fmt.","title":"Go打印结构体指针中的具体内容，而无需实现String()方法"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/tags/gopl/","section":"Tags","summary":"","title":"Gopl"},{"content":"1.1 hello,world # Go是编译型语言 Go的工具链将程序的源文件转变成为机器相关的原生二进制指令 go run 将一个或多个以.go为后缀的源文件进行编译、链接，然后运行生成的可执行文件 Go原生地支持Unicode,所以可以处理所有国家地语言 go build 可以编译输出成一个可复用的二进制程序文件，它可以直接执行 Go 代码是用包进行组织的，一个包由一个或多个.go源文件组成，放在一个文件夹中，文件夹的名字描述了包的作用 每个源文件都以一条package声明语句开始，表示该文件属于哪个包 main包是用来定义可独立执行的程序 import声明语句用来导入其他包，必须跟在package声明之后，且不能缺失导入或存在不需要的导入 一个函数的声明由func关键字、函数名、参数列表、返回值列表和函数体组成 Go不需要使用分号进行结尾，除非一行上有多条语句或声明，在特定符号后面的换行符会被转换为分号，所以换行会影响对Go代码的解析 gofmt 工具可以标准格式去格式化代码，会按照字母顺序表进行排序 goimports 工具可以自动添加或删除import声明 1.2 命令行参数 # os 包提供了与平台无关的操作系统函数和类型 os.Args 是一个字符串的切片，用来存储所有的命令行参数，第一个参数是命令本身，另外的元素是程序开始执行时的参数 注释以// 开头 或者 /* */ 包裹，编译器会忽略注释 习惯上，每个包都有一个包注释，位于包声明语句之前，用一个或多个完整句子对包的整体功能进行描述 var s string = “” 变量可以在声明时初始化，如果没有初始化，则变量隐式初始化为该类型的空值，数值类型为0，字符串为“”，布尔类型为false，指针为nil := 为短变量声明，用于声明并初始化值给予合适的类型，:= 左侧的变量不应该是已经声明过的，否则会导致编译错误 i++,i-- 为语句，不是表达式，所以不能赋值给另一个变量，自增自减仅支持后缀形式 Go中没有while语句，只有for循环语句，for 循环语句的三个组成部分外都是可选的，如果省略第一个分号和第二个分号之间的表达式，那么该循环就变成了一个无限循环，如果省略第二个分号后面的表达式，那么该循环就变成了C语言中的while 循环 range 关键字用于for循环中迭代数组、切片、字符串、map和通道，每次迭代都会返回两个值，第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本 使用空标识符_可以把不需要的值赋值给它，这样可以避免声明未使用的变量而导致编译错误 s := \u0026quot;\u0026quot; 通常在一个函数内部使用，不适合包级别的变量 var s string 默认初始化为空字符串“” s := \u0026quot;\u0026quot;, var s string 实践中，应当使用这两种形式，使用显式初始化来说明初始化变量的重要性，使用隐式初始化来表明初始化变量不重要 例子 通过+= 语句追加旧的字符串，会生成一个新的字符串，然后新字符串的地址赋值给变量s，旧的字符串会被垃圾回收器回收，如果有大量的数据需要处理，代价会非常大，推荐使用strings.Join 函数来拼接字符串 1.3 找出重复行 # map 存储了一组无序的键值对，其中所有的键都是不同的，并提供常量实践的操作来存储、获取或测试集合中的某个元素，键可以是其值能够进行相等比较的任意类型，值可以是任意类型的，可以使用内置函数make来创建一个map bufio 包 用于创建带缓冲的读取器，它可以包装任何io.Reader对象，简便且高效地处理输入和输出，bufio.NewScanner 函数可以创建一个从指定io.Reader对象读取数据的Scanner，默认的分割函数是bufio.ScanLines，可以使用bufio.ScanWords 来指定按照单词来分割输入 fmt.Printf 函数的第一个参数是格式化字符串，包含了两种类型的内容，普通字符和转义字符，普通字符会原样输出，转义字符以% 开头，用于表示一些特定的格式化操作，%s 表示字符串，%d 表示十进制整数，%f 或 %F 表示浮点数，%t 表示布尔值，%v 表示通用格式，%T 表示值的类型，%p 表示指针，%x 或 %X 表示十六进制，%b 或 %B 表示二进制，%o 或 %O 表示八进制，%q 表示带双引号的字符串，%c 表示字符(Unicode码点)，%U 表示Unicode格式，%e或%E 表示科学计数法，%g 或%G 表示根据情况选择%e或%f 以及%E或%F以产生更紧凑的(无末尾的0)输出，%% 表示百分号 字符串字面量可以包含类似转义序列来表示不可见字符，\\n 表示换行符，\\t 表示制表符，\\r 表示回车符，\\\\ 表示反斜杠，\\' 表示单引号，\\\u0026quot; 表示双引号，\\xhh 表示一个两位的十六进制数，\\uhhhh 表示一个四位的十六进制数，\\Uhhhhhhhh 表示一个八位的十六进制数 log.Printf 和 fmt.Errorf的格式化函数以f结尾，使用和fmt.Printf 相同的格式化字符串，但是不会将结果写入标准输出，而是将其格式化后的内容写入标准错误输出，log.Printf 函数会在每条日志消息的前面添加日期和时间的前缀，fmt.Errorf函数会在返回一个error结构体 以ln结尾的函数(如Println)，则使用%v的方式来格式化参数，并在最后追加换行符 函数os.Open 会返回两个值，第一个值是被打开的文件(或者内存中的数据流)，第二个值是一个错误值，如果操作成功，错误值为nil，否则错误值表示了错误的原因 函数和其他包级别的实体可以任意次序声明，但是在使用之前必须先声明，如果一个实体是在函数内部声明的，那么它只能在该函数内部使用，如果一个实体是在包级别声明的，那么它可以在整个包中使用，如果一个实体是以大写字母开头的，那么它可以被外部的包访问，如果一个实体是以小写字母开头的，那么它只能在同一个包内部使用 map是一个使用make创建的数据结构的引用，所以它可以被自由的传递，而不会发生复制，map的零值是nil，对一个nil的map，读取操作不会报错，写入操作会触发panic ioutil.ReadFile 函数可以读取一个文件的全部内容，返回的结果是一个字节slice，如果读取过程中发生错误，将会返回一个非nil的错误值，如果读取成功，错误值为nil 1.4 GIF动画 # 使用路径最后的一段来引用包 const声明用来给常量命名，常量的值必须是编译期可确定的数字、字符串、布尔值，const 声明可以出现在包级别 结构体是由一组称为字段的值组成，它们一起组成单个对象，作为一个单位被对待，结构体的字段用点号来访问，结构体的字段可以是任意类型，包括数组、切片、以及其他的结构体，结构体的字段名必须是唯一的，如果结构体的字段名以大写字母开头，那么该字段是导出的，也就是说可以被外部的包访问，如果结构体的字段名以小写字母开头，那么该字段是未导出的，也就是说只能在同一个包内部使用 1.5 获取一个URL # net包提供了可移植的网络I/O接口，包括TCP/IP、UDP、域名解析和Unix域socket，使用底层的网络连接，创建服务器 os.Exit(1)会在程序退出时返回一个状态码，非零状态码表示错误，零状态码表示成功，os.Exit 会立即终止当前程序，不会执行任何的defer函数 1.6 并发获取多个URL # goroutine 是一个并发执行的函数 通道是一种允许某一协程向另一个协程传递指定类型的值的通信机制，通道可以用make函数创建，通道的零值是nil ，通道的零值没有什么用，必须使用make函数来创建一个真正的通道 main函数在一个goroutine中执行，然后使用go语句创建额外的goroutine ioutil.Discard 是用来将输出流丢弃的，实现了Writer接口的变量，在统计长度时候经常使用 当一个goroutine试图在一个通道上进行发送或接收操作时，它会阻塞，直到另一个goroutine 试图进行接收或发送操作时才会解除阻塞，对于同一个通道来说，发送操作之间是互斥的，接收操作之间也是互斥的，但是发送操作和接收操作之间则是不互斥的 1.7 一个Web服务器 # if err := r.ParseForm(); err != nil 合并的语句更短，缩小了err变量的作用域，这是一个好的实践 可以使用go doc查看某个函数的文档 1.8 其他内容 # switch 中的case语句中可以使用逗号来分隔多个表达式，switch语句中的表达式可以省略，这种情况下，switch 语句等同于switch true语句，switch语句中的case表达式不必是常量或者整数，case 表达式的求值顺序是从上到下，当匹配成功的case表达式后，执行相应的语句后就会退出整个switch 语句，如果想要继续执行后面的case表达式，可以使用fallthrough语句，fallthrough语句不会判断下一条case 表达式的求值结果是否为true，fallthrough语句应该是case语句的最后一条语句。没有语句匹配，会走default 分支，如果没有default分支，那么switch语句将不做任何动作 无标签选择 package main func Signum(x int) int { switch { case x \u0026gt; 0: return +1 default: return 0 case x \u0026lt; 0: return -1 } } break 和 continue 可以改变控制流，break语句会跳转到整个switch, for, selecct 语句的结束标签，可以使用标签跳出多层循环。continue 语句会跳转到当前switch, for, selecct 语句的结束标签。 goto语句可以无条件地转移到过程中指定的行，goto语句通常与条件语句配合使用，可以实现条件转移，goto 语句在快速跳出循环、避免重复退出上有一定的帮助，但是在结构化程序设计中一般不主张使用goto 语句，以免造成程序流程的混乱，使理解和调试程序都产生困难，使用goto语句的地方可以使用break或者continue语句代替 type声明不仅仅可以给已有类型命名，还可以将其定义为一个新的类型，新的类型可以在原有类型的基础上添加一些额外的功能，但是底层的类型必须是一致的 指针的值是变量的地址，使用\u0026amp;操作符可以获取一个变量的地址，使用*操作符可以获取指针指向的变量的值，指针的零值是nil ，指针之间可以进行比较操作，只有当两个指针指向同一个变量或者两个指针都是nil 时候，比较的结果才为真，指针也可以指向一个结构体，指针的指针也是合法的，指针不能进行算术运算 方法是一个关联了命名类型的函数 接口可以用相同的方式处理不同的具体类型的抽象类型，它基于这些类型所包含的方法，而不是类型的描述或实现 接口可以被任意的对象实现，一个对象可以实现任意多个接口，任意类型都实现了空接口，因此空接口可以存储任意类型的数值，空接口可以用来处理未知类型的值 interface{}类型可以保存任意类型的值，可以使用switch语句来判断空接口中的值的类型，interface{} 类型本身是一个指针，内部存储了类型的信息，interface{}类型的变量只有在类型和值都为nil的时候才为nil，interface{} 类型的变量可以作为函数的参数，通过interface{} 类型的变量可以调用其内部包含的值的方法，但是如果没有类型信息，就无法调用其内部包含的值的方法，interface{} 类型的变量可以使用类型断言来判断其内部包含的值的类型，类型断言的语法是x.(T)，其中x表示interface{}类型的变量，T 表示断言x可能是的类型，如果x是T类型，那么就会返回其内部包含的值，否则就会触发panic，类型断言也可以用在switch 语句中，switch语句中的case表达式中的类型断言可以将x的类型限制为T类型，如果x不是T类型，那么该case就不会被执行，反之 在声明任何函数前，写一段注释来说明它的行为是一个好的风格，且这样可以被go doc和godoc工具定位和作为文档显示 对跨越多行的注释，使用/*...*/进行注释，对于单行注释，使用//进行注释，两种注释不能相互嵌套 ","date":"7 August 2023","permalink":"/blogs/gopl/ch1/","section":"Blog","summary":"1.1 hello,world # Go是编译型语言 Go的工具链将程序的源文件转变成为机器相关的原生二进制指令 go run 将一个或多个以.","title":"第1章-入门-笔记"},{"content":"背景 # 当新接手他人的项目，我们很容易不知所措，不知道这个函数的作用是什么，即使有很好的命名规范，这种事情也会时常发生，甚至有时候几个月不碰这个项目，自己再看这个函数，也会有一种云里雾里的感觉 如果拥有好的注释，方便我们自己以后维护，也方便后来的同事接手你的项目，不至于对你的代码说这写的是啥，像一坨💩 注释规范 # 注释语言看团队，我们团队习惯使用英文，所以都使用英文，只要整个团队统一一个注释语言即可 全部使用单行注释,//后需要使用一个空格 包注释 # 包注释是对包的介绍 每个包都至少有一个包注释，在同一个包下，任一一个源文件中注释即可 放置在package之前，来简短描述这个包的功能 // 包的功能介绍 package 包名称 文件注释 # 每个文件都应有一个文件注释 放置在package之后，需要包含文件名称，文件描述，文件作者及其时间，更新作者及其时间 因为在公司正常开发流程中，可能合并分支的时候，只有自己部门的业务主管，有这个权限进行合并代码，如果去看git的日志，如果只看主分支，只会显示主管的id，很难很快落实到每个人上 package 包名称 // @Title 文件名称 // @Description 文件描述 // @Create 创建作者 日期 时间 // @Update 更新作者 日期 时间 结构体注释和接口注释 # 每个结构体或接口都应有注释 在结构体或接口定义上面，需要有一个对整个结构体或接口的简要介绍 结构体或接口内的每个成员变量也需要有注释 // User defines user login info type User struct { UserName string // user\u0026#39;s name Password string // user\u0026#39;s password } // IUser defines user function type IUser interface { Login() // user login into the system Logout() // user logout the system } 函数和方法的注释 # 每个函数或方法都应有注释 需要包含函数或方法名称、函数或方法描述、函数或方法的创建作者及其创建时间、输入参数及其参数类型和解释、返回参数及其参数类型和解释 在函数或方法定义上面，书写下面的注释 // 函数或方法名称 // @Description 函数或方法描述 // @Create 作者 日期 时间 // @Param 输入参数名 参数类型 解释 // @Return 返回参数名 参数类型 解释 如果涉及到函数或方法的变更，需要写明修改作者、修改日期和时间、修改的功能描述 // @Modified 作者 日期 时间 // @Modify description 修改的功能描述 代码逻辑注释 # 每个代码块都需要添加注释 // This is my wife\u0026#39;s birthday if birthday == 1118 { ... } 配置 # 本配置均采用Goland IDE 包注释和文件注释配置 #Mac 使用 # Goland-\u0026gt;Settings-\u0026gt;Editor-\u0026gt;File and Code Templates-\u0026gt;Go File 复制下面的模版，替换原先的模版 // package ${GO_PACKAGE_NAME} // @Title ${FILE_NAME} // @Description // @Create XdpCs ${YEAR}-${MONTH}-${DAY} ${TIME} // @Update XdpCs ${YEAR}-${MONTH}-${DAY} ${TIME} 修改注释的快捷键配置 #Mac 使用 # Goland-\u0026gt;Settings-\u0026gt;Editor-\u0026gt;Live Templates 复制下面的模版，替换原先的模版 // @Modified XdpCs $date$ $time$:00 // @Modify description 点击Edit Variables\u0026hellip; 配置如下图所示 配置完成后，点击Define，勾选Go 使用只需要使用modify+回车即可 结构体注释、接口注释、函数注释、方法注释 #安装插件 # Goanno插件 同时也可以使用Goland的Marketplace搜索进行安装 配置插件注释格式，使用Tools-\u0026gt; Goanno Settings 函数注释、方法注释 # Normal Method 配置、Interface Method 配置 // ${function_name} // @Description ${todo} // @Create XdpCs ${date} // @Param ${param_name} ${param_type} // @Return ${ret_name_type} 结构体注释 # Struct 配置 // ${struct_name} 接口注释 # Interface 配置 // ${interface_name} 测试 # 使用control + command + /进行测试 示例 #示例\n","date":"13 March 2023","permalink":"/blogs/go/go_code_comment_standard/","section":"Blog","summary":"背景 # 当新接手他人的项目，我们很容易不知所措，不知道这个函数的作用是什么，即使有很好的命名规范，这种事情也会时常发生，甚至有时候几个月不碰这个项目，自己再看这个函数，也会有一种云里雾里的感觉 如果拥有好的注释，方便我们自己以后维护，也方便后来的同事接手你的项目，不至于对你的代码说这写的是啥，像一坨💩 注释规范 # 注释语言看团队，我们团队习惯使用英文，所以都使用英文，只要整个团队统一一个注释语言即可 全部使用单行注释,//后需要使用一个空格 包注释 # 包注释是对包的介绍 每个包都至少有一个包注释，在同一个包下，任一一个源文件中注释即可 放置在package之前，来简短描述这个包的功能 // 包的功能介绍 package 包名称 文件注释 # 每个文件都应有一个文件注释 放置在package之后，需要包含文件名称，文件描述，文件作者及其时间，更新作者及其时间 因为在公司正常开发流程中，可能合并分支的时候，只有自己部门的业务主管，有这个权限进行合并代码，如果去看git的日志，如果只看主分支，只会显示主管的id，很难很快落实到每个人上 package 包名称 // @Title 文件名称 // @Description 文件描述 // @Create 创建作者 日期 时间 // @Update 更新作者 日期 时间 结构体注释和接口注释 # 每个结构体或接口都应有注释 在结构体或接口定义上面，需要有一个对整个结构体或接口的简要介绍 结构体或接口内的每个成员变量也需要有注释 // User defines user login info type User struct { UserName string // user\u0026#39;s name Password string // user\u0026#39;s password } // IUser defines user function type IUser interface { Login() // user login into the system Logout() // user logout the system } 函数和方法的注释 # 每个函数或方法都应有注释 需要包含函数或方法名称、函数或方法描述、函数或方法的创建作者及其创建时间、输入参数及其参数类型和解释、返回参数及其参数类型和解释 在函数或方法定义上面，书写下面的注释 // 函数或方法名称 // @Description 函数或方法描述 // @Create 作者 日期 时间 // @Param 输入参数名 参数类型 解释 // @Return 返回参数名 参数类型 解释 如果涉及到函数或方法的变更，需要写明修改作者、修改日期和时间、修改的功能描述 // @Modified 作者 日期 时间 // @Modify description 修改的功能描述 代码逻辑注释 # 每个代码块都需要添加注释 // This is my wife\u0026#39;s birthday if birthday == 1118 { .","title":"Go语言注释规范"},{"content":" 公共模块代理: export GOPROXY=https://goproxy.io 同样可以设置为 https://goproxy.cn\n私有模块代理： export GOPRIVATE=git.xxx.com 初始化： go mod init [module 名称] 检测和清理依赖： go mod tidy 安装指定包： go get -v github.com/go-ego/gse@v0.60.0-rc4.2 go mod下，go get github.com/go-ego/gse@v0.60.0 可以跟语义化版本号，也可以跟git的分支go get github.com/go-ego/gse@master ,也可以跟git的提交哈希go get github.com/go-ego/gse@e3702bed2 go get遵循最小版本选择原则，只会下载不超过这个最大版本号，如果使用go get github.com/go-ego/gse@master ，下次在下载只会和第一次的一样，无论 master 分支是否更新了代码\n查看所有可以升级依赖版本： go list -u -m all 更新依赖： go get -u 更新指定包依赖： go get -u github.com/go-ego/gse 更新补丁版本号 go get -u=patch github.com/go-ego/gse 指定版本： go get -u github/com/go-ego/gse@v0.60.0-rc4.2 升降级版本号，使用比较运算符控制 go get github/com/go-ego/gse@`\u0026lt;v0.60.0` Replace:\n使用命令行： go mod edit -replace github.com/go-ego/gse = /path/to/local/gse go mod edit -replace github.com/go-ego/gse = github.com/vcaesar/gse 直接修改模块文件： replace github.com/go-ego/gse =\u0026gt; github.com/vcaesar/gse 移除依赖： go mod tidy go mod edit --droprequire=golang.org/x/crypto,仅仅修改go.mod配置文件的内容\n查看依赖包： go list -m all go list -m -json all # json 格式输出 模块配置格式化 go mod edit -fmt 常用命令： go mod init # 初始化 go mod tidy # 更新依赖文件,移除不需要的包 go mod download # 下载依赖文件 go mod vendor # 将依赖转移至本地的 vendor文件 go mod edit # 手动修改依赖文件 go mod graph # 打印依赖图 go mod verify # 校验依赖 在go mod模式，如果没有此依赖，在运行go run main.go会先去下载此依赖，当然不只是go run,go build、go test 命令也能自动下载相关依赖包\ngo mod不会在$GOPATH/src目录下保存相关引用包的源码，而包源码和链接库保存在$GOPATH/pkg/mod目录下\n","date":"21 January 2023","permalink":"/blogs/go/go_module/","section":"Blog","summary":"公共模块代理: export GOPROXY=https://goproxy.","title":"Go Module"},{"content":"","date":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo"},{"content":"问题1 #found no layout file for \u0026#34;HTML\u0026#34; for kind \u0026#34;page\u0026#34;: You should create a template file which matches Hugo Layouts Lookup Rules for this combination. 解决方法 #hugo mod clean hugo server ","date":"29 November 2022","permalink":"/blogs/hugo/hugo_error/","section":"Blog","summary":"问题1 #found no layout file for \u0026#34;HTML\u0026#34; for kind \u0026#34;page\u0026#34;: You should create a template file which matches Hugo Layouts Lookup Rules for this combination.","title":"hugo 遇到的问题"},{"content":"","date":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git"},{"content":"原理 # 本地仓库由git维护三棵\u0026quot;树\u0026quot; 第一个是工作目录,它拥有实际的文件 第二个是暂存区，它类似于缓存的存在，临时保存你的改动 第三个是HEAD,它指向最后一次提交的结果 概念 #分支 # 分支是用来将特性开发隔离开。在你创建仓库的时候，master或main是默认的分支。我们一般在其他分支上进行开发，完成后再将它们合并到主分支上 你在本地创建的分支，如果不推送到远端仓库，这个分支就只能在本地可见 命令 # 命令只介绍在开发过程中，常用的命令 创建新的git仓库 #git init 添加到暂存区 #git add \u0026lt;filename\u0026gt; git add . git add \u0026lt;filename\u0026gt; ,添加具体文件到暂存区 git add .,将所有变动添加到暂存区 这是git基本工作流程的第一步，将文件添加到暂存区 提交 #git commit -m \u0026#34;提交信息\u0026#34; 将改动提交到本地仓库的HEAD中 这是git基本工作流程的第二步，将文件提交到本地仓库的HEAD中 推送 #git push origin master 将改动提交到远端仓库，可以将master换成任何你想要推送的分支 这是git基本工作流程的第三步，推送到远端仓库 git remote add origin \u0026lt;server\u0026gt; 将你的仓库连接到远端仓库，若你本地仓库未和远端仓库建立关系 分支 #git checkout -b feature_xdp 创建一个叫做feature_xdp的分支 git checkout master 切换到主分支 更新与合并 #git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; 标准格式 以当前工作目录进行获取（fetch）并合并（merge）远端的改动 git pull git pull origin 将远端仓库的origin的master分支拉取到本地，并与本地的当前分支进行合并 git pull origin master:feature_xdp 将远端仓库的origin的master分支拉取过来，与本地的feature_xdp分支合并 git pull origin master 如果远端仓库的分支是与当前分支合并，则冒号后面的部分可以省略 git merge \u0026lt;branch\u0026gt; 合并其他分支到当前分支 冲突 # git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; 和 git merge \u0026lt;branch\u0026gt;,在两种情况下，git 会尝试自动合并改动，但是并不是每一次都会成功，可能会出现冲突。这个时候，需要你手动修改来合并这些冲突 git add \u0026lt;filename\u0026gt; 合并完成后，需要将它们添加到暂存区 git diff \u0026lt;source_branch\u0026gt; \u0026lt;target_branch\u0026gt; 可以使用该命令预览差异，在合并改动之前 log #git log 查看本地仓库历史记录 git log --author=XdpCs 只看XdpCs的提交记录 git log --pretty=oneline 每一条提交记录只占一行输出 git log --graph --oneline --decorate --all 通过树形结构来展示所有的分支，每个分支都标明它的名字和标签 git log --name-status 查看哪些文件发生改变 标签 # 通过创建标签，发布软件是一个不错的方法 git tag 1.0.0 1fd11181114 创建一个叫1.0.0的标签，1fd11181114是你想要标记的提交ID 提交ID可以通过上面的git log获取 只要提交ID具有指向唯一性，提交ID可以少几位 替换本地改动 #git checkout -- \u0026lt;filename\u0026gt; 使用HEAD中最新的内容替换掉你工作目录中的文件 已添加到暂存区的改动和新文件不会受到影响 git fetch origin git reset --hard origin/master 丢弃本地的所有改动和提交，从远端服务器获取最新的版本历史，并将本地分支指向它 克隆仓库 #git clone ../xdpcs.github.io 创建一个本地仓库的克隆版本 git clone git@github.com:XdpCs/Solidity-Learning.git 克隆一个远端服务器上的仓库 ","date":"18 November 2022","permalink":"/blogs/git/git_study/","section":"Blog","summary":"原理 # 本地仓库由git维护三棵\u0026quot;树\u0026quot; 第一个是工作目录,它拥有实际的文件 第二个是暂存区，它类似于缓存的存在，临时保存你的改动 第三个是HEAD,它指向最后一次提交的结果 概念 #分支 # 分支是用来将特性开发隔离开。在你创建仓库的时候，master或main是默认的分支。我们一般在其他分支上进行开发，完成后再将它们合并到主分支上 你在本地创建的分支，如果不推送到远端仓库，这个分支就只能在本地可见 命令 # 命令只介绍在开发过程中，常用的命令 创建新的git仓库 #git init 添加到暂存区 #git add \u0026lt;filename\u0026gt; git add .","title":"Git 学习"},{"content":"","date":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects"},{"content":"","date":null,"permalink":"/tags/web3/","section":"Tags","summary":"","title":"Web3"},{"content":"Hi! My name is Alan Xu. #Enjoy any project that uses the Go programming language. #Currently, learning English, Go, Solidity, Mysql, and Redis. #","date":null,"permalink":"/","section":"Welcome to XdpCs’s blog!","summary":"Hi! My name is Alan Xu.","title":"Welcome to XdpCs’s blog!"},{"content":"","date":null,"permalink":"/tags/architecture/","section":"Tags","summary":"","title":"Architecture"},{"content":"","date":null,"permalink":"/tags/fpga/","section":"Tags","summary":"","title":"Fpga"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/solidity/","section":"Tags","summary":"","title":"Solidity"},{"content":" 2022年从杭州不知名院校本科毕业 本科前两年一直研究嵌入式，参加过智能车竞赛、电子设计竞赛，获得了一些奖项 后面随着大流，接触Java，那时候不知道自己要做什么样的工作，要成为什么样的人 机缘巧合入职后，将自己的技术栈转换到Golang 虽然现在我的依然不知道自己想要做什么样的工作，想要成为什么样的人，但我一直在寻找自己真正感兴趣的方向 Contact # GitHub Email ","date":null,"permalink":"/about/","section":"Welcome to XdpCs’s blog!","summary":" 2022年从杭州不知名院校本科毕业 本科前两年一直研究嵌入式，参加过智能车竞赛、电子设计竞赛，获得了一些奖项 后面随着大流，接触Java，那时候不知道自己要做什么样的工作，要成为什么样的人 机缘巧合入职后，将自己的技术栈转换到Golang 虽然现在我的依然不知道自己想要做什么样的工作，想要成为什么样的人，但我一直在寻找自己真正感兴趣的方向 Contact # GitHub Email ","title":"关于我"}]