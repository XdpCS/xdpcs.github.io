<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on XdpCs's Website</title><link>https://xdpcs.github.io/blogs/</link><description>Recent content in Blog on XdpCs's Website</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© Alan Xu</copyright><lastBuildDate>Thu, 09 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://xdpcs.github.io/blogs/index.xml" rel="self" type="application/rss+xml"/><item><title>Go打印结构体指针中的具体内容，而无需实现String()方法</title><link>https://xdpcs.github.io/blogs/go/print_value/</link><pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/go/print_value/</guid><description>痛点 #例子 #package main import &amp;#34;fmt&amp;#34; type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func main() { t := &amp;amp;TreeNode{ Val: 1, Left: &amp;amp;TreeNode{ Val: 2, }, Right: &amp;amp;TreeNode{ Val: 3, }, } fmt.</description></item><item><title>第1章-入门-笔记</title><link>https://xdpcs.github.io/blogs/gopl/ch1/</link><pubDate>Mon, 07 Aug 2023 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/gopl/ch1/</guid><description>1.1 hello,world # Go是编译型语言 Go的工具链将程序的源文件转变成为机器相关的原生二进制指令 go run 将一个或多个以.</description></item><item><title>Go语言注释规范</title><link>https://xdpcs.github.io/blogs/go/go_code_comment_standard/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/go/go_code_comment_standard/</guid><description>背景 # 当新接手他人的项目，我们很容易不知所措，不知道这个函数的作用是什么，即使有很好的命名规范，这种事情也会时常发生，甚至有时候几个月不碰这个项目，自己再看这个函数，也会有一种云里雾里的感觉 如果拥有好的注释，方便我们自己以后维护，也方便后来的同事接手你的项目，不至于对你的代码说这写的是啥，像一坨💩 注释规范 # 注释语言看团队，我们团队习惯使用英文，所以都使用英文，只要整个团队统一一个注释语言即可 全部使用单行注释,//后需要使用一个空格 包注释 # 包注释是对包的介绍 每个包都至少有一个包注释，在同一个包下，任一一个源文件中注释即可 放置在package之前，来简短描述这个包的功能 // 包的功能介绍 package 包名称 文件注释 # 每个文件都应有一个文件注释 放置在package之后，需要包含文件名称，文件描述，文件作者及其时间，更新作者及其时间 因为在公司正常开发流程中，可能合并分支的时候，只有自己部门的业务主管，有这个权限进行合并代码，如果去看git的日志，如果只看主分支，只会显示主管的id，很难很快落实到每个人上 package 包名称 // @Title 文件名称 // @Description 文件描述 // @Create 创建作者 日期 时间 // @Update 更新作者 日期 时间 结构体注释和接口注释 # 每个结构体或接口都应有注释 在结构体或接口定义上面，需要有一个对整个结构体或接口的简要介绍 结构体或接口内的每个成员变量也需要有注释 // User defines user login info type User struct { UserName string // user&amp;#39;s name Password string // user&amp;#39;s password } // IUser defines user function type IUser interface { Login() // user login into the system Logout() // user logout the system } 函数和方法的注释 # 每个函数或方法都应有注释 需要包含函数或方法名称、函数或方法描述、函数或方法的创建作者及其创建时间、输入参数及其参数类型和解释、返回参数及其参数类型和解释 在函数或方法定义上面，书写下面的注释 // 函数或方法名称 // @Description 函数或方法描述 // @Create 作者 日期 时间 // @Param 输入参数名 参数类型 解释 // @Return 返回参数名 参数类型 解释 如果涉及到函数或方法的变更，需要写明修改作者、修改日期和时间、修改的功能描述 // @Modified 作者 日期 时间 // @Modify description 修改的功能描述 代码逻辑注释 # 每个代码块都需要添加注释 // This is my wife&amp;#39;s birthday if birthday == 1118 { .</description></item><item><title>Go Module</title><link>https://xdpcs.github.io/blogs/go/go_module/</link><pubDate>Sat, 21 Jan 2023 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/go/go_module/</guid><description>公共模块代理: export GOPROXY=https://goproxy.</description></item><item><title>hugo 遇到的问题</title><link>https://xdpcs.github.io/blogs/hugo/hugo_error/</link><pubDate>Tue, 29 Nov 2022 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/hugo/hugo_error/</guid><description>问题1 #found no layout file for &amp;#34;HTML&amp;#34; for kind &amp;#34;page&amp;#34;: You should create a template file which matches Hugo Layouts Lookup Rules for this combination.</description></item><item><title>Git 学习</title><link>https://xdpcs.github.io/blogs/git/git_study/</link><pubDate>Fri, 18 Nov 2022 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/git/git_study/</guid><description>原理 # 本地仓库由git维护三棵&amp;quot;树&amp;quot; 第一个是工作目录,它拥有实际的文件 第二个是暂存区，它类似于缓存的存在，临时保存你的改动 第三个是HEAD,它指向最后一次提交的结果 概念 #分支 # 分支是用来将特性开发隔离开。在你创建仓库的时候，master或main是默认的分支。我们一般在其他分支上进行开发，完成后再将它们合并到主分支上 你在本地创建的分支，如果不推送到远端仓库，这个分支就只能在本地可见 命令 # 命令只介绍在开发过程中，常用的命令 创建新的git仓库 #git init 添加到暂存区 #git add &amp;lt;filename&amp;gt; git add .</description></item><item><title>10-Gas和Gas价格</title><link>https://xdpcs.github.io/blogs/solidity/gas_and_gas_price/</link><pubDate>Tue, 20 Sep 2022 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/solidity/gas_and_gas_price/</guid><description>基础知识 # 需要为一笔交易支付多少Wei?</description></item><item><title>9-时间单位</title><link>https://xdpcs.github.io/blogs/solidity/time/</link><pubDate>Mon, 19 Sep 2022 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/solidity/time/</guid><description>基础知识 # Solidity中自带时间单位，它们分别是 seconds minutes hours days weeks 基本换算关系如下： 1 == 1 seconds 1 minutes == 60 seconds 1 hours == 60 minutes 1 days == 24 hours 1 weeks == 7 days 秒为缺省时间单位 例子 #例子</description></item><item><title>8-以太币单位</title><link>https://xdpcs.github.io/blogs/solidity/ether_and_wei/</link><pubDate>Sun, 18 Sep 2022 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/solidity/ether_and_wei/</guid><description>基础知识 # 以太币单位 单位 Wei Wei值 Wei 1 1 Wei Kwei (babbage) 1,000 1e3 Wei Mwei (lovelace) 1,000,000 1e6 Wei Gwei (shannon) 1,000,000,000 1e9 Wei microether (szabo) 1,000,000,000,000 1e12 Wei milliether (finney) 1,000,000,000,000,000 1e15 Wei ether 1,000,000,000,000,000,000 1e18 Wei 交易需要支付ether 在Solidity中，单位之间的换算是在数字后加上 wei，gwei 或 ether 来实现的 在Solidity中，后面没有单位，缺省为 wei 从Solidity0.</description></item><item><title>7-读取和写入状态变量</title><link>https://xdpcs.github.io/blogs/solidity/read_and_write_state/</link><pubDate>Sat, 17 Sep 2022 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/solidity/read_and_write_state/</guid><description>基础知识 # 写入和更新状态变量需要发送一笔交易 读取状态变量是免费的，无需任何交易费用 例子 #例子</description></item><item><title>6-不可变变量</title><link>https://xdpcs.github.io/blogs/solidity/immutable/</link><pubDate>Fri, 16 Sep 2022 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/solidity/immutable/</guid><description>基础知识 # 不可变变量就像常量 不可变变量的值可以在构造函数中初始化或在声明时初始化，但初始化后就不能被修改了,这样可以节省gas,提高合约的安全性 数值变量可以声明为immutable string和bytes不可以声明为immutable,这不同于constant 例子 #例子</description></item><item><title>5-常量</title><link>https://xdpcs.github.io/blogs/solidity/constants/</link><pubDate>Thu, 15 Sep 2022 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/solidity/constants/</guid><description>基础知识 # 常量是不可修改的变量 它们的值是硬编码的，使用常量可以节省gas成本,还可以提高合约安全性 例子 #例子</description></item><item><title>4-变量</title><link>https://xdpcs.github.io/blogs/solidity/variables/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/solidity/variables/</guid><description>基础知识 # 在Solidity中有3种类型的变量 局部变量 声明在函数内部 不存储在区块链上 状态变量 声明在函数外部 存储在区块链上 全局变量 提供关于区块链上的信息 可以在函数内不声明直接使用 全局变量列举 blockhash(uint blockNumber) returns (bytes32): 指定区块的哈希值&amp;ndash;仅可用于最新的256个区块且不包括当前区块，否则返回0 block.</description></item><item><title>3-原始数据类型</title><link>https://xdpcs.github.io/blogs/solidity/primitives/</link><pubDate>Tue, 13 Sep 2022 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/solidity/primitives/</guid><description>基础知识 # 我将介绍四种在Solidity中可用的原始数据类型，它们都是值类型 bool uint、int address bytes(定长数组) 布尔型(bool) 布尔型的取值只有两种：true和false 布尔型的运算符包括： 比较运算符：&amp;gt;，&amp;gt;=，&amp;lt;，&amp;lt;=，==，!</description></item><item><title>2-第一个App</title><link>https://xdpcs.github.io/blogs/solidity/first_app/</link><pubDate>Mon, 12 Sep 2022 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/solidity/first_app/</guid><description>这是一个计数器合约,在合约中存储一个数,可以对这个数进行增加和减少操作</description></item><item><title>1-你好，世界</title><link>https://xdpcs.github.io/blogs/solidity/hello_world/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/solidity/hello_world/</guid><description>任何一个程序教学，开头都会教你如何写Hello World，此教程也不例外</description></item><item><title>杭电计算机组成实验 实验10-实现R-I-J型指令的CPU设计实验</title><link>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/tenth_experiment/</link><pubDate>Sat, 26 Dec 2020 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/tenth_experiment/</guid><description>实验内容 # 掌握MIPS R型、I型和J型指令的综合数据通路设计，掌握各种转移类指令的控制流和指令流的多路选通控制方法 掌握J型、I型和R型转移指令的指令格式和寻址方式，学习转移地址的产生方法，掌握无条件转移指令和条件转移指令的实现方法 编程实现MIPS的部分J型、I型和R型转移指令的功能 解决方法 # 分析MIPS J型指令的特点，由6位OP字段和26位的address字段构成 分析转移指令的数据通路，转移地址的产生有三种方式，转移地址产生后，要送入PC，才能完成跳转 R型指令还添加了一条无条件跳转指令，要在原来的PC模块判断R型指令的地方进行修改，不能在I型指令下判断，这样会产生冲突 对于条件转移指令beq和bne要使用ALU做减法，判断是否全为零，也就是用ZF判断是否转移 J型指令可以接着I型指令的case结构写下来，与J型case结构无冲突 由于实验九和实验十想法十分接近，主要是控制信号的改变，及其译码模块的改变 涉及实验：具体用到的实验是 多功能ALU设计实验、 寄存器堆设计实验 、 取指令与指令译码实验 代码展示 顶层模块</description></item><item><title>杭电计算机组成实验 实验9-实现R-I型指令的CPU设计实验</title><link>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/ninth_experiment/</link><pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/ninth_experiment/</guid><description>实验内容 # 掌握MIPS R型和I型指令的综合数据通路设计，掌握数据流的多路选通控制方法 掌握取数指令lw和存数指令sw的寻址方式及其有效地址产生的方法 实现MIPS的部分I型和 R型指令的功能 解决方法 # 分析MIPS I型指令的特点，与R型指令有明显的不同：没有rd寄存器，使用rt作为目的寄存器；源操作数中有一个为立即数，位于指令的低16位 在寄存器堆模块的写地址输入端口设置二选一选择器，由于R型和I型的目的寄存器不同，由rd_rt_s控制 16位的立即数imm需要经过扩展才能与rs执行运算操作，对于有符号数的操作，执行的是符号扩展，对于无符号数的操作，执行的是0扩展 R型指令执行rs和rt运算，结果送rd；而I型立即数即数寻址指令则执行rs和扩展后的立即数imm运算，结果送rt。因此ALU的输入数据B端有两个选择：rt或者imm，仍可以通过二选一数据选择器，用rt_imm_s控制信号 需要添加一个数据存储器RAM存放指令访问的数据，读出的数据，意味着要在寄存器堆的写端口加个选择器，用alu_mem_s控制信号，其中要注意一点就是数据存储器的clk至少是CPU频率的2倍以上，我使用了两个clk输入解决这个问题 在实际写代码时，要注意顶层模块中，实例下层模块的顺序，由于译码模块变量多，我将其抽离出来，为了使顶层模块看起来简洁 涉及实验： 具体用到的实验是 多功能ALU设计实验、 寄存器堆设计实验 、 取指令与指令译码实验 代码展示 顶层模块</description></item><item><title>杭电计算机组成实验 实验8-实现R型指令的CPU设计实验</title><link>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/eighth_experiment/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/eighth_experiment/</guid><description>实验内容 # 掌握MIPS R型指令的数据通路设计，掌握指令流和数据流的控制方法 掌握完整的单周期CPU顶层模块的设计方法 实现MIPS R型指令的功能 解决方法 # 分析MIPS R型指令的特点，OP均为000000b，可作为判断R型指令的依据 两个源操作数分别在rs和rt字段所指定的寄存器中，而目的操作数则是在rd字段所指定的寄存器 3.</description></item><item><title>杭电计算机组成实验 实验5-存储器设计实验</title><link>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/fifth_experiment/</link><pubDate>Tue, 22 Dec 2020 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/fifth_experiment/</guid><description>实验内容 # 掌握灵活运用 Verilog HDL 进行各种描述与建模的技巧和方法 学习在 ISE 中设计生成 Memory IP 核的方法 学习存储器的结构及读写原理，掌握存储器的设计方法 解决方法 # 分析一个 256x8 位的物理存储器，具有读 写功能，按字节编址，按字访问， 即 64x32 位。</description></item><item><title>杭电计算机组成实验 实验6-MIPS汇编器与模拟器实验</title><link>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/sixth_experiment/</link><pubDate>Tue, 22 Dec 2020 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/sixth_experiment/</guid><description>实验内容 # 学习 MIPS指令系统，熟悉 MIPS指令格式及其汇编指令助记符，掌握机器 指令编码方法 学习 MIPS汇编程序设计，学会使用 MIPS 汇编器将汇编语言程序翻译成二 进制文件 了解使用 MIPS教学系统模拟器运行程序的方法 解决方法 # 下载 PCSpim 软件 给大家一个下载的地方，只要关注我，就可以下载到PCSpim下载地址 按照书上的要求，在文本编辑器中输入汇编程序，然后装入PCSpim 左侧内为指令地址，中间是十六进制的指令编码，右侧是相应的标准汇编指 令，主要注意的是第二个程序，必须在裸机执行方式 书上的汇编和结果展示： test.</description></item><item><title>杭电计算机组成实验 实验7-取指令与指令译码实验</title><link>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/seventh_experiment/</link><pubDate>Tue, 22 Dec 2020 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/seventh_experiment/</guid><description>实验内容 # 学习指令存储器的设计 掌握CPU取指令操作与指令译码的方法和过程 解决方法 # 本次实验设计采用哈佛结构设计存储器模块，需要设计一个只读存储器作为指令存储器，采用Memory IP核实现（不会用Memory IP核，可以看我这个博文 存储器实验 程序计数器PC与PC自增加法器组合成一个模块，由于指令存储器只有64个32位单元，所以PC的32位指令地址的高24位可直接在设计中清零 需要注意在指令周期clk的上升沿执行取指令操作，在clk下降沿更新PC值 代码展示: 顶层模块</description></item><item><title>杭电计算机组成实验 实验1-全加器设计实验</title><link>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/first_experiment/</link><pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/first_experiment/</guid><description>实验内容 # 学习ISE工具软件的使用及仿真方法 学习FPGA程序的下载方式 熟悉Nexys3实验板 掌握运用Verilog HDL 进行结构描述与建模的技术和方法 掌握二进制全加器的原理与设计 解决方法 # 分析二进制全加器的输入输出，然后得出两个输出端口的门电路。 使用ISE内部门级电路进行组合，最后实现实验所需的效果 代码展示： 顶层模块：</description></item><item><title>杭电计算机组成实验 实验2-超前进位加法器设计实验</title><link>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/second_experiment/</link><pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/second_experiment/</guid><description>实验内容 # 掌握运用Verilog HDL进行数据流描述与建模的技巧和方法，掌握模块调用与实例引用的方法 掌握超前进位加法器的原理与设计方法 解决方法 # 分析4位的二进制全加器的输入输出，内部为超前进位逻辑 首先，要知道超前进位逻辑与行波进位加法器的区别 行波进位加法器需要像链子一样，等第一位算完，再算第二位，而超前进位加法器是四位同时，第二位包括了第一位的计算部分，从而达到消除依赖的关系 代码展示： 顶层模块</description></item><item><title>杭电计算机组成实验 实验3-多功能ALU设计实验</title><link>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/third_experiment/</link><pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/third_experiment/</guid><description>实验内容 # 学习多功能ALU的工作原理，掌握运算器的设计方法 掌握运用Verilog HDL 进行行为描述与建模的技巧和方法 解决方法 # 分析一个具有8种运算功能的32位ALU，并能够产生运算结果的标志：结果位零标志（ZF）和溢出标志（OF） 首先，分析出ZF只会在加减运算中出现溢出情况，然后分析出ALU 8种计算如何表达，如果使用“-”，就不用考虑如何减法 代码展示： 顶层模块：</description></item><item><title>杭电计算机组成实验 实验4-寄存器堆设计实验</title><link>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/fourth_experiment/</link><pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate><guid>https://xdpcs.github.io/blogs/hdu_computer_organization_and_architecture_experiment/fourth_experiment/</guid><description>实验内容 # 学习使用Verilog HDL 进行时序电路的设计方法 掌握灵活运用Verilog HDL进行各种描述与建模的技巧和方法 学习寄存器堆的数据传送与读/写工作原理，掌握寄存器堆的设计方法 解决方法 # 分析一个32x32位的寄存器堆，即含有32个寄存器，每个寄存器32位。该寄存器堆有2个读端口、1个写端口，即能够同时读出2个寄存器的值，写入1个寄存器 首先，分析出两个端口读入是5位的地址，读出的数据是32位的两个，该寄存器堆只有一个写端口，还要配合控制信号Write_Reg，且写操作是边沿触发的，所有写入操作的输入信号必须在时钟边沿来临时已经有效 寄存器堆的读操作和写操作的地址译码，只需引用寄存器地址作为数组的下标即可；读只需要组合逻辑，给出寄存器地址，读出数据 代码展示： 顶层模块（需要数据输入在板子上操作）：</description></item></channel></rss>