[{"content":"","date":"18 November 2022","permalink":"/projects/solidity-learning/","section":"Projects","summary":"","title":"Solidity-Learning"},{"content":"","date":"25 December 2020","permalink":"/projects/hdu-computer-organization-and-architecture-experiment/","section":"Projects","summary":"","title":"杭电计算机组成实验"},{"content":"","date":"18 November 2022","permalink":"/projects/","section":"Projects","summary":"","title":"Projects"},{"content":"","date":"18 November 2022","permalink":"/tags/solidity/","section":"Tags","summary":"","title":"solidity"},{"content":"","date":"18 November 2022","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"18 November 2022","permalink":"/tags/web3/","section":"Tags","summary":"","title":"web3"},{"content":"Welcome to my website! I\u0026rsquo;m really happy you stopped by. # ","date":"18 June 2022","permalink":"/","section":"Welcome to XdpCs’s blog!","summary":"Welcome to my website!","title":"Welcome to XdpCs’s blog!"},{"content":"","date":"26 December 2020","permalink":"/posts/","section":"Blog","summary":"","title":"Blog"},{"content":"","date":"26 December 2020","permalink":"/tags/r-i-j%E5%9E%8B%E6%8C%87%E4%BB%A4/","section":"Tags","summary":"","title":"R-I-J型指令"},{"content":"实验内容 # 掌握MIPS R型、I型和J型指令的综合数据通路设计，掌握各种转移类指令的控制流和指令流的多路选通控制方法 掌握J型、I型和R型转移指令的指令格式和寻址方式，学习转移地址的产生方法，掌握无条件转移指令和条件转移指令的实现方法 编程实现MIPS的部分J型、I型和R型转移指令的功能 解决方法 # 分析MIPS J型指令的特点，由6位OP字段和26位的address字段构成 分析转移指令的数据通路，转移地址的产生有三种方式，转移地址产生后，要送入PC，才能完成跳转 R型指令还添加了一条无条件跳转指令，要在原来的PC模块判断R型指令的地方进行修改，不能在I型指令下判断，这样会产生冲突 对于条件转移指令beq和bne要使用ALU做减法，判断是否全为零，也就是用ZF判断是否转移 J型指令可以接着I型指令的case结构写下来，与J型case结构无冲突 由于实验九和实验十想法十分接近，主要是控制信号的改变，及其译码模块的改变 涉及实验：具体用到的实验是多功能ALU设计实验、寄存器堆设计实验 、取指令与指令译码实验 代码展示 顶层模块\nmodule CPU(clk,rst,OF,ZF,F,ALU_OP,M_R_Data,w_r_s,imm_s,rt_imm_s,Mem_Write,Write_Reg,PC,PC_s,clk_M,R_Data_B,Inst_code); input clk,rst,clk_M; output [31:0]Inst_code; wire [5:0]op_code,funct; wire [4:0]rs_addr,rt_addr,rd_addr,shamt; output [31:0]F; output OF,ZF; output [31:0]M_R_Data; output [2:0]ALU_OP; wire [31:0]Mem_Addr; wire [4:0]W_Addr; output imm_s,rt_imm_s,Mem_Write,Write_Reg; output [1:0]w_r_s; wire [31:0]imm_data; wire [31:0]R_Data_A; output [31:0]R_Data_B; wire [15:0]imm; wire [31:0]ALU_B; wire [31:0]W_Data; output [1:0]PC_s; wire [25:0]address; wire [1:0]wr_data_s; wire [31:0]PC_new; output [31:0]PC; PC pc1(clk,rst,Inst_code,PC_s,R_Data_A,address,PC,imm_data,PC_new); assign op_code = Inst_code[31:26]; assign rs_addr = Inst_code[25:21]; assign rt_addr = Inst_code[20:16]; assign rd_addr = Inst_code[15:11]; assign shamt = Inst_code[10:6]; assign funct = Inst_code[5:0]; assign imm = Inst_code[15:0]; assign address = Inst_code[25:0]; OP_Func op(op_code,funct,Write_Reg,ALU_OP,w_r_s,imm_s,rt_imm_s,Mem_Write,wr_data_s,PC_s,ZF); assign W_Addr = (w_r_s[1])?5\u0026#39;b11111:((w_r_s[0])?rt_addr:rd_addr); assign imm_data = (imm_s)?{{16{imm[15]}},imm}:{{16{1\u0026#39;b0}},imm}; Fourth_experiment_first F1(rs_addr,rt_addr,Write_Reg,R_Data_A,R_Data_B,rst,~clk,W_Addr,W_Data); assign ALU_B = (rt_imm_s)?imm_data:R_Data_B; Third_experiment_first T1(OF,ZF,ALU_OP,R_Data_A,ALU_B,F); RAM RAM_B ( .clka(clk_M), // input clka .wea(Mem_Write), // input [0 : 0] wea .addra(F[5:0]), // input [5 : 0] addra .dina(R_Data_B), // input [31 : 0] dina .douta(M_R_Data) // output [31 : 0] douta ); assign W_Data = (wr_data_s[1])?PC_new:((wr_data_s[0])? M_R_Data:F); endmodule PC（取指令模块）\nmodule PC(clk,rst,Inst_code,PC_s,R_Data_A,address,PC,imm_data,PC_new); input clk,rst; input [1:0]PC_s; input [31:0]R_Data_A; input [25:0]address; input [31:0]imm_data; output reg[31:0]PC; output [31:0]PC_new; initial PC = 32\u0026#39;h0000_0000; output [31:0]Inst_code; assign PC_new = PC +4; Inst_Rom rom( .clka(clk), // input clka .addra(PC[7:2]), // input [5 : 0] addra .douta(Inst_code) // output [31 : 0] douta ); always@(negedge clk or posedge rst) begin if(rst) begin PC \u0026lt;= 32\u0026#39;h0000_0000; end else begin case (PC_s) 2\u0026#39;b00:\tPC \u0026lt;= PC_new; 2\u0026#39;b01:\tPC \u0026lt;= R_Data_A;\t2\u0026#39;b10: PC \u0026lt;= PC_new + (imm_data\u0026lt;\u0026lt;2);\t2\u0026#39;b11:\tPC \u0026lt;= {PC_new[31:28],address,2\u0026#39;b00}; endcase end end endmodule OP_Func（译码模块）\nmodule OP_Func(op_code,funct,Write_Reg,ALU_OP,w_r_s,imm_s,rt_imm_s,Mem_Write,wr_data_s,PC_s,ZF); input [5:0]op_code; input [5:0]funct; input ZF; output reg[2:0]ALU_OP; output reg Write_Reg; output reg [1:0]wr_data_s; output reg imm_s; output reg rt_imm_s; output reg Mem_Write; output reg [1:0]w_r_s; output reg [1:0]PC_s; always@(*) begin\tWrite_Reg=1; ALU_OP=3\u0026#39;b100; wr_data_s=0; imm_s=0; rt_imm_s=0; Mem_Write=0; w_r_s=0; PC_s = 0; if(op_code==6\u0026#39;b000000) begin case(funct) 6\u0026#39;b100000:begin ALU_OP=3\u0026#39;b100; end 6\u0026#39;b100010:begin ALU_OP=3\u0026#39;b101; end 6\u0026#39;b100100:begin ALU_OP=3\u0026#39;b000;end 6\u0026#39;b100101:begin ALU_OP=3\u0026#39;b001;end 6\u0026#39;b100110:begin ALU_OP=3\u0026#39;b010;end 6\u0026#39;b100111:begin ALU_OP=3\u0026#39;b011;end 6\u0026#39;b101011:begin ALU_OP=3\u0026#39;b110;end 6\u0026#39;b000100:begin ALU_OP=3\u0026#39;b111;end 6\u0026#39;b001000:begin Write_Reg=0;Mem_Write=0;PC_s = 2\u0026#39;b01; end endcase end else begin case(op_code) 6\u0026#39;b001000:begin w_r_s=2\u0026#39;b01;imm_s=1;rt_imm_s=1;ALU_OP=3\u0026#39;b100;end 6\u0026#39;b001100:begin w_r_s=2\u0026#39;b01;rt_imm_s=1;ALU_OP=3\u0026#39;b000; end 6\u0026#39;b001110:begin w_r_s=2\u0026#39;b01;rt_imm_s=1;ALU_OP=3\u0026#39;b010;end 6\u0026#39;b001011:begin w_r_s=2\u0026#39;b01;rt_imm_s=1;ALU_OP=3\u0026#39;b110; end 6\u0026#39;b100011:begin w_r_s=2\u0026#39;b01;imm_s=1;rt_imm_s=1;wr_data_s=2\u0026#39;b01;ALU_OP=3\u0026#39;b100; end 6\u0026#39;b101011:begin imm_s=1;rt_imm_s=1;ALU_OP=3\u0026#39;b100;Write_Reg=0;Mem_Write=1; end 6\u0026#39;b000100:begin ALU_OP=3\u0026#39;b101;PC_s = (ZF)?2\u0026#39;b10:2\u0026#39;b00; Write_Reg = 1\u0026#39;b0;end 6\u0026#39;b000101:begin ALU_OP=3\u0026#39;b101;PC_s = (ZF)?2\u0026#39;b00:2\u0026#39;b10; Write_Reg = 1\u0026#39;b0;end 6\u0026#39;b000010:begin Write_Reg=0;PC_s = 2\u0026#39;b11; end 6\u0026#39;b000011:begin w_r_s=2\u0026#39;b10;wr_data_s=2\u0026#39;b10;PC_s = 2\u0026#39;b11; end endcase end end endmodule Fourth_experiment_first（寄存器堆模块）\nmodule Fourth_experiment_first(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,W_Addr,W_Data); input [4:0]R_Addr_A,R_Addr_B,W_Addr; input Write_Reg,Reset,Clk; input[31:0] W_Data; output [31:0] R_Data_A,R_Data_B; reg [31:0] REG_Files[0:31]; integer i=0; initial for(i=0;i\u0026lt;32;i=i+1) REG_Files[i]\u0026lt;=0; always @ (posedge Clk or posedge Reset) begin if(Reset) begin for(i=0;i\u0026lt;=31;i=i+1) REG_Files[i]\u0026lt;=0; end else begin if(Write_Reg) REG_Files[W_Addr]\u0026lt;=W_Data; end end assign R_Data_A = REG_Files[R_Addr_A]; assign R_Data_B = REG_Files[R_Addr_B]; endmodule Third_experiment_first（ALU模块）\nmodule Third_experiment_first(OF,ZF,ALU_OP,A,B,F); input [2:0]ALU_OP; input [31:0]A,B; output reg[31:0]F; reg C32; output reg OF; output reg ZF; always @(ALU_OP or A or B) begin OF = 0; C32 = 0; case(ALU_OP) 3\u0026#39;b000:F\u0026lt;=A\u0026amp;B; 3\u0026#39;b001:F\u0026lt;=A|B; 3\u0026#39;b010:F\u0026lt;=A^B; 3\u0026#39;b011:F\u0026lt;=A~^B; 3\u0026#39;b100:{C32,F}\u0026lt;=A+B; 3\u0026#39;b101:{C32,F}\u0026lt;=A-B; 3\u0026#39;b110:begin if(A\u0026lt;B) F\u0026lt;=32\u0026#39;h0000_0001;else F\u0026lt;=32\u0026#39;h0000_0000;end 3\u0026#39;b111:begin F\u0026lt;=B\u0026lt;\u0026lt;A;end endcase if(F==32\u0026#39;h0000_0000)\tZF\u0026lt;=1; else ZF\u0026lt;=0; if(ALU_OP == 3\u0026#39;b100 || ALU_OP == 3\u0026#39;b101) OF\u0026lt;=C32^F[31]^A[31]^B[31];\telse OF \u0026lt;=0; end endmodule 数据.coe\nmemory_initialization_radix=16; memory_initialization_vector=88888888,99999999,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999, aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff, 20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb, 00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,12345678,23456789,3456789a,6789abcd; 程序机器码.coe\nmemory_initialization_radix=16; memory_initialization_vector=00002020,20050014,2006000b,0c000004,00804020,00a04820,00c05020,8d0b0000,ad2b0000,21080001,21290001,214affff,1540fffa,03e00008; 测试模块\nmodule test; // Inputs reg clk; reg rst; reg clk_M; // Outputs wire OF; wire ZF; wire [31:0] F; wire [2:0] ALU_OP; wire [31:0] M_R_Data; wire [1:0] w_r_s; wire imm_s; wire rt_imm_s; wire Mem_Write; wire Write_Reg; wire [31:0] PC; wire [1:0] PC_s; wire [31:0] R_Data_B; wire [31:0] Inst_code; CPU uut ( .clk(clk), .rst(rst), .OF(OF), .ZF(ZF), .F(F), .ALU_OP(ALU_OP), .M_R_Data(M_R_Data), .w_r_s(w_r_s), .imm_s(imm_s), .rt_imm_s(rt_imm_s), .Mem_Write(Mem_Write), .Write_Reg(Write_Reg), .PC(PC), .PC_s(PC_s), .clk_M(clk_M), .R_Data_B(R_Data_B), .Inst_code(Inst_code) ); always #4 clk_M = ~clk_M; always #16 clk =~clk; initial begin clk = 0; rst = 1; clk_M = 0; #2; rst = 0; end endmodule 汇编程序\nmain: add $a0,$zero,$zero addi $a1,$zero,20; addi $a2,$zero,10; jal BankMove BankMove: add $t0,$a0,$zero; add $t1,$a1,$zero; add $t2,$a2,$zero; Loop1:lw $t3,0($t0); sw $t3,0($t1); addi $t0,$t0,1; addi $t1,$t1,1; addi $t2,$t2,-1; bne $t2,$zero,Loop1; jr $ra 友情提示 # 书上的机器码存在错误，读者可以自行对比，纠正机器码，博主用的汇编程序是将存储器1-10位搬到20-30位\n代码地址 # 代码地址\n","date":"26 December 2020","permalink":"/posts/hdu-computer-organization-and-architecture-experiment/tenth_experiment/","section":"Blog","summary":"实验内容 # 掌握MIPS R型、I型和J型指令的综合数据通路设计，掌握各种转移类指令的控制流和指令流的多路选通控制方法 掌握J型、I型和R型转移指令的指令格式和寻址方式，学习转移地址的产生方法，掌握无条件转移指令和条件转移指令的实现方法 编程实现MIPS的部分J型、I型和R型转移指令的功能 解决方法 # 分析MIPS J型指令的特点，由6位OP字段和26位的address字段构成 分析转移指令的数据通路，转移地址的产生有三种方式，转移地址产生后，要送入PC，才能完成跳转 R型指令还添加了一条无条件跳转指令，要在原来的PC模块判断R型指令的地方进行修改，不能在I型指令下判断，这样会产生冲突 对于条件转移指令beq和bne要使用ALU做减法，判断是否全为零，也就是用ZF判断是否转移 J型指令可以接着I型指令的case结构写下来，与J型case结构无冲突 由于实验九和实验十想法十分接近，主要是控制信号的改变，及其译码模块的改变 涉及实验：具体用到的实验是多功能ALU设计实验、寄存器堆设计实验 、取指令与指令译码实验 代码展示 顶层模块","title":"杭电计算机组成实验 实验10-实现R-I-J型指令的CPU设计实验"},{"content":"","date":"25 December 2020","permalink":"/tags/architecture/","section":"Tags","summary":"","title":"architecture"},{"content":"","date":"25 December 2020","permalink":"/tags/fpga/","section":"Tags","summary":"","title":"fpga"},{"content":"","date":"25 December 2020","permalink":"/tags/r-i%E5%9E%8B%E6%8C%87%E4%BB%A4/","section":"Tags","summary":"","title":"R-I型指令"},{"content":"实验内容 # 掌握MIPS R型和I型指令的综合数据通路设计，掌握数据流的多路选通控制方法 掌握取数指令lw和存数指令sw的寻址方式及其有效地址产生的方法 实现MIPS的部分I型和 R型指令的功能 解决方法 # 分析MIPS I型指令的特点，与R型指令有明显的不同：没有rd寄存器，使用rt作为目的寄存器；源操作数中有一个为立即数，位于指令的低16位 在寄存器堆模块的写地址输入端口设置二选一选择器，由于R型和I型的目的寄存器不同，由rd_rt_s控制 16位的立即数imm需要经过扩展才能与rs执行运算操作，对于有符号数的操作，执行的是符号扩展，对于无符号数的操作，执行的是0扩展 R型指令执行rs和rt运算，结果送rd；而I型立即数即数寻址指令则执行rs和扩展后的立即数imm运算，结果送rt。因此ALU的输入数据B端有两个选择：rt或者imm，仍可以通过二选一数据选择器，用rt_imm_s控制信号 需要添加一个数据存储器RAM存放指令访问的数据，读出的数据，意味着要在寄存器堆的写端口加个选择器，用alu_mem_s控制信号，其中要注意一点就是数据存储器的clk至少是CPU频率的2倍以上，我使用了两个clk输入解决这个问题 在实际写代码时，要注意顶层模块中，实例下层模块的顺序，由于译码模块变量多，我将其抽离出来，为了使顶层模块看起来简洁 涉及实验： 具体用到的实验是多功能ALU设计实验、寄存器堆设计实验 、取指令与指令译码实验 代码展示 顶层模块\nmodule CPU(clk,rst,OF,ZF,F,ALU_OP,M_R_Data,rd_rt_s,imm_s,rt_imm_s,Mem_Write,alu_mem_s,Write_Reg,clk_M,R_Data_B,Inst_code); input clk,rst,clk_M; wire [31:0]Inst_code; wire [5:0]op_code,funct; wire [4:0]rs_addr,rt_addr,rd_addr,shamt; output [31:0]F; output OF,ZF; output [31:0]M_R_Data; output [2:0]ALU_OP; wire [31:0]Mem_Addr; wire [4:0]W_Addr; output rd_rt_s,imm_s,rt_imm_s,Mem_Write,alu_mem_s,Write_Reg; output [31:0]Inst_code; wire [31:0]imm_data; wire [31:0]R_Data_A; output [31:0] R_Data_B; wire [15:0]imm; wire [31:0]ALU_B; wire [31:0]W_Data; PC pc1(clk,rst,Inst_code); assign op_code = Inst_code[31:26]; assign rs_addr = Inst_code[25:21]; assign rt_addr = Inst_code[20:16]; assign rd_addr = Inst_code[15:11]; assign shamt = Inst_code[10:6]; assign funct = Inst_code[5:0]; assign imm = Inst_code[15:0]; OP_Func op(op_code,funct,Write_Reg,ALU_OP,rd_rt_s,imm_s,rt_imm_s,Mem_Write,alu_mem_s); assign W_Addr = (rd_rt_s)?rt_addr:rd_addr; assign imm_data = (imm_s)?{{16{imm[15]}},imm}:{{16{1\u0026#39;b0}},imm}; assign W_Data = alu_mem_s?M_R_Data:F; Fourth_experiment_first F1(rs_addr,rt_addr,Write_Reg,R_Data_A,R_Data_B,rst,clk,W_Addr,W_Data); assign ALU_B = (rt_imm_s)?imm_data:R_Data_B;\tThird_experiment_first T1(OF,ZF,ALU_OP,R_Data_A,ALU_B,F); RAM RAM_B ( .clka(clk_M), // input clka .wea(Mem_Write), // input [0 : 0] wea .addra(F[5:0]), // input [5 : 0] addra .dina(R_Data_B), // input [31 : 0] dina .douta(M_R_Data) // output [31 : 0] douta ); endmodule PC(取指令模块)\nmodule PC(clk,rst,Inst_code); input clk,rst; wire [31:0]PC_new; reg[31:0]PC; initial PC = 32\u0026#39;h0000_0000; output [31:0]Inst_code; assign PC_new = PC +4; Inst_Rom rom( .clka(clk), // input clka .addra(PC[7:2]), // input [5 : 0] addra .douta(Inst_code) // output [31 : 0] douta ); always@(negedge clk or posedge rst) begin if(rst) begin PC \u0026lt;= 32\u0026#39;h0000_0000; end else begin PC \u0026lt;= PC_new; end end endmodule OP_Func(译码模块)\nmodule OP_Func(op_code,funct,Write_Reg,ALU_OP,rd_rt_s,imm_s,rt_imm_s,Mem_Write,alu_mem_s); input [5:0]op_code; input [5:0]funct; output reg[2:0]ALU_OP; output reg Write_Reg; output reg rd_rt_s; output reg imm_s; output reg rt_imm_s; output reg Mem_Write; output reg alu_mem_s; always@(*) begin\tWrite_Reg=1; ALU_OP=0; rd_rt_s=0; imm_s=0; rt_imm_s=0; Mem_Write=0; alu_mem_s=0; if(op_code==0) begin case(funct) 6\u0026#39;b100000:begin ALU_OP=3\u0026#39;b100; end 6\u0026#39;b100010:begin ALU_OP=3\u0026#39;b101; end 6\u0026#39;b100100:begin ALU_OP=3\u0026#39;b000;end 6\u0026#39;b100101:begin ALU_OP=3\u0026#39;b001;end 6\u0026#39;b100110:begin ALU_OP=3\u0026#39;b010;end 6\u0026#39;b100111:begin ALU_OP=3\u0026#39;b011;end 6\u0026#39;b101011:begin ALU_OP=3\u0026#39;b110;end 6\u0026#39;b000100:begin ALU_OP=3\u0026#39;b111;end endcase end else begin case(op_code) 6\u0026#39;b001000:begin rd_rt_s=1;imm_s=1;rt_imm_s=1;ALU_OP=100;end 6\u0026#39;b001100:begin rd_rt_s=1;rt_imm_s=1;ALU_OP=000; end 6\u0026#39;b001110:begin rd_rt_s=1;rt_imm_s=1;ALU_OP=010;end 6\u0026#39;b001011:begin rd_rt_s=1;rt_imm_s=1;ALU_OP=110; end 6\u0026#39;b100011:begin rd_rt_s=1;imm_s=1;rt_imm_s=1;alu_mem_s=1;ALU_OP=100; end 6\u0026#39;b101011:begin imm_s=1;rt_imm_s=1;ALU_OP=100;Write_Reg=0;Mem_Write=1; end endcase end end endmodule Fourth_experiment_first（寄存器堆模块）\nmodule Fourth_experiment_first(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,W_Addr,W_Data); input [4:0]R_Addr_A,R_Addr_B,W_Addr; input Write_Reg,Reset,Clk; input[31:0] W_Data; output [31:0] R_Data_A,R_Data_B; reg [31:0] REG_Files[0:31]; integer i=0; initial for(i=0;i\u0026lt;32;i=i+1) REG_Files[i]\u0026lt;=0; always @ (posedge Clk or posedge Reset) begin if(Reset) begin for(i=0;i\u0026lt;=31;i=i+1) REG_Files[i]\u0026lt;=0; end else begin if(Write_Reg) REG_Files[W_Addr]\u0026lt;=W_Data; end end assign R_Data_A = REG_Files[R_Addr_A]; assign R_Data_B = REG_Files[R_Addr_B]; endmodule Third_experiment_first（ALU模块）\nmodule Third_experiment_first(OF,ZF,ALU_OP,A,B,F); input [2:0]ALU_OP; input [31:0]A,B; output reg[31:0]F; reg C32; output reg OF; output reg ZF; always @(ALU_OP or A or B) begin OF = 0; C32 = 0; case(ALU_OP) 3\u0026#39;b000:F\u0026lt;=A\u0026amp;B; 3\u0026#39;b001:F\u0026lt;=A|B; 3\u0026#39;b010:F\u0026lt;=A^B; 3\u0026#39;b011:F\u0026lt;=A~^B; 3\u0026#39;b100:{C32,F}\u0026lt;=A+B; 3\u0026#39;b101:{C32,F}\u0026lt;=A-B; 3\u0026#39;b110:begin if(A\u0026lt;B) F\u0026lt;=32\u0026#39;h0000_0001;else F\u0026lt;=32\u0026#39;h0000_0000;end 3\u0026#39;b111:begin F\u0026lt;=B\u0026lt;\u0026lt;A;end endcase if(F==32\u0026#39;h0000_0000)\tZF\u0026lt;=1; else ZF\u0026lt;=0; if(ALU_OP == 3\u0026#39;b100 || ALU_OP == 3\u0026#39;b101) OF\u0026lt;=C32^F[31]^A[31]^B[31];\telse OF \u0026lt;=0; end endmodule MIPS32.coe\nmemory_initialization_radix=16; memory_initialization_vector=38011234,20026789,20039000,38040010,00822804,00253025,00833804,00464020,00414822,00225022,206b7fff,206c8000,314dffff,2c4e6788,2c4f678a,ac8b0000,ac0c0014,ac8d0010,ac8e0014,8c100010,8c910004,02119025,8c930010,8c940014,0274a827,8c96fff0,8c97fff4,02d7c02b; 数据coe\nmemory_initialization_radix=16; memory_initialization_vector=88888888,99999999,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999, aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff, 20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb, 00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,12345678,23456789,3456789a,6789abcd; 测试模块\nmodule test; reg clk; reg rst; reg clk_M; wire OF; wire ZF; wire [31:0] F; wire [2:0] ALU_OP; wire [31:0] M_R_Data; wire rd_rt_s; wire imm_s; wire rt_imm_s; wire Mem_Write; wire alu_mem_s; wire Write_Reg; wire [31:0] R_Data_B; wire [31:0] Inst_code; CPU uut ( .clk(clk), .rst(rst), .OF(OF), .ZF(ZF), .F(F), .ALU_OP(ALU_OP), .M_R_Data(M_R_Data), .rd_rt_s(rd_rt_s), .imm_s(imm_s), .rt_imm_s(rt_imm_s), .Mem_Write(Mem_Write), .alu_mem_s(alu_mem_s), .Write_Reg(Write_Reg), .clk_M(clk_M), .R_Data_B(R_Data_B), .Inst_code(Inst_code) ); always #9 clk_M = ~clk_M; always #20 clk =~clk; initial begin clk = 0; rst = 1; clk_M = 0; #2; rst = 0; end endmodule 友情提示 # 1.有的同学会把在顶层模块存数据存储器的地址和PC的地址弄混，大家会问为什么PC的存储器是取[7:2],而顶层模块存数据存储器的地址[5:0] ,主要原因就在PC=PC+4这个语句上，我们的存储器还是按照字节去寻址的，如果我们不取[7:2]的地址就会导致中间几条指令跳过，而顶层数据模块就是逐一增加的\n2.数据存储器的clk至少是CPU频率的2倍以上\n3.开始的时候，rst一定要拉高哦\n代码地址 # 代码地址\n","date":"25 December 2020","permalink":"/posts/hdu-computer-organization-and-architecture-experiment/ninth_experiment/","section":"Blog","summary":"实验内容 # 掌握MIPS R型和I型指令的综合数据通路设计，掌握数据流的多路选通控制方法 掌握取数指令lw和存数指令sw的寻址方式及其有效地址产生的方法 实现MIPS的部分I型和 R型指令的功能 解决方法 # 分析MIPS I型指令的特点，与R型指令有明显的不同：没有rd寄存器，使用rt作为目的寄存器；源操作数中有一个为立即数，位于指令的低16位 在寄存器堆模块的写地址输入端口设置二选一选择器，由于R型和I型的目的寄存器不同，由rd_rt_s控制 16位的立即数imm需要经过扩展才能与rs执行运算操作，对于有符号数的操作，执行的是符号扩展，对于无符号数的操作，执行的是0扩展 R型指令执行rs和rt运算，结果送rd；而I型立即数即数寻址指令则执行rs和扩展后的立即数imm运算，结果送rt。因此ALU的输入数据B端有两个选择：rt或者imm，仍可以通过二选一数据选择器，用rt_imm_s控制信号 需要添加一个数据存储器RAM存放指令访问的数据，读出的数据，意味着要在寄存器堆的写端口加个选择器，用alu_mem_s控制信号，其中要注意一点就是数据存储器的clk至少是CPU频率的2倍以上，我使用了两个clk输入解决这个问题 在实际写代码时，要注意顶层模块中，实例下层模块的顺序，由于译码模块变量多，我将其抽离出来，为了使顶层模块看起来简洁 涉及实验： 具体用到的实验是多功能ALU设计实验、寄存器堆设计实验 、取指令与指令译码实验 代码展示 顶层模块","title":"杭电计算机组成实验 实验9-实现R-I型指令的CPU设计实验"},{"content":"","date":"23 December 2020","permalink":"/tags/r%E5%9E%8B%E6%8C%87%E4%BB%A4/","section":"Tags","summary":"","title":"R型指令"},{"content":"实验内容 # 掌握MIPS R型指令的数据通路设计，掌握指令流和数据流的控制方法 掌握完整的单周期CPU顶层模块的设计方法 实现MIPS R型指令的功能 解决方法 # 分析MIPS R型指令的特点，OP均为000000b，可作为判断R型指令的依据 两个源操作数分别在rs和rt字段所指定的寄存器中，而目的操作数则是在rd字段所指定的寄存器 3.分析数据通路是从指令存储器取出的指令经过初级译码，将分解出的源寄存器rs、rt直接与寄存器堆的两个读端口A和B的寄存器地址连接，而将目的寄存器rd字段与寄存器堆的写端口地址相连，寄存器读出的A口数据和B口数据则直接连接到ALU的输入端A和B，ALU计算后的结果则送入寄存器堆的写数据端口 分析时序，首先是取指令，然后进行指令译码，最后将运算结果送到目的寄存器，PC自增，指向下一条指令 实验八中除译码模块，其他模块都已经前几个实验中完成，只需要将其连接，然后在译码模块中通过OP判断是否为R型，且将funct翻译成ALU的控制信号ALU_OP以及指定ALU的运算功能，由于此译码模块较为简单，我就在顶层模块实现了 具体用到的实验是多功能ALU设计实验、寄存器堆设计实验、取指令与指令译码实验 代码实现: 顶层模块\nmodule CPU(clk,rst,op_code,funct,rs_addr,rt_addr,rd_addr,shamt,OF,ZF,F,ALU_OP,Inst_code); input clk,rst; output [31:0]Inst_code; output [5:0]op_code,funct; output [4:0]rs_addr,rt_addr,rd_addr,shamt; output [31:0]F; output OF,ZF; output reg [2:0]ALU_OP; reg Write_Reg; wire [31:0]R_Data_A,R_Data_B; PC pc1(clk,rst,Inst_code); assign op_code = Inst_code[31:26]; assign rs_addr = Inst_code[25:21]; assign rt_addr = Inst_code[20:16]; assign rd_addr = Inst_code[15:11]; assign shamt = Inst_code[10:6]; assign funct = Inst_code[5:0]; Fourth_experiment_first F1(rs_addr,rt_addr,Write_Reg,R_Data_A,R_Data_B,rst,~clk,rd_addr,F); Third_experiment_first T1(OF,ZF,ALU_OP,R_Data_A,R_Data_B,F); always@(*) begin\tWrite_Reg\u0026lt;=0; ALU_OP=0; if(op_code==0) Write_Reg\u0026lt;=1; begin case(funct) 6\u0026#39;b100000:ALU_OP=3\u0026#39;b100; 6\u0026#39;b100010:ALU_OP=3\u0026#39;b101; 6\u0026#39;b100100:ALU_OP=3\u0026#39;b000; 6\u0026#39;b100101:ALU_OP=3\u0026#39;b001; 6\u0026#39;b100110:ALU_OP=3\u0026#39;b010; 6\u0026#39;b100111:ALU_OP=3\u0026#39;b011; 6\u0026#39;b101011:ALU_OP=3\u0026#39;b110; 6\u0026#39;b000100:ALU_OP=3\u0026#39;b111; endcase end end endmodule PC（取指令模块）\nmodule PC(clk,rst,Inst_code); input clk,rst; wire [31:0]PC_new; reg[31:0]PC; initial PC = 32\u0026#39;h0000_0000; output [31:0]Inst_code; assign PC_new = PC +4; Inst_Rom your_instance_name( .clka(clk), // input clka .addra(PC[7:2]), // input [5 : 0] addra .douta(Inst_code) // output [31 : 0] douta ); always@(negedge clk or posedge rst) begin if(rst) begin PC \u0026lt;= 32\u0026#39;h0000_0000; end else begin PC \u0026lt;= PC_new; end end endmodule Fourth_experiment_first模块（寄存器堆模块）\nmodule Fourth_experiment_first(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,W_Addr,W_Data); input [4:0]R_Addr_A,R_Addr_B,W_Addr; input Write_Reg,Reset,Clk; input[31:0] W_Data; output [31:0] R_Data_A,R_Data_B; reg [31:0] REG_Files[0:31]; integer i=0; initial for(i=0;i\u0026lt;32;i=i+1) REG_Files[i]\u0026lt;=0; always @ (posedge Clk or posedge Reset) begin if(Reset) begin for(i=0;i\u0026lt;=31;i=i+1) REG_Files[i]\u0026lt;=0; end else begin if(Write_Reg) REG_Files[W_Addr]\u0026lt;=W_Data; end end assign R_Data_A = REG_Files[R_Addr_A]; assign R_Data_B = REG_Files[R_Addr_B]; endmodule Third_experiment_first（ALU模块）\nmodule Third_experiment_first(OF,ZF,ALU_OP,A,B,F); input [2:0]ALU_OP; input [31:0]A,B; output reg[31:0]F; reg C32; output reg OF; output reg ZF; always @(ALU_OP or A or B) begin OF = 0; C32 = 0; case(ALU_OP) 3\u0026#39;b000:F\u0026lt;=A\u0026amp;B; 3\u0026#39;b001:F\u0026lt;=A|B; 3\u0026#39;b010:F\u0026lt;=A^B; 3\u0026#39;b011:F\u0026lt;=A~^B; 3\u0026#39;b100:{C32,F}\u0026lt;=A+B; 3\u0026#39;b101:{C32,F}\u0026lt;=A-B; 3\u0026#39;b110:begin if(A\u0026lt;B) F\u0026lt;=32\u0026#39;h0000_0001;else F\u0026lt;=32\u0026#39;h0000_0000;end 3\u0026#39;b111:begin F\u0026lt;=B\u0026lt;\u0026lt;A;end endcase if(F==32\u0026#39;h0000_0000)\tZF\u0026lt;=1; else ZF\u0026lt;=0; if(ALU_OP == 3\u0026#39;b100 || ALU_OP == 3\u0026#39;b101) OF\u0026lt;=C32^F[31]^A[31]^B[31];\telse OF \u0026lt;=0; end endmodule MIPS32.coe\nmemory_initialization_radix=16; memory_initialization_vector=00000827 0001102b 00421820 00622020 00832820 00a33020 00463804 00a64820 01264004 00284826 01215020 01075822 00e86022 012c6824 012c7025 00c77825 00c78027 00e38820 02289004 02239804 00f3a004 0281a820 0255b025 0296b820 0296c022 02d4c822 0241d026 02d4d82b 0354e02b 02c2e820 0282f022 017af820; 测试模块\nmodule test; // Inputs reg clk; reg rst; // Outputs wire [5:0] op_code; wire [5:0] funct; wire [4:0] rs_addr; wire [4:0] rt_addr; wire [4:0] rd_addr; wire [4:0] shamt; wire OF; wire ZF; wire [31:0] F; wire [2:0] ALU_OP; wire [31:0] Inst_code; CPU uut ( .clk(clk), .rst(rst), .op_code(op_code), .funct(funct), .rs_addr(rs_addr), .rt_addr(rt_addr), .rd_addr(rd_addr), .shamt(shamt), .OF(OF), .ZF(ZF), .F(F), .ALU_OP(ALU_OP), .Inst_code(Inst_code) ); always #20 clk = ~clk; initial begin clk = 0; rst = 1; #2; rst = 0; end endmodule 友情提示：开始不拉高rst，第一条指令取不到噢，解释可以看实验七，顶上有链接\n代码地址 # 代码地址\n","date":"23 December 2020","permalink":"/posts/hdu-computer-organization-and-architecture-experiment/eighth_experiment/","section":"Blog","summary":"实验内容 # 掌握MIPS R型指令的数据通路设计，掌握指令流和数据流的控制方法 掌握完整的单周期CPU顶层模块的设计方法 实现MIPS R型指令的功能 解决方法 # 分析MIPS R型指令的特点，OP均为000000b，可作为判断R型指令的依据 两个源操作数分别在rs和rt字段所指定的寄存器中，而目的操作数则是在rd字段所指定的寄存器 3.","title":"杭电计算机组成实验 实验8-实现R型指令的CPU设计实验"},{"content":"","date":"22 December 2020","permalink":"/tags/mips/","section":"Tags","summary":"","title":"MIPS"},{"content":"","date":"22 December 2020","permalink":"/tags/%E5%8F%96%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%8C%87%E4%BB%A4%E8%AF%91%E7%A0%81/","section":"Tags","summary":"","title":"取指令与指令译码"},{"content":"","date":"22 December 2020","permalink":"/tags/%E5%AD%98%E5%82%A8%E5%99%A8/","section":"Tags","summary":"","title":"存储器"},{"content":"实验内容 # 掌握灵活运用 Verilog HDL 进行各种描述与建模的技巧和方法 学习在 ISE 中设计生成 Memory IP 核的方法 学习存储器的结构及读写原理，掌握存储器的设计方法 解决方法 # 分析一个 256x8 位的物理存储器，具有读 写功能，按字节编址，按字访问， 即 64x32 位。\n首先，给出的 8 位存储器地址，只按照高 6 位访问存储器，而低 2 位必须为 00\n我采用了两种方法进行设计存储器，首先是 MemoryIP 核\nMemoryIP核只需按照书上步骤下来，贴几张步骤图，大家按照步骤下来 这里我选择的是同步存储器，由时钟控制；另一种是分布式存储器，不带时钟同步，也就是异步控制\n5. MemoryIP代码展示：\nmodule RAM( input [7:2]Mem_Addr, input [1:0]MUX,\tinput Mem_Write,\tinput Clk,\toutput reg [7:0]LED); wire [31:0]M_R_Data;\treg [31:0]M_W_Data;\tRAM_B your_instance_name ( .clka(Clk), // input clka .wea(Mem_Write), // input [0 : 0] wea .addra(Mem_Addr), // input [5 : 0] addra .dina(M_W_Data), // input [31 : 0] dina .douta(M_R_Data) // output [31 : 0] douta ); always @(*) begin LED = 0; M_W_Data = 0; if(Mem_Write) begin case(MUX) 2\u0026#39;b00:\tM_W_Data = 32\u0026#39;h0000_000F; 2\u0026#39;b01:\tM_W_Data = 32\u0026#39;h0000_0DB0; 2\u0026#39;b10:\tM_W_Data = 32\u0026#39;h003C_C381; 2\u0026#39;b11:\tM_W_Data = 32\u0026#39;hFFFF_FFFF;\tendcase end else begin case(MUX) 2\u0026#39;b00:\tLED = M_R_Data[7:0]; 2\u0026#39;b01:\tLED = M_R_Data[15:8]; 2\u0026#39;b10:\tLED = M_R_Data[23:16]; 2\u0026#39;b11:\tLED = M_R_Data[31:24];\tendcase end end endmodule Test_Mem.coe\nmemory_initialization_radix = 16; memory_initialization_vector = 00000820,00632020,00010fff,20006789,ffff0000,0000ffff,88888888,99999999,aaaaaaaa,bbbbbbbb; 测试模块\nmodule test; // Inputs reg [7:2] Mem_Addr; reg [1:0] MUX; reg Mem_Write; reg Clk; // Outputs wire [7:0] LED; RAM uut ( .Mem_Addr(Mem_Addr), .MUX(MUX), .Mem_Write(Mem_Write), .Clk(Clk), .LED(LED) ); always #20 Clk=~Clk; initial begin // Initialize Inputs Mem_Addr = 0; MUX = 0; Mem_Write = 1; Clk = 0; #100; Mem_Addr = 6\u0026#39;b000000; MUX = 0; Mem_Write = 0; end endmodule 6. 自己实现同步存储器核心代码展示（这自己实现的代码欢迎大家指正错误）：\n存储器模块\nmodule RAMA(Mem_Read,Mem_Write,Mem_Addr,M_W_Data,M_R_Data,clk); input Mem_Read,Mem_Write,clk; input [5:0]Mem_Addr; input [31:0]M_W_Data; output reg[31:0]M_R_Data; reg [0:31]memory[0:63]; always@(posedge clk) if(Mem_Write) memory[Mem_Addr]\u0026lt;=M_W_Data; else if(Mem_Read) M_R_Data \u0026lt;= memory[Mem_Addr]; endmodule 顶层模块\nmodule RAM( input [5:0]Mem_Addr, input [1:0]MUX,\tinput Mem_Write, input Mem_Read, input clk,\toutput reg [7:0]LED); wire [31:0]M_R_Data;\treg [31:0]M_W_Data;\tRAMA ram (Mem_Read,Mem_Write,Mem_Addr,M_W_Data,M_R_Data,clk); always @(*) begin LED = 0; M_W_Data = 0; if(Mem_Write) begin case(MUX) 2\u0026#39;b00:\tM_W_Data = 32\u0026#39;h0000_000F; 2\u0026#39;b01:\tM_W_Data = 32\u0026#39;h0000_0DB0; 2\u0026#39;b10:\tM_W_Data = 32\u0026#39;h003C_C381; 2\u0026#39;b11:\tM_W_Data = 32\u0026#39;hFFFF_FFFF;\tendcase end else if(Mem_Read) begin case(MUX) 2\u0026#39;b00:\tLED = M_R_Data[7:0]; 2\u0026#39;b01:\tLED = M_R_Data[15:8]; 2\u0026#39;b10:\tLED = M_R_Data[23:16]; 2\u0026#39;b11:\tLED = M_R_Data[31:24];\tendcase end end endmodule 测试模块\nmodule test; // Inputs reg [5:0] Mem_Addr; reg [1:0] MUX; reg Mem_Write; reg Mem_Read; reg clk; // Outputs wire [7:0] LED; RAM uut ( .Mem_Addr(Mem_Addr), .MUX(MUX), .Mem_Write(Mem_Write), .Mem_Read(Mem_Read), .clk(clk), .LED(LED) ); always #20 clk = ~clk; initial begin // Initialize Inputs Mem_Addr = 0; MUX = 0; Mem_Write = 1; Mem_Read = 0; clk = 0; #100; Mem_Addr = 0; MUX = 0; Mem_Write = 0; Mem_Read = 1; end endmodule 7. 自己实现异步存储器核心代码展示（这自己实现的代码欢迎大家指正错误）：\n存储器模块\nmodule RAMA(Mem_Read,Mem_Write,Mem_Addr,M_W_Data,M_R_Data); input Mem_Read,Mem_Write; input [5:0]Mem_Addr; input [31:0]M_W_Data; output reg[31:0]M_R_Data; reg [0:31]memory[0:63]; //M_R_Data \u0026lt;= Mem_Read?memory[Mem_Addr]:32\u0026#39;bz; always@(*) if(Mem_Write) memory[Mem_Addr]\u0026lt;=M_W_Data; else if(Mem_Read) M_R_Data \u0026lt;= memory[Mem_Addr]; endmodule 顶层模块\nmodule RAM( input [5:0]Mem_Addr, input [1:0]MUX,\tinput Mem_Write, input Mem_Read,\toutput reg [7:0]LED); wire [31:0]M_R_Data;\treg [31:0]M_W_Data;\tRAMA ram (Mem_Read,Mem_Write,Mem_Addr,M_W_Data,M_R_Data); always @(*) begin LED = 0; M_W_Data = 0; if(Mem_Write) begin case(MUX) 2\u0026#39;b00:\tM_W_Data = 32\u0026#39;h0000_000F; 2\u0026#39;b01:\tM_W_Data = 32\u0026#39;h0000_0DB0; 2\u0026#39;b10:\tM_W_Data = 32\u0026#39;h003C_C381; 2\u0026#39;b11:\tM_W_Data = 32\u0026#39;hFFFF_FFFF;\tendcase end else if(Mem_Read) begin case(MUX) 2\u0026#39;b00:\tLED = M_R_Data[7:0]; 2\u0026#39;b01:\tLED = M_R_Data[15:8]; 2\u0026#39;b10:\tLED = M_R_Data[23:16]; 2\u0026#39;b11:\tLED = M_R_Data[31:24];\tendcase end end endmodule 测试模块\nmodule test; reg [5:0] Mem_Addr; reg [1:0] MUX; reg Mem_Write; reg Mem_Read; wire [7:0] LED; RAM uut ( .Mem_Addr(Mem_Addr), .MUX(MUX), .Mem_Write(Mem_Write), .Mem_Read(Mem_Read), .LED(LED) ); initial begin Mem_Addr = 0; MUX = 0; Mem_Write = 1; Mem_Read = 0; #100; Mem_Addr = 0; MUX = 0; Mem_Write = 0; Mem_Read = 1; end endmodule 代码地址 # 代码地址-1\n代码地址-2\n代码地址-3\n","date":"22 December 2020","permalink":"/posts/hdu-computer-organization-and-architecture-experiment/fifth_experiment/","section":"Blog","summary":"实验内容 # 掌握灵活运用 Verilog HDL 进行各种描述与建模的技巧和方法 学习在 ISE 中设计生成 Memory IP 核的方法 学习存储器的结构及读写原理，掌握存储器的设计方法 解决方法 # 分析一个 256x8 位的物理存储器，具有读 写功能，按字节编址，按字访问， 即 64x32 位。","title":"杭电计算机组成实验 实验5-存储器设计实验"},{"content":"实验内容 # 学习 MIPS指令系统，熟悉 MIPS指令格式及其汇编指令助记符，掌握机器 指令编码方法 学习 MIPS汇编程序设计，学会使用 MIPS 汇编器将汇编语言程序翻译成二 进制文件 了解使用 MIPS教学系统模拟器运行程序的方法 解决方法 # 下载 PCSpim 软件 给大家一个下载的地方，只要关注我，就可以下载到PCSpim下载地址 按照书上的要求，在文本编辑器中输入汇编程序，然后装入PCSpim 左侧内为指令地址，中间是十六进制的指令编码，右侧是相应的标准汇编指 令，主要注意的是第二个程序，必须在裸机执行方式 书上的汇编和结果展示： test.asm\nmain:\tli $v0 , 5 syscall move $t0,$v0 li $v0,5 syscall\tmove $t1 , $v0 bgt $t0,$t1,t0_bigger move $t2,$t1 b endif t0_bigger : move $t2,$t0 endif :move $a0,$t2 li $v0,1 syscall jr $ra R_CPU_Test.asm\nmain:nor $1,$0,$0;\t#$1 = FFFF_FFFF\tsltu $2,$0,$1;\t#$2 = 0000_0001 if($2\u0026lt;$3) $1=1 else $1=0 add $3,$2,$2;\t#$3 = 0000_0002 add $4,$3,$2;\t#$4 = 0000_0003 add $5,$4,$3;\t#$5 = 0000_0005 add $6,$5,$3;\t#$6 = 0000_0007 sllv $7,$6,$2;\t#$7 = 0000_000E $1=$2\u0026lt;\u0026lt;$3 add $9,$5,$6;\t#$9 = 0000_000C sllv $8,$6,$9;\t#$8 = 0000_7000 xor $9,$1,$8;\t#$9 = FFFF_8FFF add $10,$9,$1;\t#$10 = FFFF_8FFE sub $11,$8,$7; #$11 = 0000_6FF2 sub $12,$7,$8;\t#$12 = FFFF_900E and $13,$9,$12; #$13 = FFFF_800E or $14,$9,$12;\t#$14 = FFFF_9FFF or $15,$6,$7;\t#$15 = 0000_000F nor $16,$6,$7;\t#$16 = FFFF_FFF0 add $17,$7,$3;\t#$17 = 0000_0010 sllv $18,$8,$17;\t#$18 = 7000_0000 sllv $19,$3,$17;\t#$19 = 0002_0000 sllv $20,$19,$7;\t#$20 = 8000_0000 add $21,$20,$1; #$21 = 7FFF_FFFF or $22,$18,$21\t#$22 = 7FFF_FFFF add $23,$20,$22;\t#$23 = FFFF_FFFF sub $24,$20,$22;\t#$24 = 0000_0001 sub $25,$22,$20;\t#$25 = FFFF_FFFF xor $26,$18,$1;\t#$26 = 8FFF_FFFF sltu $27,$22,$20;\t#$27 = 0000_0001 sltu $28,$26,$20;\t#$28 = 0000_0000 add $29,$22,$2;\t#$29 = 8000_0000 sub $30,$20,$2;\t#$30 = 7FFF_FFFF add $31,$11,$26;\t#$31 = 9000_6FF1 结果机器码展示\n00000827 0001102b 00421820 00622020 00832820 00a33020 00463804 00a64820 01264004 00284826 01215020 01075822 00e86022 012c6824 012c7025 00c77825 00c78027 00e38820 02289004 02239804 00f3a004 0281a820 0255b025 0296b820 0296c022 02d4c822 0241d026 02d4d82b 0354e02b 02c2e820 0282f022 017af820 代码地址 # 代码地址\n","date":"22 December 2020","permalink":"/posts/hdu-computer-organization-and-architecture-experiment/sixth_experiment/","section":"Blog","summary":"实验内容 # 学习 MIPS指令系统，熟悉 MIPS指令格式及其汇编指令助记符，掌握机器 指令编码方法 学习 MIPS汇编程序设计，学会使用 MIPS 汇编器将汇编语言程序翻译成二 进制文件 了解使用 MIPS教学系统模拟器运行程序的方法 解决方法 # 下载 PCSpim 软件 给大家一个下载的地方，只要关注我，就可以下载到PCSpim下载地址 按照书上的要求，在文本编辑器中输入汇编程序，然后装入PCSpim 左侧内为指令地址，中间是十六进制的指令编码，右侧是相应的标准汇编指 令，主要注意的是第二个程序，必须在裸机执行方式 书上的汇编和结果展示： test.","title":"杭电计算机组成实验 实验6-MIPS汇编器与模拟器实验"},{"content":"实验内容 # 学习指令存储器的设计 掌握CPU取指令操作与指令译码的方法和过程 解决方法 # 本次实验设计采用哈佛结构设计存储器模块，需要设计一个只读存储器作为指令存储器，采用Memory IP核实现（不会用Memory IP核，可以看我这个博文存储器实验 程序计数器PC与PC自增加法器组合成一个模块，由于指令存储器只有64个32位单元，所以PC的32位指令地址的高24位可直接在设计中清零 需要注意在指令周期clk的上升沿执行取指令操作，在clk下降沿更新PC值 代码展示: 顶层模块\nmodule Fetch_Inst_Code(clk,rst,LED,MUX,op_code,funct,rs_addr,rt_addr,rd_addr,shamt,Inst_code); input clk,rst; input [1:0]MUX; output [31:0]Inst_code; output reg[7:0]LED; reg [31:0]PC; wire [31:0]PC_new; output [5:0]op_code,funct; output [4:0]rs_addr,rt_addr,rd_addr,shamt; PC pc1(clk,rst,Inst_code); always@(*) begin case(MUX) 2\u0026#39;b00:LED = Inst_code[7:0]; 2\u0026#39;b01:LED = Inst_code[15:8]; 2\u0026#39;b10:LED = Inst_code[23:16]; 2\u0026#39;b11:LED = Inst_code[31:25]; endcase end assign op_code = Inst_code[31:26]; assign rs_addr = Inst_code[25:21]; assign rt_addr = Inst_code[20:16]; assign rd_addr = Inst_code[15:11]; assign shamt = Inst_code[10:6]; assign funct = Inst_code[5:0]; endmodule PC(取指令模块)\nmodule PC(clk,rst,Inst_code); input clk,rst; wire [31:0]PC_new; reg[31:0]PC; initial PC = 32\u0026#39;h0000_0000; output [31:0]Inst_code; assign PC_new = PC +4; Inst_Rom your_instance_name ( .clka(clk), // input clka .addra(PC[7:2]), // input [5 : 0] addra .douta(Inst_code) // output [31 : 0] douta ); always@(negedge clk or posedge rst) begin if(rst) begin PC \u0026lt;= 32\u0026#39;h0000_0000; end else begin PC \u0026lt;=PC_new; end end endmodule 友情提示：PC一定要初始化，否则结果会有所偏差\n测试模块\nmodule test; // Inputs reg clk; reg rst; reg [1:0] MUX; // Outputs wire [7:0] LED; wire [5:0] op_code; wire [5:0] funct; wire [4:0] rs_addr; wire [4:0] rt_addr; wire [4:0] rd_addr; wire [4:0] shamt; wire [31:0] Inst_code; Fetch_Inst_Code uut ( .clk(clk), .rst(rst), .LED(LED), .MUX(MUX), .op_code(op_code), .funct(funct), .rs_addr(rs_addr), .rt_addr(rt_addr), .rd_addr(rd_addr), .shamt(shamt), .Inst_code(Inst_code) ); always #33 clk = ~clk; initial begin clk = 0; rst = 1; MUX = 0; #2; rst = 0; end endmodule MIPS32.coe\nmemory_initialization_radix=16; memory_initialization_vector=00000827 0001102b 00421820 00622020 00832820 00a33020 00463804 00a64820 01264004 00284826 01215020 01075822 00e86022 012c6824 012c7025 00c77825 00c78027 00e38820 02289004 02239804 00f3a004 0281a820 0255b025 0296b820 0296c022 02d4c822 0241d026 02d4d82b 0354e02b 02c2e820 0282f022 017af820; 友情提示：如果rst不先开始拉高，就会导致第一条指令取不到，我一个朋友就因为这个写了一个下午，重构了很久；根据我个人分析，是因为clk的上升沿的到来，但是PC地址还没准备好，导致第一条指令没有取到\n询问了研究生学长，证实自己的想法\n代码地址 # 代码地址\n","date":"22 December 2020","permalink":"/posts/hdu-computer-organization-and-architecture-experiment/seventh_experiment/","section":"Blog","summary":"实验内容 # 学习指令存储器的设计 掌握CPU取指令操作与指令译码的方法和过程 解决方法 # 本次实验设计采用哈佛结构设计存储器模块，需要设计一个只读存储器作为指令存储器，采用Memory IP核实现（不会用Memory IP核，可以看我这个博文存储器实验 程序计数器PC与PC自增加法器组合成一个模块，由于指令存储器只有64个32位单元，所以PC的32位指令地址的高24位可直接在设计中清零 需要注意在指令周期clk的上升沿执行取指令操作，在clk下降沿更新PC值 代码展示: 顶层模块","title":"杭电计算机组成实验 实验7-取指令与指令译码实验"},{"content":"","date":"21 December 2020","permalink":"/tags/%E5%85%A8%E5%8A%A0%E5%99%A8/","section":"Tags","summary":"","title":"全加器"},{"content":"","date":"21 December 2020","permalink":"/tags/%E5%A4%9A%E5%8A%9F%E8%83%BDalu/","section":"Tags","summary":"","title":"多功能ALU"},{"content":"","date":"21 December 2020","permalink":"/tags/%E5%AF%84%E5%AD%98%E5%99%A8%E5%A0%86/","section":"Tags","summary":"","title":"寄存器堆"},{"content":"实验内容 # 学习ISE工具软件的使用及仿真方法 学习FPGA程序的下载方式 熟悉Nexys3实验板 掌握运用Verilog HDL 进行结构描述与建模的技术和方法 掌握二进制全加器的原理与设计 解决方法 # 分析二进制全加器的输入输出，然后得出两个输出端口的门电路。 使用ISE内部门级电路进行组合，最后实现实验所需的效果 代码展示： 顶层模块：\nmodule First_Experiment_Add(A,B,Ci,F,C); input A,B,Ci; output F,C; xor\tXU1(F,A,B,Ci), XU2(Q,A,B); and\tAN1(W,Q,Ci), AN2(E,A,B); or\tOR1(C,W,E); endmodule 测试模块：\nmodule test; // Inputs reg A; reg B; reg Ci; // Outputs wire F; wire C; First_Experiment_Add uut ( .A(A), .B(B), .Ci(Ci), .F(F), .C(C) ); initial begin A = 0; B = 0; Ci = 0; #100; A = 1; B = 0; Ci = 0; #100; A = 1; B = 1; Ci = 0; #100; A = 1; B = 1; Ci = 1; end endmodule 代码地址 # 代码地址\n","date":"21 December 2020","permalink":"/posts/hdu-computer-organization-and-architecture-experiment/first_experiment/","section":"Blog","summary":"实验内容 # 学习ISE工具软件的使用及仿真方法 学习FPGA程序的下载方式 熟悉Nexys3实验板 掌握运用Verilog HDL 进行结构描述与建模的技术和方法 掌握二进制全加器的原理与设计 解决方法 # 分析二进制全加器的输入输出，然后得出两个输出端口的门电路。 使用ISE内部门级电路进行组合，最后实现实验所需的效果 代码展示： 顶层模块：","title":"杭电计算机组成实验 实验1-全加器设计实验"},{"content":"实验内容 # 掌握运用Verilog HDL进行数据流描述与建模的技巧和方法，掌握模块调用与实例引用的方法 掌握超前进位加法器的原理与设计方法 解决方法 # 分析4位的二进制全加器的输入输出，内部为超前进位逻辑 首先，要知道超前进位逻辑与行波进位加法器的区别 行波进位加法器需要像链子一样，等第一位算完，再算第二位，而超前进位加法器是四位同时，第二位包括了第一位的计算部分，从而达到消除依赖的关系 代码展示： 顶层模块\nmodule second_experiment_first(A,B,F,C4,C0); input [3:0]A,B; input C0; output [3:0]F; output C4; assign G0 = A[0] \u0026amp; B[0]; assign P0 = A[0] | B[0]; assign G1 = A[1] \u0026amp; B[1]; assign P1 = A[1] | B[1]; assign G2 = A[2] \u0026amp; B[2]; assign P2 = A[2] | B[2]; assign G3 = A[3] \u0026amp; B[3]; assign P3 = A[3] | B[3]; assign C1 = G0 | P0\u0026amp;C0; assign C2 = G1 | P1\u0026amp;G0 | P0\u0026amp;P1\u0026amp;C0; assign C3 = G2 | P2\u0026amp;G1 | P2\u0026amp;P1\u0026amp;G0 | P2\u0026amp;P1\u0026amp;P0\u0026amp;C0; assign C4 = G3 | P3\u0026amp;G2 | P3\u0026amp;P2\u0026amp;G1 | P3\u0026amp;P2\u0026amp;P1\u0026amp;G0 | P3\u0026amp;P2\u0026amp;P1\u0026amp;P0\u0026amp;C0; assign F[0] = A[0]^B[0]^C0; assign F[1] = A[1]^B[1]^C1; assign F[2] = A[2]^B[2]^C2; assign F[3] = A[3]^B[3]^C3; endmodule 测试模块\nmodule second_experiment_test; // Inputs reg [3:0] A; reg [3:0] B; reg C0; // Outputs wire [3:0] F; wire C4; second_experiment_first uut ( .A(A), .B(B), .F(F), .C4(C4), .C0(C0) ); initial begin A = 4\u0026#39;b1000; B = 4\u0026#39;b1000; C0 = 1; #100; A = 4\u0026#39;b1001; B = 4\u0026#39;b1001; C0 = 1; #100; A = 4\u0026#39;b1011; B = 4\u0026#39;b1011; C0 = 1; end endmodule 特别注意 # 题主在网上看到一份报告中的代码并不是把所有的运算拿过来的，而是把C1赋给C2这样做的，assign这种组合逻辑电路，是并行执行，这样的方法不一定可行\n代码地址 # 代码地址\n","date":"21 December 2020","permalink":"/posts/hdu-computer-organization-and-architecture-experiment/second_experiment/","section":"Blog","summary":"实验内容 # 掌握运用Verilog HDL进行数据流描述与建模的技巧和方法，掌握模块调用与实例引用的方法 掌握超前进位加法器的原理与设计方法 解决方法 # 分析4位的二进制全加器的输入输出，内部为超前进位逻辑 首先，要知道超前进位逻辑与行波进位加法器的区别 行波进位加法器需要像链子一样，等第一位算完，再算第二位，而超前进位加法器是四位同时，第二位包括了第一位的计算部分，从而达到消除依赖的关系 代码展示： 顶层模块","title":"杭电计算机组成实验 实验2-超前进位加法器设计实验"},{"content":"实验内容 # 学习多功能ALU的工作原理，掌握运算器的设计方法 掌握运用Verilog HDL 进行行为描述与建模的技巧和方法 解决方法 # 分析一个具有8种运算功能的32位ALU，并能够产生运算结果的标志：结果位零标志（ZF）和溢出标志（OF） 首先，分析出ZF只会在加减运算中出现溢出情况，然后分析出ALU 8种计算如何表达，如果使用“-”，就不用考虑如何减法** 代码展示： 顶层模块：\nmodule ALU(AB_SW,ALU_OP,F_LED_SW,LED); input[2:0]AB_SW,ALU_OP,F_LED_SW; output[7:0]LED; wire [31:0]A,B,F; wire ZF,OF; Third_experiment_second T2(AB_SW,A,B); Third_experiment_first T1(OF,ZF,ALU_OP,A,B,F); Third_experiment_third T3(F_LED_SW,LED,F,ZF,OF); endmodule Third_experiment_second模块（作为数据输入）\nmodule Third_experiment_second(AB_SW,A,B); input[2:0]AB_SW; output reg[31:0]A,B; always @(*) begin case(AB_SW) 3\u0026#39;b000:begin A=32\u0026#39;h0000_0000;B=32\u0026#39;h0000_0000;end 3\u0026#39;b001:begin A=32\u0026#39;h0000_0003;B=32\u0026#39;h0000_0607;end 3\u0026#39;b010:begin A=32\u0026#39;h8000_0000;B=32\u0026#39;h8000_0000;end 3\u0026#39;b011:begin A=32\u0026#39;h7FFF_FFFF;B=32\u0026#39;h7FFF_FFFF;end 3\u0026#39;b100:begin A=32\u0026#39;hFFFF_FFFF;B=32\u0026#39;hFFFF_FFFF;end 3\u0026#39;b101:begin A=32\u0026#39;h8000_0000;B=32\u0026#39;hFFFF_FFFF;end 3\u0026#39;b110:begin A=32\u0026#39;hFFFF_FFFF;B=32\u0026#39;h8000_0000;end 3\u0026#39;b111:begin A=32\u0026#39;h1234_5678;B=32\u0026#39;h3333_2222;end default:begin A=32\u0026#39;h9ABC_DEF0;B=32\u0026#39;h1111_2222;end endcase end endmodule Third_experiment_first模块（运算）\nmodule Third_experiment_first(OF,ZF,ALU_OP,A,B,F); input [2:0]ALU_OP; input [31:0]A,B; output reg[31:0]F; reg C32; output reg OF=0; output reg ZF=0; always @(ALU_OP or A or B) begin case(ALU_OP) 3\u0026#39;b000:F\u0026lt;=A\u0026amp;B; 3\u0026#39;b001:F\u0026lt;=A|B; 3\u0026#39;b010:F\u0026lt;=A^B; 3\u0026#39;b011:F\u0026lt;=A~^B; 3\u0026#39;b100:{C32,F}\u0026lt;=A+B; 3\u0026#39;b101:{C32,F}\u0026lt;=A-B; 3\u0026#39;b110:begin if(A\u0026lt;B) F\u0026lt;=32\u0026#39;h0000_0001;else F\u0026lt;=32\u0026#39;h0000_0000;end 3\u0026#39;b111:begin F\u0026lt;=B\u0026lt;\u0026lt;A;end endcase if(F==32\u0026#39;h0000_0000)\tZF\u0026lt;=1; else ZF\u0026lt;=0; OF=C32^F[31]^A[31]^B[31];\tend endmodule Third_experiment_third模块（作为LED显示）\nmodule Third_experiment_third(F_LED_SW,LED,F,ZF,OF); input[31:0]F; input ZF,OF; input[2:0] F_LED_SW; output reg[7:0] LED; always@(*) begin case(F_LED_SW) 3\u0026#39;b000:LED=F[7:0]; 3\u0026#39;b001:LED=F[15:8]; 3\u0026#39;b010:LED=F[23:16]; 3\u0026#39;b011:LED=F[31:24]; default:begin LED[7]=ZF;LED[0]=OF;LED[6:1]=6\u0026#39;b0;end endcase end endmodule 测试模块\nmodule ALU_TEST; // Inputs reg [2:0] AB_SW; reg [2:0] ALU_OP; reg [2:0] F_LED_SW; // Outputs wire [7:0] LED; ALU uut ( .AB_SW(AB_SW), .ALU_OP(ALU_OP), .F_LED_SW(F_LED_SW), .LED(LED) ); initial begin AB_SW = 3\u0026#39;b001; ALU_OP = 3\u0026#39;b000; F_LED_SW = 3\u0026#39;b000; #100; AB_SW = 3\u0026#39;b001; ALU_OP = 3\u0026#39;b001; F_LED_SW = 3\u0026#39;b000; #100; AB_SW = 3\u0026#39;b001; ALU_OP = 3\u0026#39;b010; F_LED_SW = 3\u0026#39;b000; end endmodule 特别注意 # 当时在做实验的时候，有的朋友问我begin\u0026hellip;end是干什么用，其实就是相当于C语言中的大括号\n代码地址 # 代码地址\n","date":"21 December 2020","permalink":"/posts/hdu-computer-organization-and-architecture-experiment/third_experiment/","section":"Blog","summary":"实验内容 # 学习多功能ALU的工作原理，掌握运算器的设计方法 掌握运用Verilog HDL 进行行为描述与建模的技巧和方法 解决方法 # 分析一个具有8种运算功能的32位ALU，并能够产生运算结果的标志：结果位零标志（ZF）和溢出标志（OF） 首先，分析出ZF只会在加减运算中出现溢出情况，然后分析出ALU 8种计算如何表达，如果使用“-”，就不用考虑如何减法** 代码展示： 顶层模块：","title":"杭电计算机组成实验 实验3-多功能ALU设计实验"},{"content":"实验内容 # 学习使用Verilog HDL 进行时序电路的设计方法 掌握灵活运用Verilog HDL进行各种描述与建模的技巧和方法 学习寄存器堆的数据传送与读/写工作原理，掌握寄存器堆的设计方法 解决方法 # 分析一个32x32位的寄存器堆，即含有32个寄存器，每个寄存器32位。该寄存器堆有2个读端口、1个写端口，即能够同时读出2个寄存器的值，写入1个寄存器 首先，分析出两个端口读入是5位的地址，读出的数据是32位的两个，该寄存器堆只有一个写端口，还要配合控制信号Write_Reg，且写操作是边沿触发的，所有写入操作的输入信号必须在时钟边沿来临时已经有效 寄存器堆的读操作和写操作的地址译码，只需引用寄存器地址作为数组的下标即可；读只需要组合逻辑，给出寄存器地址，读出数据 代码展示： 顶层模块（需要数据输入在板子上操作）：\nmodule RegisterFile(Addr,Write_Reg,Opt,Clk,Reset,A_B,LED); input [1:0]Opt; input [4:0]Addr; input Write_Reg,Clk,Reset,A_B; output reg [7:0]LED; wire [31:0]R_Data_A,R_Data_B; reg [4:0]R_Addr_A,R_Addr_B; reg [31:0]W_Data; initial LED \u0026lt;= 0; Fourth_experiment_first F1(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,Addr,W_Data); always@(Addr or Write_Reg or Opt or A_B or R_Data_A or R_Data_B) begin if(Write_Reg) begin case(Opt) 2\u0026#39;b00: begin W_Data=32\u0026#39;h000f_000f; end 2\u0026#39;b01: begin W_Data=32\u0026#39;h0f0f_0f00; end 2\u0026#39;b10: begin W_Data=32\u0026#39;hf0f0_f0f0; end 2\u0026#39;b11: begin W_Data=32\u0026#39;hffff_ffff; end endcase end else if(A_B) begin R_Addr_A=Addr; case(Opt) 2\u0026#39;b00: LED=R_Data_A[7:0]; 2\u0026#39;b01: LED=R_Data_A[15:8]; 2\u0026#39;b10: LED=R_Data_A[23:16]; 2\u0026#39;b11: LED=R_Data_A[31:24]; endcase end else begin R_Addr_B=Addr; case(Opt) 2\u0026#39;b00: LED=R_Data_B[7:0]; 2\u0026#39;b01: LED=R_Data_B[15:8]; 2\u0026#39;b10: LED=R_Data_B[23:16]; 2\u0026#39;b11: LED=R_Data_B[31:24]; endcase end end endmodule 寄存器堆实现的Fourth_experiment_first模块\nmodule Fourth_experiment_first(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,W_Addr,W_Data); input [4:0]R_Addr_A,R_Addr_B,W_Addr; input Write_Reg,Reset,Clk; input[31:0] W_Data; output [31:0] R_Data_A,R_Data_B; reg [31:0] REG_Files[0:31]; integer i=0; always @ (posedge Clk or posedge Reset) begin if(Reset) begin for(i=0;i\u0026lt;=31;i=i+1) REG_Files[i]\u0026lt;=0; end else begin if(Write_Reg) REG_Files[W_Addr]\u0026lt;=W_Data; end end assign R_Data_A = REG_Files[R_Addr_A]; assign R_Data_B = REG_Files[R_Addr_B]; endmodule 测试模块\nmodule Fourth_experiment_test; // Inputs reg [4:0] Addr; reg Write_Reg; reg [1:0] Opt; reg Clk; reg Reset; reg A_B; // Outputs wire [7:0] LED; RegisterFile uut ( .Addr(Addr), .Write_Reg(Write_Reg), .Opt(Opt), .Clk(Clk), .Reset(Reset), .A_B(A_B), .LED(LED) ); always #20 Clk = ~Clk; initial begin Addr = 5\u0026#39;b00001; Write_Reg = 1; Opt = 0; Clk = 1; Reset = 0; A_B = 0; #100; Addr = 5\u0026#39;b00001; Write_Reg = 0; Opt = 0; A_B = 0; end endmodule 代码地址 # 代码地址\n","date":"21 December 2020","permalink":"/posts/hdu-computer-organization-and-architecture-experiment/fourth_experiment/","section":"Blog","summary":"实验内容 # 学习使用Verilog HDL 进行时序电路的设计方法 掌握灵活运用Verilog HDL进行各种描述与建模的技巧和方法 学习寄存器堆的数据传送与读/写工作原理，掌握寄存器堆的设计方法 解决方法 # 分析一个32x32位的寄存器堆，即含有32个寄存器，每个寄存器32位。该寄存器堆有2个读端口、1个写端口，即能够同时读出2个寄存器的值，写入1个寄存器 首先，分析出两个端口读入是5位的地址，读出的数据是32位的两个，该寄存器堆只有一个写端口，还要配合控制信号Write_Reg，且写操作是边沿触发的，所有写入操作的输入信号必须在时钟边沿来临时已经有效 寄存器堆的读操作和写操作的地址译码，只需引用寄存器地址作为数组的下标即可；读只需要组合逻辑，给出寄存器地址，读出数据 代码展示： 顶层模块（需要数据输入在板子上操作）：","title":"杭电计算机组成实验 实验4-寄存器堆设计实验"},{"content":"","date":"21 December 2020","permalink":"/tags/%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8/","section":"Tags","summary":"","title":"超前进位加法器"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"努力学习的小菜鸡\nContact # GitHub Email ","date":"1 January 0001","permalink":"/about/","section":"Welcome to XdpCs’s blog!","summary":"努力学习的小菜鸡","title":"关于我"}]