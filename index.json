[{"content":"","date":"6 December 2023","permalink":"/projects/comfyuiclient/","section":"Projects","summary":"","title":"ComfyUIClient"},{"content":"","date":"18 April 2023","permalink":"/projects/flt-withdraw/","section":"Projects","summary":"","title":"flt-withdraw"},{"content":"","date":"18 November 2022","permalink":"/projects/solidity-learning/","section":"Projects","summary":"","title":"Solidity-Learning"},{"content":"","date":"25 December 2020","permalink":"/projects/hdu-computer-organization/","section":"Projects","summary":"","title":"杭州电子科技大学计算机组成实验：代码和解析"},{"content":"","date":null,"permalink":"/blogs/","section":"Blog","summary":"","title":"Blog"},{"content":"简介 # base64是一种用64个字符来表示任意二进制数据的方法 用途 # 用于在HTTP协议下传输二进制数据 用于在URL中传输参数 用于加密 用于数据校验，数据压缩，数据编码 Go #在Go语言中，encoding/base64包实现了base64编码和解码\n它们分别为base64.StdEncoding,base64.URLEncoding, base64.RawStdEncoding, base64.RawURLEncoding\nbase64.StdEncoding # 标准base64编码，使用的字符集为A-Z，a-z，0-9，+，/ 以及填充字符=，编码后的字符串长度为4的倍数 在接入sd3 ，返回接口的格式为base64.StdEncoding，但是错误的使用了base64.RawStdEncoding ，导致解码失败，但是出来的图片经过上传，能在浏览器中显示，但是在代码中一直抛出error\nbase64.URLEncoding # URL兼容的base64编码，使用的字符集为A-Z，a-z，0-9，-，_ 以及填充字符=，编码后的字符串长度为4的倍数 base64.RawStdEncoding # 标准base64编码，使用的字符集为A-Z，a-z，0-9，+，/，不需要填充字符=，编码后的字符串不会做任何填充 base64.RawURLEncoding # URL兼容的base64编码，使用的字符集为A-Z，a-z，0-9，-，_，不需要填充字符=，编码后的字符串不会做任何填充 例子 #package main import ( \u0026#34;encoding/base64\u0026#34; \u0026#34;fmt\u0026#34; ) // @Title main.go // @Description // @Create XdpCs 2024-06-11 10:15 // @Update XdpCs 2024-06-11 10:15 func main() { data := []byte(\u0026#34;Hello//\u0026#34;) // base64.StdEncoding dst := make([]byte, base64.StdEncoding.EncodedLen(len(data))) base64.StdEncoding.Encode(dst, data) fmt.Println(\u0026#34;base64.StdEncoding: \u0026#34;, string(dst)) fmt.Println(\u0026#34;base64.StdEncoding len: \u0026#34;, len(dst)) // base64.RawStdEncoding dst = make([]byte, base64.RawStdEncoding.EncodedLen(len(data))) base64.RawStdEncoding.Encode(dst, data) fmt.Println(\u0026#34;base64.RawStdEncoding: \u0026#34;, string(dst)) fmt.Println(\u0026#34;base64.RawStdEncoding len: \u0026#34;, len(dst)) // base64.URLEncoding dst = make([]byte, base64.URLEncoding.EncodedLen(len(data))) base64.URLEncoding.Encode(dst, data) fmt.Println(\u0026#34;base64.URLEncoding: \u0026#34;, string(dst)) fmt.Println(\u0026#34;base64.URLEncoding len: \u0026#34;, len(dst)) // base64.RawURLEncoding dst = make([]byte, base64.RawURLEncoding.EncodedLen(len(data))) base64.RawURLEncoding.Encode(dst, data) fmt.Println(\u0026#34;base64.RawURLEncoding: \u0026#34;, string(dst)) fmt.Println(\u0026#34;base64.RawURLEncoding len: \u0026#34;, len(dst)) } ","date":"11 June 2024","permalink":"/blogs/go/base64_encoding/","section":"Blog","summary":"简介 # base64是一种用64个字符来表示任意二进制数据的方法 用途 # 用于在HTTP协议下传输二进制数据 用于在URL中传输参数 用于加密 用于数据校验，数据压缩，数据编码 Go #在Go语言中，encoding/base64包实现了base64编码和解码","title":"encoding/base64"},{"content":"","date":null,"permalink":"/tags/golang/","section":"Tags","summary":"","title":"Golang"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/tags/aigc/","section":"Tags","summary":"","title":"Aigc"},{"content":"","date":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects"},{"content":"痛点 #例子 #package main import \u0026#34;fmt\u0026#34; type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func main() { t := \u0026amp;TreeNode{ Val: 1, Left: \u0026amp;TreeNode{ Val: 2, }, Right: \u0026amp;TreeNode{ Val: 3, }, } fmt.Println(t) } 输出 #\u0026amp;{1 0x14000126018 0x14000126030} 我们从上述的例子可以看到，我们无法打印出结构体内部的Left和Right，只能打印出他们的地址\n解决办法 #使用程序库 #https://github.com/XdpCs/print-value\n例子 #package main import ( \u0026#34;fmt\u0026#34; print \u0026#34;github.com/XdpCs/print-value\u0026#34; ) type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func main() { t := \u0026amp;TreeNode{ Val: 1, Left: \u0026amp;TreeNode{ Val: 2, }, Right: \u0026amp;TreeNode{ Val: 3, }, } fmt.Println(print.Print(t)) } 结果 #TreeNode{Val:1,Left:TreeNode{Val:2,Left:nil,Right:nil},Right:TreeNode{Val:3,Left:nil,Right:nil}} ","date":"9 November 2023","permalink":"/blogs/go/print_value/","section":"Blog","summary":"痛点 #例子 #package main import \u0026#34;fmt\u0026#34; type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func main() { t := \u0026amp;TreeNode{ Val: 1, Left: \u0026amp;TreeNode{ Val: 2, }, Right: \u0026amp;TreeNode{ Val: 3, }, } fmt.","title":"Go打印结构体指针中的具体内容，而无需实现String()方法"},{"content":"","date":null,"permalink":"/tags/web3/","section":"Tags","summary":"","title":"Web3"},{"content":"背景 # 当新接手他人的项目，我们很容易不知所措，不知道这个函数的作用是什么，即使有很好的命名规范，这种事情也会时常发生，甚至有时候几个月不碰这个项目，自己再看这个函数，也会有一种云里雾里的感觉 如果拥有好的注释，方便我们自己以后维护，也方便后来的同事接手你的项目，不至于对你的代码说这写的是啥，像一坨💩 注释规范 # 注释语言看团队，我们团队习惯使用英文，所以都使用英文，只要整个团队统一一个注释语言即可 全部使用单行注释,//后需要使用一个空格 包注释 # 包注释是对包的介绍 每个包都至少有一个包注释，在同一个包下，任一一个源文件中注释即可 放置在package之前，来简短描述这个包的功能 // 包的功能介绍 package 包名称 文件注释 # 每个文件都应有一个文件注释 放置在package之后，需要包含文件名称，文件描述，文件作者及其时间，更新作者及其时间 因为在公司正常开发流程中，可能合并分支的时候，只有自己部门的业务主管，有这个权限进行合并代码，如果去看git的日志，如果只看主分支，只会显示主管的id，很难很快落实到每个人上 package 包名称 // @Title 文件名称 // @Description 文件描述 // @Create 创建作者 日期 时间 // @Update 更新作者 日期 时间 结构体注释和接口注释 # 每个结构体或接口都应有注释 在结构体或接口定义上面，需要有一个对整个结构体或接口的简要介绍 结构体或接口内的每个成员变量也需要有注释 // User defines user login info type User struct { UserName string // user\u0026#39;s name Password string // user\u0026#39;s password } // IUser defines user function type IUser interface { Login() // user login into the system Logout() // user logout the system } 函数和方法的注释 # 每个函数或方法都应有注释 需要包含函数或方法名称、函数或方法描述、函数或方法的创建作者及其创建时间、输入参数及其参数类型和解释、返回参数及其参数类型和解释 在函数或方法定义上面，书写下面的注释 // 函数或方法名称 // @Description 函数或方法描述 // @Create 作者 日期 时间 // @Param 输入参数名 参数类型 解释 // @Return 返回参数名 参数类型 解释 如果涉及到函数或方法的变更，需要写明修改作者、修改日期和时间、修改的功能描述 // @Modified 作者 日期 时间 // @Modify description 修改的功能描述 代码逻辑注释 # 每个代码块都需要添加注释 // This is my wife\u0026#39;s birthday if birthday == 1118 { ... } 配置 # 本配置均采用Goland IDE 包注释和文件注释配置 #Mac 使用 # Goland-\u0026gt;Settings-\u0026gt;Editor-\u0026gt;File and Code Templates-\u0026gt;Go File 复制下面的模版，替换原先的模版 // package ${GO_PACKAGE_NAME} // @Title ${FILE_NAME} // @Description // @Create XdpCs ${YEAR}-${MONTH}-${DAY} ${TIME} // @Update XdpCs ${YEAR}-${MONTH}-${DAY} ${TIME} 修改注释的快捷键配置 #Mac 使用 # Goland-\u0026gt;Settings-\u0026gt;Editor-\u0026gt;Live Templates 复制下面的模版，替换原先的模版 // @Modified XdpCs $date$ $time$:00 // @Modify description 点击Edit Variables\u0026hellip; 配置如下图所示 配置完成后，点击Define，勾选Go 使用只需要使用modify+回车即可 结构体注释、接口注释、函数注释、方法注释 #安装插件 # Goanno插件 同时也可以使用Goland的Marketplace搜索进行安装 配置插件注释格式，使用Tools-\u0026gt; Goanno Settings 函数注释、方法注释 # Normal Method 配置、Interface Method 配置 // ${function_name} // @Description ${todo} // @Create XdpCs ${date} // @Param ${param_name} ${param_type} // @Return ${ret_name_type} 结构体注释 # Struct 配置 // ${struct_name} 接口注释 # Interface 配置 // ${interface_name} 测试 # 使用control + command + /进行测试 示例 #示例\n","date":"13 March 2023","permalink":"/blogs/go/go_code_comment_standard/","section":"Blog","summary":"背景 # 当新接手他人的项目，我们很容易不知所措，不知道这个函数的作用是什么，即使有很好的命名规范，这种事情也会时常发生，甚至有时候几个月不碰这个项目，自己再看这个函数，也会有一种云里雾里的感觉 如果拥有好的注释，方便我们自己以后维护，也方便后来的同事接手你的项目，不至于对你的代码说这写的是啥，像一坨💩 注释规范 # 注释语言看团队，我们团队习惯使用英文，所以都使用英文，只要整个团队统一一个注释语言即可 全部使用单行注释,//后需要使用一个空格 包注释 # 包注释是对包的介绍 每个包都至少有一个包注释，在同一个包下，任一一个源文件中注释即可 放置在package之前，来简短描述这个包的功能 // 包的功能介绍 package 包名称 文件注释 # 每个文件都应有一个文件注释 放置在package之后，需要包含文件名称，文件描述，文件作者及其时间，更新作者及其时间 因为在公司正常开发流程中，可能合并分支的时候，只有自己部门的业务主管，有这个权限进行合并代码，如果去看git的日志，如果只看主分支，只会显示主管的id，很难很快落实到每个人上 package 包名称 // @Title 文件名称 // @Description 文件描述 // @Create 创建作者 日期 时间 // @Update 更新作者 日期 时间 结构体注释和接口注释 # 每个结构体或接口都应有注释 在结构体或接口定义上面，需要有一个对整个结构体或接口的简要介绍 结构体或接口内的每个成员变量也需要有注释 // User defines user login info type User struct { UserName string // user\u0026#39;s name Password string // user\u0026#39;s password } // IUser defines user function type IUser interface { Login() // user login into the system Logout() // user logout the system } 函数和方法的注释 # 每个函数或方法都应有注释 需要包含函数或方法名称、函数或方法描述、函数或方法的创建作者及其创建时间、输入参数及其参数类型和解释、返回参数及其参数类型和解释 在函数或方法定义上面，书写下面的注释 // 函数或方法名称 // @Description 函数或方法描述 // @Create 作者 日期 时间 // @Param 输入参数名 参数类型 解释 // @Return 返回参数名 参数类型 解释 如果涉及到函数或方法的变更，需要写明修改作者、修改日期和时间、修改的功能描述 // @Modified 作者 日期 时间 // @Modify description 修改的功能描述 代码逻辑注释 # 每个代码块都需要添加注释 // This is my wife\u0026#39;s birthday if birthday == 1118 { .","title":"Go语言注释规范"},{"content":" 公共模块代理: export GOPROXY=https://goproxy.io 同样可以设置为 https://goproxy.cn\n私有模块代理： export GOPRIVATE=git.xxx.com 初始化： go mod init [module 名称] 检测和清理依赖： go mod tidy 安装指定包： go get -v github.com/go-ego/gse@v0.60.0-rc4.2 go mod下，go get github.com/go-ego/gse@v0.60.0 可以跟语义化版本号，也可以跟git的分支go get github.com/go-ego/gse@master ,也可以跟git的提交哈希go get github.com/go-ego/gse@e3702bed2 go get遵循最小版本选择原则，只会下载不超过这个最大版本号，如果使用go get github.com/go-ego/gse@master ，下次在下载只会和第一次的一样，无论 master 分支是否更新了代码\n查看所有可以升级依赖版本： go list -u -m all 更新依赖： go get -u 更新指定包依赖： go get -u github.com/go-ego/gse 更新补丁版本号 go get -u=patch github.com/go-ego/gse 指定版本： go get -u github/com/go-ego/gse@v0.60.0-rc4.2 升降级版本号，使用比较运算符控制 go get github/com/go-ego/gse@`\u0026lt;v0.60.0` Replace:\n使用命令行： go mod edit -replace github.com/go-ego/gse = /path/to/local/gse go mod edit -replace github.com/go-ego/gse = github.com/vcaesar/gse 直接修改模块文件： replace github.com/go-ego/gse =\u0026gt; github.com/vcaesar/gse 移除依赖： go mod tidy go mod edit --droprequire=golang.org/x/crypto,仅仅修改go.mod配置文件的内容\n查看依赖包： go list -m all go list -m -json all # json 格式输出 模块配置格式化 go mod edit -fmt 常用命令： go mod init # 初始化 go mod tidy # 更新依赖文件,移除不需要的包 go mod download # 下载依赖文件 go mod vendor # 将依赖转移至本地的 vendor文件 go mod edit # 手动修改依赖文件 go mod graph # 打印依赖图 go mod verify # 校验依赖 在go mod模式，如果没有此依赖，在运行go run main.go会先去下载此依赖，当然不只是go run,go build、go test 命令也能自动下载相关依赖包\ngo mod不会在$GOPATH/src目录下保存相关引用包的源码，而包源码和链接库保存在$GOPATH/pkg/mod目录下\n","date":"21 January 2023","permalink":"/blogs/go/go_module/","section":"Blog","summary":"公共模块代理: export GOPROXY=https://goproxy.","title":"Go Module"},{"content":"","date":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo"},{"content":"问题1 #found no layout file for \u0026#34;HTML\u0026#34; for kind \u0026#34;page\u0026#34;: You should create a template file which matches Hugo Layouts Lookup Rules for this combination. 解决方法 #hugo mod clean hugo server ","date":"29 November 2022","permalink":"/blogs/hugo/hugo_error/","section":"Blog","summary":"问题1 #found no layout file for \u0026#34;HTML\u0026#34; for kind \u0026#34;page\u0026#34;: You should create a template file which matches Hugo Layouts Lookup Rules for this combination.","title":"hugo 遇到的问题"},{"content":"","date":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git"},{"content":"原理 # 本地仓库由git维护三棵\u0026quot;树\u0026quot; 第一个是工作目录,它拥有实际的文件 第二个是暂存区，它类似于缓存的存在，临时保存你的改动 第三个是HEAD,它指向最后一次提交的结果 概念 #分支 # 分支是用来将特性开发隔离开。在你创建仓库的时候，master或main是默认的分支。我们一般在其他分支上进行开发，完成后再将它们合并到主分支上 你在本地创建的分支，如果不推送到远端仓库，这个分支就只能在本地可见 命令 # 命令只介绍在开发过程中，常用的命令 创建新的git仓库 #git init 添加到暂存区 #git add \u0026lt;filename\u0026gt; git add . git add \u0026lt;filename\u0026gt; ,添加具体文件到暂存区 git add .,将所有变动添加到暂存区 这是git基本工作流程的第一步，将文件添加到暂存区 提交 #git commit -m \u0026#34;提交信息\u0026#34; 将改动提交到本地仓库的HEAD中 这是git基本工作流程的第二步，将文件提交到本地仓库的HEAD中 推送 #git push origin master 将改动提交到远端仓库，可以将master换成任何你想要推送的分支 这是git基本工作流程的第三步，推送到远端仓库 git remote add origin \u0026lt;server\u0026gt; 将你的仓库连接到远端仓库，若你本地仓库未和远端仓库建立关系 分支 #git checkout -b feature_xdp 创建一个叫做feature_xdp的分支 git checkout master 切换到主分支 更新与合并 #git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; 标准格式 以当前工作目录进行获取（fetch）并合并（merge）远端的改动 git pull git pull origin 将远端仓库的origin的master分支拉取到本地，并与本地的当前分支进行合并 git pull origin master:feature_xdp 将远端仓库的origin的master分支拉取过来，与本地的feature_xdp分支合并 git pull origin master 如果远端仓库的分支是与当前分支合并，则冒号后面的部分可以省略 git merge \u0026lt;branch\u0026gt; 合并其他分支到当前分支 冲突 # git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; 和 git merge \u0026lt;branch\u0026gt;,在两种情况下，git 会尝试自动合并改动，但是并不是每一次都会成功，可能会出现冲突。这个时候，需要你手动修改来合并这些冲突 git add \u0026lt;filename\u0026gt; 合并完成后，需要将它们添加到暂存区 git diff \u0026lt;source_branch\u0026gt; \u0026lt;target_branch\u0026gt; 可以使用该命令预览差异，在合并改动之前 log #git log 查看本地仓库历史记录 git log --author=XdpCs 只看XdpCs的提交记录 git log --pretty=oneline 每一条提交记录只占一行输出 git log --graph --oneline --decorate --all 通过树形结构来展示所有的分支，每个分支都标明它的名字和标签 git log --name-status 查看哪些文件发生改变 标签 # 通过创建标签，发布软件是一个不错的方法 git tag 1.0.0 1fd11181114 创建一个叫1.0.0的标签，1fd11181114是你想要标记的提交ID 提交ID可以通过上面的git log获取 只要提交ID具有指向唯一性，提交ID可以少几位 替换本地改动 #git checkout -- \u0026lt;filename\u0026gt; 使用HEAD中最新的内容替换掉你工作目录中的文件 已添加到暂存区的改动和新文件不会受到影响 git fetch origin git reset --hard origin/master 丢弃本地的所有改动和提交，从远端服务器获取最新的版本历史，并将本地分支指向它 克隆仓库 #git clone ../xdpcs.github.io 创建一个本地仓库的克隆版本 git clone git@github.com:XdpCs/Solidity-Learning.git 克隆一个远端服务器上的仓库 ","date":"18 November 2022","permalink":"/blogs/git/git_study/","section":"Blog","summary":"原理 # 本地仓库由git维护三棵\u0026quot;树\u0026quot; 第一个是工作目录,它拥有实际的文件 第二个是暂存区，它类似于缓存的存在，临时保存你的改动 第三个是HEAD,它指向最后一次提交的结果 概念 #分支 # 分支是用来将特性开发隔离开。在你创建仓库的时候，master或main是默认的分支。我们一般在其他分支上进行开发，完成后再将它们合并到主分支上 你在本地创建的分支，如果不推送到远端仓库，这个分支就只能在本地可见 命令 # 命令只介绍在开发过程中，常用的命令 创建新的git仓库 #git init 添加到暂存区 #git add \u0026lt;filename\u0026gt; git add .","title":"Git 学习"},{"content":"Hi! My name is Alan Xu. #Enjoy any project that uses the Go programming language. #Currently, learning English, Go, Solidity, Mysql, and Redis. #","date":null,"permalink":"/","section":"Welcome to XdpCs’s blog!","summary":"Hi! My name is Alan Xu.","title":"Welcome to XdpCs’s blog!"},{"content":"","date":null,"permalink":"/tags/architecture/","section":"Tags","summary":"","title":"Architecture"},{"content":"","date":null,"permalink":"/tags/fpga/","section":"Tags","summary":"","title":"Fpga"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":" 2022年从杭州不知名院校本科毕业 本科前两年一直研究嵌入式，参加过智能车竞赛、电子设计竞赛，获得了一些奖项 后面随着大流，接触Java，那时候不知道自己要做什么样的工作，要成为什么样的人 机缘巧合入职后，将自己的技术栈转换到Golang 虽然现在我的依然不知道自己想要做什么样的工作，想要成为什么样的人，但我一直在寻找自己真正感兴趣的方向 Contact # GitHub Email ","date":null,"permalink":"/about/","section":"Welcome to XdpCs’s blog!","summary":" 2022年从杭州不知名院校本科毕业 本科前两年一直研究嵌入式，参加过智能车竞赛、电子设计竞赛，获得了一些奖项 后面随着大流，接触Java，那时候不知道自己要做什么样的工作，要成为什么样的人 机缘巧合入职后，将自己的技术栈转换到Golang 虽然现在我的依然不知道自己想要做什么样的工作，想要成为什么样的人，但我一直在寻找自己真正感兴趣的方向 Contact # GitHub Email ","title":"关于我"}]