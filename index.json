[{"content":"","date":"18 November 2022","permalink":"/projects/solidity-learning/","section":"Projects","summary":"","title":"Solidity-Learning"},{"content":"","date":"25 December 2020","permalink":"/projects/hdu-computer-organization-and-architecture-experiment/","section":"Projects","summary":"","title":"杭电计算机组成实验"},{"content":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库\n基础知识 # 结构体(Struct)是引用类型 你可以通过结构体(Struct)定义自己的类型 结构体(Struct)可以将相关数据分组在一起 结构体(Struct)可以声明在合约外面并从其他合约中导入 结构体(Struct)无法包含其自身类型 结构体(Struct)中，若成员变量存在引用类型，建议使用storage获取该结构体的引用，以防止引用类型的数据丢失 结构体(Struct)有三种初始化的方法，会在下文的例子中讲到 例子 #例子\n该例子是通过使用结构体(Struct)存储待办事项的例子\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Todos { struct Todo { string text; bool completed; } Todo[] public todos; function createOneWay(string memory _text) public { todos.push(Todo(_text, false)); } function createTwoWay(string memory _text) public { todos.push(Todo({text : _text, completed : false})); } function createThreeWay(string memory _text) public { Todo memory todo; todo.text = _text; todos.push(todo); } function get(uint _index) public view returns (string memory text, bool completed){ Todo storage todo = todos[_index]; return (todo.text, todo.completed); } function update(uint _index, string memory _text) public { Todo storage todo = todos[_index]; todo.text = _text; } function toggleCompleted(uint _index) public { Todo storage todo = todos[_index]; todo.completed = !todo.completed; } } 程序解析 #struct Todo { string text; bool completed; } 待办事项的结构体(Struct) Todo[] public todos; Todo结构体(Struct)数组 function createOneWay(string memory _text) public { todos.push(Todo(_text, false)); } function createTwoWay(string memory _text) public { todos.push(Todo({text : _text, completed : false})); } function createThreeWay(string memory _text) public { Todo memory todo; todo.text = _text; todos.push(todo); } 三种方法初始化一个结构体(Struct) Todo(_text, false)，像函数调用一样初始化，这种方式不推荐，因为如果在结构体中间新增一个新的变量，所有初始化函数都需要改 Todo({text : _text, completed : false})，像键值对映射一样初始化，强烈推荐 Todo memory todo初始化一个结构体(Struct)变量，然后对其进行赋值 function get(uint _index) public view returns (string memory text, bool completed){ Todo storage todo = todos[_index]; return (todo.text, todo.completed); } 由于todos声明为public，Solidity会自动生成get方法，所以你其实不需要此方法 function update(uint _index, string memory _text) public { Todo storage todo = todos[_index]; todo.text = _text; } 更新text function toggleCompleted(uint _index) public { Todo storage todo = todos[_index]; todo.completed = !todo.completed; } 更新completed ","date":"6 December 2023","permalink":"/blogs/solidity/011.structs/","section":"Blog","summary":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库","title":"011-结构体(Struct)"},{"content":"","date":null,"permalink":"/blogs/","section":"Blog","summary":"","title":"Blog"},{"content":"","date":null,"permalink":"/tags/solidity/","section":"Tags","summary":"","title":"Solidity"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库\n基础知识 # 创建映射(Mapping)的语法是mapping(KeyType KeyName? =\u0026gt; ValueType ValueName?) VariableName，也可以写成mapping(KeyType =\u0026gt; ValueType) 新增Key Value的语法是Var[Key] = Value，其中Var是映射变量名，Key和Value对应新增的键值对 删除Key Value的语法是delete Var[Key]，其中Var是映射变量名，Key是要删除的键 映射(Mapping)类似于数据结构中的哈希表 映射(Mapping)的细节 KeyType可以是Solidity的 值类型，bytes，string和合约类型,不可以使用自定义结构体 ValueType可以是任何类型包含映射(Mapping)或者数组或者结构体 映射(Mapping)的存储数据位置必须是storage,可以用于存储状态变量或函数内的存储引用或库函数的参数 映射(Mapping)不能作为函数的参数或返回结果 映射(Mapping)不能被遍历 若映射(Mapping)声明为public，那么Solidity会自动给你创建一个getter函数，可以通过Key来查询对应的Value 映射(Mapping)原理 映射(Mapping)在实际的初始化过程中，创建每个可能的Key，并将其映射到字节形式全是零的值:一个类型的默认值 在映射(Mapping)中，实际上并不存储Key的值，而是存储它的keccak256的哈希值，从而便于查询实际的值 映射(Mapping)中不存储length的信息 例子 #例子\n该例子是使用映射(Mapping)的例子\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.20; contract Mapping { mapping(address =\u0026gt; uint) public map; mapping(ValueContract =\u0026gt; uint) public contractMap; function getMap(address _addr) public view returns (uint){ return map[_addr]; } function setMap(address _addr, uint _i) public { map[_addr] = _i; } function removeMap(address _addr) public { delete map[_addr]; } function getContractMap(ValueContract _addr) public view returns (uint){ return contractMap[_addr]; } function setContractMap(ValueContract _addr, uint _i) public { contractMap[_addr] = _i; } function removeContractMap(ValueContract _addr) public { delete contractMap[_addr]; } } contract NestedMapping { mapping(address =\u0026gt; mapping(uint =\u0026gt; bool)) public nested; function get(address _addr, uint _i) public view returns (bool){ return nested[_addr][_i]; } function set(address _addr, uint _i, bool _boo) public { nested[_addr][_i] = _boo; } function remove(address _addr, uint _i) public { delete nested[_addr][_i]; } } contract ValueContract { uint public value; constructor(uint _value) { value = _value; } } 程序解析 #ValueContract 合约 #contract ValueContract {} 声明了一个叫ValueContract的空合约 Mapping 合约 #mapping(address =\u0026gt; uint) public map; mapping(ValueContract =\u0026gt; uint) public contractMap; 声明了map和contractMap，分别从 address 映射到 uint 和 ValueContract 映射到 uint map和contractMap 声明为public,其实会自动生成get函数 function getMap(address _addr) public view returns (uint){ return map[_addr]; } function getContractMap(ValueContract _addr) public view returns (uint){ return contractMap[_addr]; } 映射(Mapping)总是返回一个值 如果这个值从没被设置过，则将会返回默认值 function setMap(address _addr, uint _i) public { map[_addr] = _i; } function getContractMap(ValueContract _addr) public view returns (uint){ return contractMap[_addr]; } 更新这个地址或这个合约类型映射的值 function removeMap(address _addr) public { delete map[_addr]; } function removeContractMap(ValueContract _addr) public { delete contractMap[_addr]; } 重置这个值到默认值 NestedMapping 合约 #mapping(address =\u0026gt; mapping(uint =\u0026gt; bool)) public nested; 嵌套映射 address 到 另一个mapping function get(address _addr, uint _i) public view returns (bool){ return nested[_addr][_i]; } 你可以从嵌套映射中得到值，即使没有初始化 function set(address _addr, uint _i, bool _boo) public { nested[_addr][_i] = _boo; } 设置这个地址和这个整数型的值 function remove(address _addr, uint _i) public { delete nested[_addr][_i]; } 重置这个值到默认值 ","date":"5 December 2023","permalink":"/blogs/solidity/010.mapping/","section":"Blog","summary":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库","title":"010-映射(Mapping)"},{"content":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库\n基础知识 # 需要为一笔交易支付多少 ether ? 需要支付 gas消耗(gas spent) * gas价格(gas price)数量的ether gas：计算单位 gas消耗(gas spent)：一笔交易中消耗的gas总数 gas价格(gas price)：你愿意支付的gas单价 拥有更高的gas价格的交易会有更高的优先权被打包入区块中 没有消耗完的gas将会被归还 Gas限制(gas limit) 你能花费的gas数量有2个上限 gas限制(gas limit)：你所设置的用在这笔交易中最大数量的gas 区块gas限制(block gas limit)：网络中设置的区块中所允许的最大数量的gas 使用完你发送的所有gas，这会导致交易失败，状态变量的更改会被回滚，消耗的gas不会被退还 这样的机制是为了防止用户，使用低价gas去滥用系统 例子 #例子\n该例子说明了死循环，消耗完用户所提供的所有gas，导致交易失败\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.20; contract GasAndGasPrice { uint public i = 0; function forever() external { while (true) { i += 1; } } } 程序解析 #function forever() external { while (true) { i += 1; } } 这个循环运行直至所有gas消耗光，然后交易失败 ","date":"2 December 2023","permalink":"/blogs/solidity/009.gas_and_gas_price/","section":"Blog","summary":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库","title":"009-Gas和Gas价格"},{"content":"","date":null,"permalink":"/tags/golang/","section":"Tags","summary":"","title":"Golang"},{"content":"痛点 #例子 #package main import \u0026#34;fmt\u0026#34; type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func main() { t := \u0026amp;TreeNode{ Val: 1, Left: \u0026amp;TreeNode{ Val: 2, }, Right: \u0026amp;TreeNode{ Val: 3, }, } fmt.Println(t) } 输出 #\u0026amp;{1 0x14000126018 0x14000126030} 我们从上述的例子可以看到，我们无法打印出结构体内部的Left和Right，只能打印出他们的地址\n解决办法 #使用程序库 #https://github.com/XdpCs/print-value\n例子 #package main import ( \u0026#34;fmt\u0026#34; print \u0026#34;github.com/XdpCs/print-value\u0026#34; ) type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func main() { t := \u0026amp;TreeNode{ Val: 1, Left: \u0026amp;TreeNode{ Val: 2, }, Right: \u0026amp;TreeNode{ Val: 3, }, } fmt.Println(print.Print(t)) } 结果 #TreeNode{Val:1,Left:TreeNode{Val:2,Left:nil,Right:nil},Right:TreeNode{Val:3,Left:nil,Right:nil}} ","date":"9 November 2023","permalink":"/blogs/go/print_value/","section":"Blog","summary":"痛点 #例子 #package main import \u0026#34;fmt\u0026#34; type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func main() { t := \u0026amp;TreeNode{ Val: 1, Left: \u0026amp;TreeNode{ Val: 2, }, Right: \u0026amp;TreeNode{ Val: 3, }, } fmt.","title":"Go打印结构体指针中的具体内容，而无需实现String()方法"},{"content":"","date":null,"permalink":"/tags/gopl/","section":"Tags","summary":"","title":"gopl"},{"content":"1.1 hello,world # Go是编译型语言 Go的工具链将程序的源文件转变成为机器相关的原生二进制指令 go run 将一个或多个以.go为后缀的源文件进行编译、链接，然后运行生成的可执行文件 Go原生地支持Unicode,所以可以处理所有国家地语言 go build 可以编译输出成一个可复用的二进制程序文件，它可以直接执行 Go 代码是用包进行组织的，一个包由一个或多个.go源文件组成，放在一个文件夹中，文件夹的名字描述了包的作用 每个源文件都以一条package声明语句开始，表示该文件属于哪个包 main包是用来定义可独立执行的程序 import声明语句用来导入其他包，必须跟在package声明之后，且不能缺失导入或存在不需要的导入 一个函数的声明由func关键字、函数名、参数列表、返回值列表和函数体组成 Go不需要使用分号进行结尾，除非一行上有多条语句或声明，在特定符号后面的换行符会被转换为分号，所以换行会影响对Go代码的解析 gofmt 工具可以标准格式去格式化代码，会按照字母顺序表进行排序 goimports 工具可以自动添加或删除import声明 1.2 命令行参数 # os 包提供了与平台无关的操作系统函数和类型 os.Args 是一个字符串的切片，用来存储所有的命令行参数，第一个参数是命令本身，另外的元素是程序开始执行时的参数 注释以// 开头 或者 /* */ 包裹，编译器会忽略注释 习惯上，每个包都有一个包注释，位于包声明语句之前，用一个或多个完整句子对包的整体功能进行描述 var s string = “” 变量可以在声明时初始化，如果没有初始化，则变量隐式初始化为该类型的空值，数值类型为0，字符串为“”，布尔类型为false，指针为nil := 为短变量声明，用于声明并初始化值给予合适的类型，:= 左侧的变量不应该是已经声明过的，否则会导致编译错误 i++,i-- 为语句，不是表达式，所以不能赋值给另一个变量，自增自减仅支持后缀形式 Go中没有while语句，只有for循环语句，for 循环语句的三个组成部分外都是可选的，如果省略第一个分号和第二个分号之间的表达式，那么该循环就变成了一个无限循环，如果省略第二个分号后面的表达式，那么该循环就变成了C语言中的while 循环 range 关键字用于for循环中迭代数组、切片、字符串、map和通道，每次迭代都会返回两个值，第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本 使用空标识符_可以把不需要的值赋值给它，这样可以避免声明未使用的变量而导致编译错误 s := \u0026quot;\u0026quot; 通常在一个函数内部使用，不适合包级别的变量 var s string 默认初始化为空字符串“” s := \u0026quot;\u0026quot;, var s string 实践中，应当使用这两种形式，使用显式初始化来说明初始化变量的重要性，使用隐式初始化来表明初始化变量不重要 例子 通过+= 语句追加旧的字符串，会生成一个新的字符串，然后新字符串的地址赋值给变量s，旧的字符串会被垃圾回收器回收，如果有大量的数据需要处理，代价会非常大，推荐使用strings.Join 函数来拼接字符串 1.3 找出重复行 # map 存储了一组无序的键值对，其中所有的键都是不同的，并提供常量实践的操作来存储、获取或测试集合中的某个元素，键可以是其值能够进行相等比较的任意类型，值可以是任意类型的，可以使用内置函数make来创建一个map bufio 包 用于创建带缓冲的读取器，它可以包装任何io.Reader对象，简便且高效地处理输入和输出，bufio.NewScanner 函数可以创建一个从指定io.Reader对象读取数据的Scanner，默认的分割函数是bufio.ScanLines，可以使用bufio.ScanWords 来指定按照单词来分割输入 fmt.Printf 函数的第一个参数是格式化字符串，包含了两种类型的内容，普通字符和转义字符，普通字符会原样输出，转义字符以% 开头，用于表示一些特定的格式化操作，%s 表示字符串，%d 表示十进制整数，%f 或 %F 表示浮点数，%t 表示布尔值，%v 表示通用格式，%T 表示值的类型，%p 表示指针，%x 或 %X 表示十六进制，%b 或 %B 表示二进制，%o 或 %O 表示八进制，%q 表示带双引号的字符串，%c 表示字符(Unicode码点)，%U 表示Unicode格式，%e或%E 表示科学计数法，%g 或%G 表示根据情况选择%e或%f 以及%E或%F以产生更紧凑的(无末尾的0)输出，%% 表示百分号 字符串字面量可以包含类似转义序列来表示不可见字符，\\n 表示换行符，\\t 表示制表符，\\r 表示回车符，\\\\ 表示反斜杠，\\' 表示单引号，\\\u0026quot; 表示双引号，\\xhh 表示一个两位的十六进制数，\\uhhhh 表示一个四位的十六进制数，\\Uhhhhhhhh 表示一个八位的十六进制数 log.Printf 和 fmt.Errorf的格式化函数以f结尾，使用和fmt.Printf 相同的格式化字符串，但是不会将结果写入标准输出，而是将其格式化后的内容写入标准错误输出，log.Printf 函数会在每条日志消息的前面添加日期和时间的前缀，fmt.Errorf函数会在返回一个error结构体 以ln结尾的函数(如Println)，则使用%v的方式来格式化参数，并在最后追加换行符 函数os.Open 会返回两个值，第一个值是被打开的文件(或者内存中的数据流)，第二个值是一个错误值，如果操作成功，错误值为nil，否则错误值表示了错误的原因 函数和其他包级别的实体可以任意次序声明，但是在使用之前必须先声明，如果一个实体是在函数内部声明的，那么它只能在该函数内部使用，如果一个实体是在包级别声明的，那么它可以在整个包中使用，如果一个实体是以大写字母开头的，那么它可以被外部的包访问，如果一个实体是以小写字母开头的，那么它只能在同一个包内部使用 map是一个使用make创建的数据结构的引用，所以它可以被自由的传递，而不会发生复制，map的零值是nil，对一个nil的map，读取操作不会报错，写入操作会触发panic ioutil.ReadFile 函数可以读取一个文件的全部内容，返回的结果是一个字节slice，如果读取过程中发生错误，将会返回一个非nil的错误值，如果读取成功，错误值为nil 1.4 GIF动画 # 使用路径最后的一段来引用包 const声明用来给常量命名，常量的值必须是编译期可确定的数字、字符串、布尔值，const 声明可以出现在包级别 结构体是由一组称为字段的值组成，它们一起组成单个对象，作为一个单位被对待，结构体的字段用点号来访问，结构体的字段可以是任意类型，包括数组、切片、以及其他的结构体，结构体的字段名必须是唯一的，如果结构体的字段名以大写字母开头，那么该字段是导出的，也就是说可以被外部的包访问，如果结构体的字段名以小写字母开头，那么该字段是未导出的，也就是说只能在同一个包内部使用 1.5 获取一个URL # net包提供了可移植的网络I/O接口，包括TCP/IP、UDP、域名解析和Unix域socket，使用底层的网络连接，创建服务器 os.Exit(1)会在程序退出时返回一个状态码，非零状态码表示错误，零状态码表示成功，os.Exit 会立即终止当前程序，不会执行任何的defer函数 1.6 并发获取多个URL # goroutine 是一个并发执行的函数 通道是一种允许某一协程向另一个协程传递指定类型的值的通信机制，通道可以用make函数创建，通道的零值是nil ，通道的零值没有什么用，必须使用make函数来创建一个真正的通道 main函数在一个goroutine中执行，然后使用go语句创建额外的goroutine ioutil.Discard 是用来将输出流丢弃的，实现了Writer接口的变量，在统计长度时候经常使用 当一个goroutine试图在一个通道上进行发送或接收操作时，它会阻塞，直到另一个goroutine 试图进行接收或发送操作时才会解除阻塞，对于同一个通道来说，发送操作之间是互斥的，接收操作之间也是互斥的，但是发送操作和接收操作之间则是不互斥的 1.7 一个Web服务器 # if err := r.ParseForm(); err != nil 合并的语句更短，缩小了err变量的作用域，这是一个好的实践 可以使用go doc查看某个函数的文档 1.8 其他内容 # switch 中的case语句中可以使用逗号来分隔多个表达式，switch语句中的表达式可以省略，这种情况下，switch 语句等同于switch true语句，switch语句中的case表达式不必是常量或者整数，case 表达式的求值顺序是从上到下，当匹配成功的case表达式后，执行相应的语句后就会退出整个switch 语句，如果想要继续执行后面的case表达式，可以使用fallthrough语句，fallthrough语句不会判断下一条case 表达式的求值结果是否为true，fallthrough语句应该是case语句的最后一条语句。没有语句匹配，会走default 分支，如果没有default分支，那么switch语句将不做任何动作 无标签选择 package main func Signum(x int) int { switch { case x \u0026gt; 0: return +1 default: return 0 case x \u0026lt; 0: return -1 } } break 和 continue 可以改变控制流，break语句会跳转到整个switch, for, selecct 语句的结束标签，可以使用标签跳出多层循环。continue 语句会跳转到当前switch, for, selecct 语句的结束标签。 goto语句可以无条件地转移到过程中指定的行，goto语句通常与条件语句配合使用，可以实现条件转移，goto 语句在快速跳出循环、避免重复退出上有一定的帮助，但是在结构化程序设计中一般不主张使用goto 语句，以免造成程序流程的混乱，使理解和调试程序都产生困难，使用goto语句的地方可以使用break或者continue语句代替 type声明不仅仅可以给已有类型命名，还可以将其定义为一个新的类型，新的类型可以在原有类型的基础上添加一些额外的功能，但是底层的类型必须是一致的 指针的值是变量的地址，使用\u0026amp;操作符可以获取一个变量的地址，使用*操作符可以获取指针指向的变量的值，指针的零值是nil ，指针之间可以进行比较操作，只有当两个指针指向同一个变量或者两个指针都是nil 时候，比较的结果才为真，指针也可以指向一个结构体，指针的指针也是合法的，指针不能进行算术运算 方法是一个关联了命名类型的函数 接口可以用相同的方式处理不同的具体类型的抽象类型，它基于这些类型所包含的方法，而不是类型的描述或实现 接口可以被任意的对象实现，一个对象可以实现任意多个接口，任意类型都实现了空接口，因此空接口可以存储任意类型的数值，空接口可以用来处理未知类型的值 interface{}类型可以保存任意类型的值，可以使用switch语句来判断空接口中的值的类型，interface{} 类型本身是一个指针，内部存储了类型的信息，interface{}类型的变量只有在类型和值都为nil的时候才为nil，interface{} 类型的变量可以作为函数的参数，通过interface{} 类型的变量可以调用其内部包含的值的方法，但是如果没有类型信息，就无法调用其内部包含的值的方法，interface{} 类型的变量可以使用类型断言来判断其内部包含的值的类型，类型断言的语法是x.(T)，其中x表示interface{}类型的变量，T 表示断言x可能是的类型，如果x是T类型，那么就会返回其内部包含的值，否则就会触发panic，类型断言也可以用在switch 语句中，switch语句中的case表达式中的类型断言可以将x的类型限制为T类型，如果x不是T类型，那么该case就不会被执行，反之 在声明任何函数前，写一段注释来说明它的行为是一个好的风格，且这样可以被go doc和godoc工具定位和作为文档显示 对跨越多行的注释，使用/*...*/进行注释，对于单行注释，使用//进行注释，两种注释不能相互嵌套 ","date":"7 August 2023","permalink":"/blogs/gopl/ch1/","section":"Blog","summary":"1.1 hello,world # Go是编译型语言 Go的工具链将程序的源文件转变成为机器相关的原生二进制指令 go run 将一个或多个以.","title":"第1章-入门-笔记"},{"content":"背景 # 当新接手他人的项目，我们很容易不知所措，不知道这个函数的作用是什么，即使有很好的命名规范，这种事情也会时常发生，甚至有时候几个月不碰这个项目，自己再看这个函数，也会有一种云里雾里的感觉 如果拥有好的注释，方便我们自己以后维护，也方便后来的同事接手你的项目，不至于对你的代码说这写的是啥，像一坨💩 注释规范 # 注释语言看团队，我们团队习惯使用英文，所以都使用英文，只要整个团队统一一个注释语言即可 全部使用单行注释,//后需要使用一个空格 包注释 # 包注释是对包的介绍 每个包都至少有一个包注释，在同一个包下，任一一个源文件中注释即可 放置在package之前，来简短描述这个包的功能 // 包的功能介绍 package 包名称 文件注释 # 每个文件都应有一个文件注释 放置在package之后，需要包含文件名称，文件描述，文件作者及其时间，更新作者及其时间 因为在公司正常开发流程中，可能合并分支的时候，只有自己部门的业务主管，有这个权限进行合并代码，如果去看git的日志，如果只看主分支，只会显示主管的id，很难很快落实到每个人上 package 包名称 // @Title 文件名称 // @Description 文件描述 // @Create 创建作者 日期 时间 // @Update 更新作者 日期 时间 结构体注释和接口注释 # 每个结构体或接口都应有注释 在结构体或接口定义上面，需要有一个对整个结构体或接口的简要介绍 结构体或接口内的每个成员变量也需要有注释 // User defines user login info type User struct { UserName string // user\u0026#39;s name Password string // user\u0026#39;s password } // IUser defines user function type IUser interface { Login() // user login into the system Logout() // user logout the system } 函数和方法的注释 # 每个函数或方法都应有注释 需要包含函数或方法名称、函数或方法描述、函数或方法的创建作者及其创建时间、输入参数及其参数类型和解释、返回参数及其参数类型和解释 在函数或方法定义上面，书写下面的注释 // 函数或方法名称 // @Description 函数或方法描述 // @Create 作者 日期 时间 // @Param 输入参数名 参数类型 解释 // @Return 返回参数名 参数类型 解释 如果涉及到函数或方法的变更，需要写明修改作者、修改日期和时间、修改的功能描述 // @Modified 作者 日期 时间 // @Modify description 修改的功能描述 代码逻辑注释 # 每个代码块都需要添加注释 // This is my wife\u0026#39;s birthday if birthday == 1118 { ... } 配置 # 本配置均采用Goland IDE 包注释和文件注释配置 #Mac 使用 # Goland-\u0026gt;Settings-\u0026gt;Editor-\u0026gt;File and Code Templates-\u0026gt;Go File 复制下面的模版，替换原先的模版 // package ${GO_PACKAGE_NAME} // @Title ${FILE_NAME} // @Description // @Create XdpCs ${YEAR}-${MONTH}-${DAY} ${TIME} // @Update XdpCs ${YEAR}-${MONTH}-${DAY} ${TIME} 修改注释的快捷键配置 #Mac 使用 # Goland-\u0026gt;Settings-\u0026gt;Editor-\u0026gt;Live Templates 复制下面的模版，替换原先的模版 // @Modified XdpCs $date$ $time$:00 // @Modify description 点击Edit Variables\u0026hellip; 配置如下图所示 配置完成后，点击Define，勾选Go 使用只需要使用modify+回车即可 结构体注释、接口注释、函数注释、方法注释 #安装插件 # Goanno插件 同时也可以使用Goland的Marketplace搜索进行安装 配置插件注释格式，使用Tools-\u0026gt; Goanno Settings 函数注释、方法注释 # Normal Method 配置、Interface Method 配置 // ${function_name} // @Description ${todo} // @Create XdpCs ${date} // @Param ${param_name} ${param_type} // @Return ${ret_name_type} 结构体注释 # Struct 配置 // ${struct_name} 接口注释 # Interface 配置 // ${interface_name} 测试 # 使用control + command + /进行测试 示例 #示例\n","date":"13 March 2023","permalink":"/blogs/go/go_code_comment_standard/","section":"Blog","summary":"背景 # 当新接手他人的项目，我们很容易不知所措，不知道这个函数的作用是什么，即使有很好的命名规范，这种事情也会时常发生，甚至有时候几个月不碰这个项目，自己再看这个函数，也会有一种云里雾里的感觉 如果拥有好的注释，方便我们自己以后维护，也方便后来的同事接手你的项目，不至于对你的代码说这写的是啥，像一坨💩 注释规范 # 注释语言看团队，我们团队习惯使用英文，所以都使用英文，只要整个团队统一一个注释语言即可 全部使用单行注释,//后需要使用一个空格 包注释 # 包注释是对包的介绍 每个包都至少有一个包注释，在同一个包下，任一一个源文件中注释即可 放置在package之前，来简短描述这个包的功能 // 包的功能介绍 package 包名称 文件注释 # 每个文件都应有一个文件注释 放置在package之后，需要包含文件名称，文件描述，文件作者及其时间，更新作者及其时间 因为在公司正常开发流程中，可能合并分支的时候，只有自己部门的业务主管，有这个权限进行合并代码，如果去看git的日志，如果只看主分支，只会显示主管的id，很难很快落实到每个人上 package 包名称 // @Title 文件名称 // @Description 文件描述 // @Create 创建作者 日期 时间 // @Update 更新作者 日期 时间 结构体注释和接口注释 # 每个结构体或接口都应有注释 在结构体或接口定义上面，需要有一个对整个结构体或接口的简要介绍 结构体或接口内的每个成员变量也需要有注释 // User defines user login info type User struct { UserName string // user\u0026#39;s name Password string // user\u0026#39;s password } // IUser defines user function type IUser interface { Login() // user login into the system Logout() // user logout the system } 函数和方法的注释 # 每个函数或方法都应有注释 需要包含函数或方法名称、函数或方法描述、函数或方法的创建作者及其创建时间、输入参数及其参数类型和解释、返回参数及其参数类型和解释 在函数或方法定义上面，书写下面的注释 // 函数或方法名称 // @Description 函数或方法描述 // @Create 作者 日期 时间 // @Param 输入参数名 参数类型 解释 // @Return 返回参数名 参数类型 解释 如果涉及到函数或方法的变更，需要写明修改作者、修改日期和时间、修改的功能描述 // @Modified 作者 日期 时间 // @Modify description 修改的功能描述 代码逻辑注释 # 每个代码块都需要添加注释 // This is my wife\u0026#39;s birthday if birthday == 1118 { .","title":"Go语言注释规范"},{"content":" 公共模块代理: export GOPROXY=https://goproxy.io 同样可以设置为 https://goproxy.cn\n私有模块代理： export GOPRIVATE=git.xxx.com 初始化： go mod init [module 名称] 检测和清理依赖： go mod tidy 安装指定包： go get -v github.com/go-ego/gse@v0.60.0-rc4.2 go mod下，go get github.com/go-ego/gse@v0.60.0 可以跟语义化版本号，也可以跟git的分支go get github.com/go-ego/gse@master ,也可以跟git的提交哈希go get github.com/go-ego/gse@e3702bed2 go get遵循最小版本选择原则，只会下载不超过这个最大版本号，如果使用go get github.com/go-ego/gse@master ，下次在下载只会和第一次的一样，无论 master 分支是否更新了代码\n查看所有可以升级依赖版本： go list -u -m all 更新依赖： go get -u 更新指定包依赖： go get -u github.com/go-ego/gse 更新补丁版本号 go get -u=patch github.com/go-ego/gse 指定版本： go get -u github/com/go-ego/gse@v0.60.0-rc4.2 升降级版本号，使用比较运算符控制 go get github/com/go-ego/gse@`\u0026lt;v0.60.0` Replace:\n使用命令行： go mod edit -replace github.com/go-ego/gse = /path/to/local/gse go mod edit -replace github.com/go-ego/gse = github.com/vcaesar/gse 直接修改模块文件： replace github.com/go-ego/gse =\u0026gt; github.com/vcaesar/gse 移除依赖： go mod tidy go mod edit --droprequire=golang.org/x/crypto,仅仅修改go.mod配置文件的内容\n查看依赖包： go list -m all go list -m -json all # json 格式输出 模块配置格式化 go mod edit -fmt 常用命令： go mod init # 初始化 go mod tidy # 更新依赖文件,移除不需要的包 go mod download # 下载依赖文件 go mod vendor # 将依赖转移至本地的 vendor文件 go mod edit # 手动修改依赖文件 go mod graph # 打印依赖图 go mod verify # 校验依赖 在go mod模式，如果没有此依赖，在运行go run main.go会先去下载此依赖，当然不只是go run,go build、go test 命令也能自动下载相关依赖包\ngo mod不会在$GOPATH/src目录下保存相关引用包的源码，而包源码和链接库保存在$GOPATH/pkg/mod目录下\n","date":"21 January 2023","permalink":"/blogs/go/go_module/","section":"Blog","summary":"公共模块代理: export GOPROXY=https://goproxy.","title":"Go Module"},{"content":"","date":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"hugo"},{"content":"问题1 #found no layout file for \u0026#34;HTML\u0026#34; for kind \u0026#34;page\u0026#34;: You should create a template file which matches Hugo Layouts Lookup Rules for this combination. 解决方法 #hugo mod clean hugo server ","date":"29 November 2022","permalink":"/blogs/hugo/hugo_error/","section":"Blog","summary":"问题1 #found no layout file for \u0026#34;HTML\u0026#34; for kind \u0026#34;page\u0026#34;: You should create a template file which matches Hugo Layouts Lookup Rules for this combination.","title":"hugo 遇到的问题"},{"content":"","date":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"git"},{"content":"原理 # 本地仓库由git维护三棵\u0026quot;树\u0026quot; 第一个是工作目录,它拥有实际的文件 第二个是暂存区，它类似于缓存的存在，临时保存你的改动 第三个是HEAD,它指向最后一次提交的结果 概念 #分支 # 分支是用来将特性开发隔离开。在你创建仓库的时候，master或main是默认的分支。我们一般在其他分支上进行开发，完成后再将它们合并到主分支上 你在本地创建的分支，如果不推送到远端仓库，这个分支就只能在本地可见 命令 # 命令只介绍在开发过程中，常用的命令 创建新的git仓库 #git init 添加到暂存区 #git add \u0026lt;filename\u0026gt; git add . git add \u0026lt;filename\u0026gt; ,添加具体文件到暂存区 git add .,将所有变动添加到暂存区 这是git基本工作流程的第一步，将文件添加到暂存区 提交 #git commit -m \u0026#34;提交信息\u0026#34; 将改动提交到本地仓库的HEAD中 这是git基本工作流程的第二步，将文件提交到本地仓库的HEAD中 推送 #git push origin master 将改动提交到远端仓库，可以将master换成任何你想要推送的分支 这是git基本工作流程的第三步，推送到远端仓库 git remote add origin \u0026lt;server\u0026gt; 将你的仓库连接到远端仓库，若你本地仓库未和远端仓库建立关系 分支 #git checkout -b feature_xdp 创建一个叫做feature_xdp的分支 git checkout master 切换到主分支 更新与合并 #git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; 标准格式 以当前工作目录进行获取（fetch）并合并（merge）远端的改动 git pull git pull origin 将远端仓库的origin的master分支拉取到本地，并与本地的当前分支进行合并 git pull origin master:feature_xdp 将远端仓库的origin的master分支拉取过来，与本地的feature_xdp分支合并 git pull origin master 如果远端仓库的分支是与当前分支合并，则冒号后面的部分可以省略 git merge \u0026lt;branch\u0026gt; 合并其他分支到当前分支 冲突 # git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; 和 git merge \u0026lt;branch\u0026gt;,在两种情况下，git 会尝试自动合并改动，但是并不是每一次都会成功，可能会出现冲突。这个时候，需要你手动修改来合并这些冲突 git add \u0026lt;filename\u0026gt; 合并完成后，需要将它们添加到暂存区 git diff \u0026lt;source_branch\u0026gt; \u0026lt;target_branch\u0026gt; 可以使用该命令预览差异，在合并改动之前 log #git log 查看本地仓库历史记录 git log --author=XdpCs 只看XdpCs的提交记录 git log --pretty=oneline 每一条提交记录只占一行输出 git log --graph --oneline --decorate --all 通过树形结构来展示所有的分支，每个分支都标明它的名字和标签 git log --name-status 查看哪些文件发生改变 标签 # 通过创建标签，发布软件是一个不错的方法 git tag 1.0.0 1fd11181114 创建一个叫1.0.0的标签，1fd11181114是你想要标记的提交ID 提交ID可以通过上面的git log获取 只要提交ID具有指向唯一性，提交ID可以少几位 替换本地改动 #git checkout -- \u0026lt;filename\u0026gt; 使用HEAD中最新的内容替换掉你工作目录中的文件 已添加到暂存区的改动和新文件不会受到影响 git fetch origin git reset --hard origin/master 丢弃本地的所有改动和提交，从远端服务器获取最新的版本历史，并将本地分支指向它 克隆仓库 #git clone ../xdpcs.github.io 创建一个本地仓库的克隆版本 git clone git@github.com:XdpCs/Solidity-Learning.git 克隆一个远端服务器上的仓库 ","date":"18 November 2022","permalink":"/blogs/git/git_study/","section":"Blog","summary":"原理 # 本地仓库由git维护三棵\u0026quot;树\u0026quot; 第一个是工作目录,它拥有实际的文件 第二个是暂存区，它类似于缓存的存在，临时保存你的改动 第三个是HEAD,它指向最后一次提交的结果 概念 #分支 # 分支是用来将特性开发隔离开。在你创建仓库的时候，master或main是默认的分支。我们一般在其他分支上进行开发，完成后再将它们合并到主分支上 你在本地创建的分支，如果不推送到远端仓库，这个分支就只能在本地可见 命令 # 命令只介绍在开发过程中，常用的命令 创建新的git仓库 #git init 添加到暂存区 #git add \u0026lt;filename\u0026gt; git add .","title":"Git 学习"},{"content":"","date":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects"},{"content":"","date":null,"permalink":"/tags/web3/","section":"Tags","summary":"","title":"web3"},{"content":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库\n基础知识 # Solidity中自带时间单位，它们分别是 seconds minutes hours days weeks 基本换算关系如下： 1 == 1 seconds 1 minutes == 60 seconds 1 hours == 60 minutes 1 days == 24 hours 1 weeks == 7 days seconds为缺省时间单位 在Solidity 0.5.0之后，years已经被移除 例子 #例子\n该例子是判断当前时间是否大于合约部署后的一分钟\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.20; contract TimeUnits { uint public start; constructor(){ start = block.timestamp; } function judge() public view returns (bool) { if (block.timestamp \u0026gt;= start + 1 minutes) return true; return false; } } 程序解析 #function judge() public view returns (bool) { if (block.timestamp \u0026gt;= start + 1 minutes) return true; return false; } 这些时间单位是不能直接用在变量后面，想要使用，必须将输入变量换算为时间 ","date":"19 September 2022","permalink":"/blogs/solidity/008.time_units/","section":"Blog","summary":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库","title":"008-时间单位"},{"content":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库\n基础知识 # 以太币单位 单位 Wei Wei值 Wei 1 1 Wei Kwei (babbage) 1,000 1e3 Wei Mwei (lovelace) 1,000,000 1e6 Wei Gwei (shannon) 1,000,000,000 1e9 Wei Microether (szabo) 1,000,000,000,000 1e12 Wei Milliether (finney) 1,000,000,000,000,000 1e15 Wei Ether 1,000,000,000,000,000,000 1e18 Wei 交易需要支付ether 在Solidity中，单位之间的换算是在数字后边加上wei，gwei 或ether 来实现的 在Solidity中，后面没有单位，缺省为wei 从Solidity 0.7.0版本开始，finney 和 szabo 被移除了 gwei 在Solidity 0.6.11版本中添加，因此在0.6.11之前的版本中不可用 例子 #例子\n该例子是测试了以太币的单位换算\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.20; contract EtherUnits { uint public oneWei = 1 wei; bool public isOneWei = 1 wei == 1; uint public oneEther = 1 ether; bool public isOneEther = 1 ether == 1e18; uint public oneGwei = 1 gwei; bool public isOneGwei = 1 gwei == 1e9; } 程序解析 #uint public oneWei = 1 wei; bool public isOneWei = 1 wei == 1; 1 wei 等于 1，若没填写单位，默认是以wei为单位 uint public oneEther = 1 ether; bool public isOneEther = 1 ether == 1e18; 1 ether 等于 $10^{18}$ wei uint public oneGwei = 1 gwei; bool public isOneGwei = 1 gwei == 1e9; 1 gwei 等于 $10^9$ wei ","date":"18 September 2022","permalink":"/blogs/solidity/007.ether_units/","section":"Blog","summary":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库","title":"007-以太币单位"},{"content":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库\n基础知识 # 不可变变量类似于常量，但是少了一些约束 不可变变量的值可以在构造函数中初始化或在声明时初始化，但初始化后就不能被修改了,这样可以节省gas，提高合约的安全性 值类型变量可以声明为immutable 和constant不同，string和bytes不可以声明为immutable， 在Solidity 0.8.21之前，如果不对不可变变量，在构造函数或声明时初始化赋值，会报TypeError: Construction control flow ends without initializing all immutable state variables. 例子 #例子\n该例子是如何对不可变变量进行赋值\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.20; contract Immutable { address public immutable MY_ADDRESS; uint public immutable MY_UINT; uint public immutable MY_LOVE = 1118; uint public immutable NO_USAGE; constructor(uint _myUint){ MY_ADDRESS = msg.sender; MY_UINT = _myUint; } } 程序解析 #address public immutable MY_ADDRESS; uint public immutable MY_UINT; uint public immutable MY_LOVE = 1118; uint public immutable NO_USAGE; 大写不可变变量的名称是一种编码习惯 NO_USAGE 是用来展示不对不可变变量进行初始化，但是由于Solidity对每个变量都有默认值，所以部署后，访问这个值会返回0 constructor(uint _myUint){ MY_ADDRESS = msg.sender; MY_UINT = _myUint; } 不可变变量必须在构造函数的时候就赋值，构造函数只会在合约部署的时候调用一次 ","date":"16 September 2022","permalink":"/blogs/solidity/006.immutable/","section":"Blog","summary":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库","title":"006-不可变变量"},{"content":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库\n基础知识 # 常量是不可修改的变量 它们的值是硬编码的，使用常量可以节省gas成本,还可以提高合约安全性 常量必须在声明的时候，进行初始化，之后便不能再改变了，且必须在编译时就确定其值，否则会报错 常量允许使用内置函数keccak256、sha256、ripemd160、ecrecover、addmod 和 mulmod（尽管除了keccak256之外，它们确实调用外部合约） 值类型变量、string和bytes可以声明为constant 例子 #例子\n该例子是常量的使用方法的例子\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.20; contract Constants { address public constant MY_ADDRESS = 0x0000000000000000000000000000000000001118; uint public constant MY_UINT = 1118; string public constant MY_STRING = \u0026#34;0x1118\u0026#34;; bytes public constant MY_BYTES = \u0026#34;FYY\u0026#34;; bool public constant MY_BOOL = false; bytes32 public constant MY_KE256 = keccak256(abi.encodePacked(\u0026#34;100\u0026#34;)); } 程序解析 #address public constant MY_ADDRESS = 0x0000000000000000000000000000000000001118; uint public constant MY_UINT = 1118; string public constant MY_STRING = \u0026#34;0x1118\u0026#34;; bytes public constant MY_BYTES = \u0026#34;FYY\u0026#34;; bool public constant MY_BOOL = false; bytes32 public constant MY_KE256 = keccak256(abi.encodePacked(\u0026#34;100\u0026#34;)); 大写常量变量的名称是一种编码习惯 ","date":"15 September 2022","permalink":"/blogs/solidity/005.constants/","section":"Blog","summary":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库","title":"005-常量"},{"content":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库\n基础知识 # 在Solidity中有3种类型的变量 局部变量 状态变量 全局变量 局部变量 # 局部变量声明在函数内部 局部变量不存储在区块链上 状态变量 # 状态变量声明在函数外部 状态变量存储在区块链上 全局变量 # 全局变量不需要声明，可以直接使用 全局变量提供了关于区块链上的信息 全局变量列举 blockhash(uint blockNumber) returns (bytes32)：指定区块的哈希值\u0026ndash;仅可用于最新的256个区块且不包括当前区块，否则返回0。 block.basefee (uint)：当前区块的基础费用(EIP-3198and EIP-1559) block.chainid (uint)：当前链id block.coinbase (address payable)：挖出当前区块矿工的地址 block.difficulty (uint)：当前区块难度，在evm paris升级后，该值不再准确，使用block.prevrandao代替。(EIP-4399) block.prevrandao (uint)：信标链提供的随机数，在evm paris升级后，使用该值代替block.difficulty block.gaslimit (uint)：当前区块的gas限制 block.number (uint)：当前区块号 block.timestamp (uint)：当前区块的时间戳，自unix纪元以来的秒数 gasleft() returns (uint256)：剩余的gas msg.data (bytes)：完整的calldata msg.sender (address)：消息发送者 (当前调用者) msg.sig (bytes4)：calldata的前四个字节 (也就是函数标识符) msg.value (uint)：当前交易发送的wei的数量 tx.gasprice (uint)：交易的gas价格 tx.origin (address)：交易发起者(完全的调用链) 例子 #例子\n该例子是局部变量、状态变量和全局变量使用的例子\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.20; contract Variables { string public text = \u0026#34;hello,fyy\u0026#34;; uint public num = 1118; uint public gasLeft; address public origin; uint public timestamp; function doSomething() public { uint i = 1114; text = \u0026#34;hello,xdp\u0026#34;; gasLeft = gasleft(); origin = tx.origin; timestamp = block.timestamp; } function blockHash() view public returns (bytes32) { return blockhash(block.number - 1); } function getBaseFee() view public returns (uint) { return block.basefee; } function getChainID() view public returns (uint) { return block.chainid; } function getCoinBase() view public returns (address) { return block.coinbase; } function getDifficulty() view public returns (uint) { return block.difficulty; } function getPrevRandao() view public returns (uint) { return block.prevrandao; } function getGasLimit() view public returns (uint) { return block.gaslimit; } } 程序解析 #string public text = \u0026#34;hello,fyy\u0026#34;; uint public num = 1118; uint public gasLeft; address public origin; uint public timestamp; 状态变量存储在区块链上，会更加消耗gas uint i = 1114; 局部变量不存储在区块链上，仅在函数执行过程中变量才有效，相比状态变量更加节省gas text = \u0026#34;hello,xdp\u0026#34;; gasLeft = gasleft(); origin = tx.origin; timestamp = block.timestamp; 修改状态变量值 gasLeft = gasleft(); origin = tx.origin; timestamp = block.timestamp; function blockHash() view public returns (bytes32) { return blockhash(block.number - 1); } function getBaseFee() view public returns (uint) { return block.basefee; } function getChainID() view public returns (uint) { return block.chainid; } function getCoinBase() view public returns (address) { return block.coinbase; } function getDifficulty() view public returns (uint) { return block.difficulty; } function getPrevRandao() view public returns (uint) { return block.prevrandao; } function getGasLimit() view public returns (uint) { return block.gaslimit; } 全局变量的使用方法 ","date":"14 September 2022","permalink":"/blogs/solidity/004.variables/","section":"Blog","summary":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库","title":"004-变量"},{"content":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库\n基础知识 # 我将介绍四种在Solidity中可用的值类型 布尔类型(bool) 整数类型(uint、int) 地址类型(address) 定长字节数组类型(bytes) 枚举类型(enum) 布尔类型(bool) # 布尔型的取值只有两种：true和 false 布尔型的运算符包括： 比较运算符：\u0026gt;，\u0026gt;=，\u0026lt;，\u0026lt;=，==，!= 与运算 \u0026amp;\u0026amp; 或运算 || 非运算 ! \u0026amp;\u0026amp; 和 ||运算符遵循短路规则，a||b，如果a是true,b不会被计算;a\u0026amp;\u0026amp;b,如果a是false,b不会被计算 短路规则，会更加节省gas费用 整数类型(uint、int) #uint # uint代表无符号整数，也就是说没有负数的整数 有不同的字节数的无符号整数，可供使用 uint8 范围 从 0 到 $2^8-1$ uint16 范围 从 0 到 $2^{16}-1$ \u0026hellip; 以8位为递增 uint256 范围 从 0 到 $2^{256}-1$ int # int表示有符号整数，在int中允许有负数存在 int表示的范围与uint表示的范围不同 int8 范围 从 $-2^7$ 到 $2^7-1$ int16 范围 从 $-2^{15}$ 到 $2^{15}-1$ \u0026hellip; 以8位为递增 int256 范围 从 $-2^{255}$ 到 $2^{255}-1$ 整数类型(uint、int)的运算符 # 比较运算符： \u0026lt;=， \u0026lt;， ==， !=， \u0026gt;=， \u0026gt; 算数运算符： +，-，-（一元运算符），*，/，%（取余），**（幂） 地址类型(address) # address类型是一个20字节的值 地址类型有两种 普通地址（address）：可以调用call, delegatecall 和 staticcall成员方法 payable address: 比普通地址多了transfer和send两个成员方法用于转账，和一个成员变量balance用于查询余额 定长字节数组类型(bytes) # bytes表示一个字节序列 Solidity提供了两种字节类型： 固定大小的字节数组 固定大小的字节数组属于值类型 固定大小的字节数组存储数据会更节省gas费用 动态大小的字节数组 动态大小的字节数组不属于值类型，在后面会讲 bytes1, bytes2, bytes3, ..., bytes32 代表从1到32的字节序列 bytes类型的运算符： 比较运算符：\u0026lt;=， \u0026lt;， ==， !=， \u0026gt;=， \u0026gt; 位运算符： \u0026amp;， |， ^ （按位异或）， ~ （按位取反） 移位运算符： \u0026laquo; （左移位）， \u0026raquo; （右移位） 索引访问： 如果x是bytesI类型，那么当0 \u0026lt;= k \u0026lt; I时，x[k]返回第k个字节（只读） 移位运算符以无符号的整数类型作为右操作数（但返回左操作数的类型），它表示要移位的位数。有符号类型的移位将产生一个编译错误 成员变量： .length: 这个字节数组的长度（只读） 枚举类型(enum) # 枚举类型用于表示一组有限的值，它们对于建模选择和跟踪状态很有用 枚举类型的声明： enum 枚举名称 { 枚举值1, 枚举值2, \u0026hellip; } 枚举值的类型是uint8，从0开始递增，不能超过256个 枚举可以声明在合约外面并从其他合约中导入 枚举可以显式的和uint8进行相互转换，并且会检查所转换的无符号整数是否在枚举长度范围内 默认值 # 未赋值的变量有一个默认值 布尔类型(bool)为false 整数类型(uint、int)为0 地址类型(address)为0x0000000000000000000000000000000000000000 定长字节数组类型(bytes)为0，根据长度决定，比如bytes2为0x0000 枚举类型(enum)为0 例子 #例子\n该例子是值类型使用的例子\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.20; contract ValueType { bool public b = false; bool public b1 = 1118 \u0026gt; 1114; // true bool public b2 = 1118 \u0026gt;= 1114; // true bool public b3 = 1118 \u0026lt; 1114; // false bool public b4 = 1118 \u0026lt;= 1114; // false bool public b5 = 1118 == 1114; // false bool public b6 = 1118 != 1114; // true bool public b7 = !b; // true bool public b8 = b1 \u0026amp;\u0026amp; b2; // true bool public b9 = b3 \u0026amp;\u0026amp; b1; // false,发生短路运算 bool public b10 = b3 || b4; // false bool public b11 = b1 || b3; // true,发生短路运算 uint8 public u8 = 18; uint24 public u24 = 1118; uint public u256 = 1114; // uint是uint256的别称 int8 public i8 = - 18; int24 public i24 = 1118; int public i256 = - 1114; // int是int256的别称 int public minInt = type(int).min; int public maxInt = type(int).max; int public int_1 = - 1114; int public int_2 = 1118 + 1114; int public int_3 = 1118 - 1114; int public int_4 = 18 * 14; int public int_5 = 18 / 18; int public int_6 = 1118 % 1114; int public int_7 = 2 ** 10; address public addr; constructor ()payable{ } function getEth() public { addr = msg.sender; address payable _addr = payable(addr); _addr.transfer(1 ether); } bytes1 public a1 = 0xb5; // [10110101] bytes2 public a2 = 0xb556; // [1011010101010110] bytes1 public a3 = a1[0]; // [10110101] enum Status{ Pending, Shipped, Accepted, Rejected, Canceled } Status public status; Status public maxEnum = type(Status).max; Status public minEnum = type(Status).min; function get() public view returns (Status){ return status; } function set(Status _status) public { status = _status; } function cancel() public { status = Status.Canceled; } function reject() public { status = Status.Rejected; } function accept() public { status = Status.Accepted; } function ship() public { status = Status.Shipped; } function pending() public { status = Status.Pending; } function reset() public { delete status; delete a1; delete b1; delete u8; delete i8; delete addr; } bool public defaultBoo; // false uint public defaultUint; // 0 int public defaultInt; // 0 address public defaultAddr; // 0x0000000000000000000000000000000000000000 bytes2 public defaultBytes; // 0x0000 Status public defaultEnum; // 0 } 程序解析 #布尔类型(bool)使用的例子 #bool public b = false; bool public b1 = 1118 \u0026gt; 1114; // true bool public b2 = 1118 \u0026gt;= 1114; // true bool public b3 = 1118 \u0026lt; 1114; // false bool public b4 = 1118 \u0026lt;= 1114; // false bool public b5 = 1118 == 1114; // false bool public b6 = 1118 != 1114; // true bool public b7 = !b; // true bool public b8 = b1 \u0026amp;\u0026amp; b2; // true bool public b9 = b3 \u0026amp;\u0026amp; b1; // false,发生短路运算 bool public b10 = b3 || b4; // false bool public b11 = b1 || b3; // true,发生短路运算 布尔类型(bool)运算符的使用和赋值 整数类型(uint、int)使用的例子 #uint8 public u8 = 18; uint24 public u24 = 1118; uint public u256 = 1114; // uint是uint256的别称 int8 public i8 = - 18; int24 public i24 = 1118; int public i256 = - 1114; // int是int256的别称 整数类型(uint、int)的赋值 int public minInt = type(int).min; int public maxInt = type(int).max; int的最大值和最小值 int public int_1 = - 1114; int public int_2 = 1118 + 1114; int public int_3 = 1118 - 1114; int public int_4 = 18 * 14; int public int_5 = 18 / 18; int public int_6 = 1118 % 1114; int public int_7 = 2 ** 10; 运算符的例子，如果想看运算符的例子，可以看上面布尔类型的例子 地址类型(address)使用的例子 #address public addr; 声明了一个地址类型(address)叫addr constructor ()payable{ } constructor 表示构造函数，只会在合约部署的时候，调用一次 构造函数用payable修饰，保证部署合约的时候，能打入eth function getEth() public { addr = msg.sender; address payable _addr = payable(addr); _addr.transfer(1 ether); } 用户调用此函数，可以从合约中提取一个ether到自己的账户，所以部署合约的时候，一定打入一个ether以上，否则调用这个函数会失败 定长字节数组类型(bytes)使用的例子 #bytes1 public a1 = 0xb5; // [10110101] bytes2 public a2 = 0xb556; // [1011010101010110] bytes1 public a3 = a1[0]; // [10110101] 定长字节数组类型(bytes)的赋值 枚举类型(enum)使用的例子 #enum Status{ Pending, Shipped, Accepted, Rejected, Canceled } Status public status; Status public maxEnum = type(Status).max; Status public minEnum = type(Status).min; Status表示发货状态，并声明了status，默认值为\u0026quot;Pending\u0026quot; 通过type(Status).max 和 type(Status).min ，可以得到枚举类型(enum)的最大值和最小值 function get() public view returns (Status) { return status; } 返回值为Status类型 Pending为0 Shipped为1 Accepted为2 Rejected为3 Canceled为4 function set(Status _status) public { status = _status; } 通过输入uint类型数字更新status变量，若大于枚举(enum)范围，会交易失败 function cancel() public { status = Status.Canceled; } 更新status为Canceled function reject() public { status = Status.Rejected; } 更新status为Rejected function accept() public { status = Status.Accepted; } 更新status为Accepted function ship() public { status = Status.Shipped; } 更新status为Shipped function pending() public { status = Status.Pending; } 更新status为Pending 默认值使用的例子 #function reset() public { delete status; delete a1; delete b1; delete u8; delete i8; delete addr; } 使用delete关键字，可以将该变量，恢复成默认值 bool public defaultBoo; // false uint public defaultUint; // 0 int public defaultInt; // 0 address public defaultAddr; // 0x0000000000000000000000000000000000000000 bytes2 public defaultBytes; // 0x0000 Status public defaultEnum; // 0 声明变量未赋值，变量的值是默认值 ","date":"13 September 2022","permalink":"/blogs/solidity/003.value_type/","section":"Blog","summary":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库","title":"003-值类型"},{"content":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库\n基础知识 #这是一个简单的计数器合约，在合约中存储一个数，你可以增加和减少此数\n例子 #该例子是一个链上计数器合约\n例子\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.20; contract Counter { uint public count; function getCount() public view returns (uint) { return count; } function inc() public { count++; } function dec() public { count--; } } 程序解析 #uint public count; 存储在链上合约中的count变量,用public修饰可见性，在后面可以知道，public修饰的变量，会自动生成一个get函数 function getCount() public view returns (uint) { return count; } 该函数用于获取当前count的值，其实此函数是多此一举hhh function inc() public { count++; } 该函数用于增加count的值 function dec() public { count--; } 该函数用于减少count的值，但是在刚开始部署合约的时候，不能先调用此函数 因为在Solidity 8.0版本之后，如果溢出，会将交易回滚，显示交易失败 溢出的问题，会在 003-值类型中，讲解数值变量的范围 ","date":"12 September 2022","permalink":"/blogs/solidity/002.first_app/","section":"Blog","summary":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库","title":"002-第一个App"},{"content":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库\n基础知识 #任何一个程序教学，开头都会教你如何写Hello World，我也不例外\n例子 #该例子是在链上存储\u0026quot;Hello World!\u0026quot;的字符串\n例子\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.20; contract HelloWorld { string public greet = \u0026#34;Hello World!\u0026#34;; } 程序解析 #// SPDX-License-Identifier: MIT 如果不加此行，编译的时候，编译器会警告，但程序可以编译成功 如果你不想指定一个许可证，或者源代码不开源，请使用特殊值UNLICENSED 注意，UNLICENSED(不存在于SPDX许可证列表中)与UNLICENSE(授予所有人所有权利)不同 每个源文件都应该注释最上面一行，以说明版权许可证 版权注释在文件的任何位置都可以被编译器识别，但建议把它放在文件的顶部 编译器不会验证许可证是否属于SPDX版权许可列表,但它会在bytecode metadata中包含提供的字符串 pragma solidity ^0.8.20; pragma用于声明允许使用低于0.8.20版本并且不高于0.9.0的编译器版本编译,^表示高于 contract HelloWorld contract声明了一个合约名字，名字叫HelloWorld string public greet = \u0026#34;Hello World!\u0026#34;; 声明了一个string变量，并且可见性是public 在Solidity中所有的标识符（合约名称，函数名称和变量名称），都只能使用ASCII字符集 ","date":"11 September 2022","permalink":"/blogs/solidity/001.hello_world/","section":"Blog","summary":"背景 #通过学习Solidity，然后输出文章检验自己的学习成果github仓库","title":"001-你好，世界"},{"content":"Hi! My name is Alan Xu. #Enjoy any project that uses the Go programming language. #Currently, learning English, Go, Solidity, Mysql, and Redis. #","date":null,"permalink":"/","section":"Welcome to XdpCs’s blog!","summary":"Hi! My name is Alan Xu.","title":"Welcome to XdpCs’s blog!"},{"content":"","date":null,"permalink":"/tags/r-i-j%E5%9E%8B%E6%8C%87%E4%BB%A4/","section":"Tags","summary":"","title":"R-I-J型指令"},{"content":"","date":null,"permalink":"/tags/%E6%9D%AD%E7%94%B5%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%AE%9E%E9%AA%8C/","section":"Tags","summary":"","title":"杭电计算机组成实验"},{"content":"实验内容 # 掌握MIPS R型、I型和J型指令的综合数据通路设计，掌握各种转移类指令的控制流和指令流的多路选通控制方法 掌握J型、I型和R型转移指令的指令格式和寻址方式，学习转移地址的产生方法，掌握无条件转移指令和条件转移指令的实现方法 编程实现MIPS的部分J型、I型和R型转移指令的功能 解决方法 # 分析MIPS J型指令的特点，由6位OP字段和26位的address字段构成 分析转移指令的数据通路，转移地址的产生有三种方式，转移地址产生后，要送入PC，才能完成跳转 R型指令还添加了一条无条件跳转指令，要在原来的PC模块判断R型指令的地方进行修改，不能在I型指令下判断，这样会产生冲突 对于条件转移指令beq和bne要使用ALU做减法，判断是否全为零，也就是用ZF判断是否转移 J型指令可以接着I型指令的case结构写下来，与J型case结构无冲突 由于实验九和实验十想法十分接近，主要是控制信号的改变，及其译码模块的改变 涉及实验：具体用到的实验是 多功能ALU设计实验、 寄存器堆设计实验 、 取指令与指令译码实验 代码展示 顶层模块\nmodule CPU(clk,rst,OF,ZF,F,ALU_OP,M_R_Data,w_r_s,imm_s,rt_imm_s,Mem_Write,Write_Reg,PC,PC_s,clk_M,R_Data_B,Inst_code); input clk,rst,clk_M; output [31:0]Inst_code; wire [5:0]op_code,funct; wire [4:0]rs_addr,rt_addr,rd_addr,shamt; output [31:0]F; output OF,ZF; output [31:0]M_R_Data; output [2:0]ALU_OP; wire [31:0]Mem_Addr; wire [4:0]W_Addr; output imm_s,rt_imm_s,Mem_Write,Write_Reg; output [1:0]w_r_s; wire [31:0]imm_data; wire [31:0]R_Data_A; output [31:0]R_Data_B; wire [15:0]imm; wire [31:0]ALU_B; wire [31:0]W_Data; output [1:0]PC_s; wire [25:0]address; wire [1:0]wr_data_s; wire [31:0]PC_new; output [31:0]PC; PC pc1(clk,rst,Inst_code,PC_s,R_Data_A,address,PC,imm_data,PC_new); assign op_code = Inst_code[31:26]; assign rs_addr = Inst_code[25:21]; assign rt_addr = Inst_code[20:16]; assign rd_addr = Inst_code[15:11]; assign shamt = Inst_code[10:6]; assign funct = Inst_code[5:0]; assign imm = Inst_code[15:0]; assign address = Inst_code[25:0]; OP_Func op(op_code,funct,Write_Reg,ALU_OP,w_r_s,imm_s,rt_imm_s,Mem_Write,wr_data_s,PC_s,ZF); assign W_Addr = (w_r_s[1])?5\u0026#39;b11111:((w_r_s[0])?rt_addr:rd_addr); assign imm_data = (imm_s)?{{16{imm[15]}},imm}:{{16{1\u0026#39;b0}},imm}; Fourth_experiment_first F1(rs_addr,rt_addr,Write_Reg,R_Data_A,R_Data_B,rst,~clk,W_Addr,W_Data); assign ALU_B = (rt_imm_s)?imm_data:R_Data_B; Third_experiment_first T1(OF,ZF,ALU_OP,R_Data_A,ALU_B,F); RAM RAM_B ( .clka(clk_M), // input clka .wea(Mem_Write), // input [0 : 0] wea .addra(F[5:0]), // input [5 : 0] addra .dina(R_Data_B), // input [31 : 0] dina .douta(M_R_Data) // output [31 : 0] douta ); assign W_Data = (wr_data_s[1])?PC_new:((wr_data_s[0])? M_R_Data:F); endmodule PC（取指令模块）\nmodule PC(clk,rst,Inst_code,PC_s,R_Data_A,address,PC,imm_data,PC_new); input clk,rst; input [1:0]PC_s; input [31:0]R_Data_A; input [25:0]address; input [31:0]imm_data; output reg[31:0]PC; output [31:0]PC_new; initial PC = 32\u0026#39;h0000_0000; output [31:0]Inst_code; assign PC_new = PC +4; Inst_Rom rom( .clka(clk), // input clka .addra(PC[7:2]), // input [5 : 0] addra .douta(Inst_code) // output [31 : 0] douta ); always@(negedge clk or posedge rst) begin if(rst) begin PC \u0026lt;= 32\u0026#39;h0000_0000; end else begin case (PC_s) 2\u0026#39;b00:\tPC \u0026lt;= PC_new; 2\u0026#39;b01:\tPC \u0026lt;= R_Data_A;\t2\u0026#39;b10: PC \u0026lt;= PC_new + (imm_data\u0026lt;\u0026lt;2);\t2\u0026#39;b11:\tPC \u0026lt;= {PC_new[31:28],address,2\u0026#39;b00}; endcase end end endmodule OP_Func（译码模块）\nmodule OP_Func(op_code,funct,Write_Reg,ALU_OP,w_r_s,imm_s,rt_imm_s,Mem_Write,wr_data_s,PC_s,ZF); input [5:0]op_code; input [5:0]funct; input ZF; output reg[2:0]ALU_OP; output reg Write_Reg; output reg [1:0]wr_data_s; output reg imm_s; output reg rt_imm_s; output reg Mem_Write; output reg [1:0]w_r_s; output reg [1:0]PC_s; always@(*) begin\tWrite_Reg=1; ALU_OP=3\u0026#39;b100; wr_data_s=0; imm_s=0; rt_imm_s=0; Mem_Write=0; w_r_s=0; PC_s = 0; if(op_code==6\u0026#39;b000000) begin case(funct) 6\u0026#39;b100000:begin ALU_OP=3\u0026#39;b100; end 6\u0026#39;b100010:begin ALU_OP=3\u0026#39;b101; end 6\u0026#39;b100100:begin ALU_OP=3\u0026#39;b000;end 6\u0026#39;b100101:begin ALU_OP=3\u0026#39;b001;end 6\u0026#39;b100110:begin ALU_OP=3\u0026#39;b010;end 6\u0026#39;b100111:begin ALU_OP=3\u0026#39;b011;end 6\u0026#39;b101011:begin ALU_OP=3\u0026#39;b110;end 6\u0026#39;b000100:begin ALU_OP=3\u0026#39;b111;end 6\u0026#39;b001000:begin Write_Reg=0;Mem_Write=0;PC_s = 2\u0026#39;b01; end endcase end else begin case(op_code) 6\u0026#39;b001000:begin w_r_s=2\u0026#39;b01;imm_s=1;rt_imm_s=1;ALU_OP=3\u0026#39;b100;end 6\u0026#39;b001100:begin w_r_s=2\u0026#39;b01;rt_imm_s=1;ALU_OP=3\u0026#39;b000; end 6\u0026#39;b001110:begin w_r_s=2\u0026#39;b01;rt_imm_s=1;ALU_OP=3\u0026#39;b010;end 6\u0026#39;b001011:begin w_r_s=2\u0026#39;b01;rt_imm_s=1;ALU_OP=3\u0026#39;b110; end 6\u0026#39;b100011:begin w_r_s=2\u0026#39;b01;imm_s=1;rt_imm_s=1;wr_data_s=2\u0026#39;b01;ALU_OP=3\u0026#39;b100; end 6\u0026#39;b101011:begin imm_s=1;rt_imm_s=1;ALU_OP=3\u0026#39;b100;Write_Reg=0;Mem_Write=1; end 6\u0026#39;b000100:begin ALU_OP=3\u0026#39;b101;PC_s = (ZF)?2\u0026#39;b10:2\u0026#39;b00; Write_Reg = 1\u0026#39;b0;end 6\u0026#39;b000101:begin ALU_OP=3\u0026#39;b101;PC_s = (ZF)?2\u0026#39;b00:2\u0026#39;b10; Write_Reg = 1\u0026#39;b0;end 6\u0026#39;b000010:begin Write_Reg=0;PC_s = 2\u0026#39;b11; end 6\u0026#39;b000011:begin w_r_s=2\u0026#39;b10;wr_data_s=2\u0026#39;b10;PC_s = 2\u0026#39;b11; end endcase end end endmodule Fourth_experiment_first（寄存器堆模块）\nmodule Fourth_experiment_first(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,W_Addr,W_Data); input [4:0]R_Addr_A,R_Addr_B,W_Addr; input Write_Reg,Reset,Clk; input[31:0] W_Data; output [31:0] R_Data_A,R_Data_B; reg [31:0] REG_Files[0:31]; integer i=0; initial for(i=0;i\u0026lt;32;i=i+1) REG_Files[i]\u0026lt;=0; always @ (posedge Clk or posedge Reset) begin if(Reset) begin for(i=0;i\u0026lt;=31;i=i+1) REG_Files[i]\u0026lt;=0; end else begin if(Write_Reg) REG_Files[W_Addr]\u0026lt;=W_Data; end end assign R_Data_A = REG_Files[R_Addr_A]; assign R_Data_B = REG_Files[R_Addr_B]; endmodule Third_experiment_first（ALU模块）\nmodule Third_experiment_first(OF,ZF,ALU_OP,A,B,F); input [2:0]ALU_OP; input [31:0]A,B; output reg[31:0]F; reg C32; output reg OF; output reg ZF; always @(ALU_OP or A or B) begin OF = 0; C32 = 0; case(ALU_OP) 3\u0026#39;b000:F\u0026lt;=A\u0026amp;B; 3\u0026#39;b001:F\u0026lt;=A|B; 3\u0026#39;b010:F\u0026lt;=A^B; 3\u0026#39;b011:F\u0026lt;=A~^B; 3\u0026#39;b100:{C32,F}\u0026lt;=A+B; 3\u0026#39;b101:{C32,F}\u0026lt;=A-B; 3\u0026#39;b110:begin if(A\u0026lt;B) F\u0026lt;=32\u0026#39;h0000_0001;else F\u0026lt;=32\u0026#39;h0000_0000;end 3\u0026#39;b111:begin F\u0026lt;=B\u0026lt;\u0026lt;A;end endcase if(F==32\u0026#39;h0000_0000)\tZF\u0026lt;=1; else ZF\u0026lt;=0; if(ALU_OP == 3\u0026#39;b100 || ALU_OP == 3\u0026#39;b101) OF\u0026lt;=C32^F[31]^A[31]^B[31];\telse OF \u0026lt;=0; end endmodule 数据.coe\nmemory_initialization_radix=16; memory_initialization_vector=88888888,99999999,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999, aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff, 20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb, 00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,12345678,23456789,3456789a,6789abcd; 程序机器码.coe\nmemory_initialization_radix=16; memory_initialization_vector=00002020,20050014,2006000b,0c000004,00804020,00a04820,00c05020,8d0b0000,ad2b0000,21080001,21290001,214affff,1540fffa,03e00008; 测试模块\nmodule test; // Inputs reg clk; reg rst; reg clk_M; // Outputs wire OF; wire ZF; wire [31:0] F; wire [2:0] ALU_OP; wire [31:0] M_R_Data; wire [1:0] w_r_s; wire imm_s; wire rt_imm_s; wire Mem_Write; wire Write_Reg; wire [31:0] PC; wire [1:0] PC_s; wire [31:0] R_Data_B; wire [31:0] Inst_code; CPU uut ( .clk(clk), .rst(rst), .OF(OF), .ZF(ZF), .F(F), .ALU_OP(ALU_OP), .M_R_Data(M_R_Data), .w_r_s(w_r_s), .imm_s(imm_s), .rt_imm_s(rt_imm_s), .Mem_Write(Mem_Write), .Write_Reg(Write_Reg), .PC(PC), .PC_s(PC_s), .clk_M(clk_M), .R_Data_B(R_Data_B), .Inst_code(Inst_code) ); always #4 clk_M = ~clk_M; always #16 clk =~clk; initial begin clk = 0; rst = 1; clk_M = 0; #2; rst = 0; end endmodule 汇编程序\nmain: add $a0,$zero,$zero addi $a1,$zero,20; addi $a2,$zero,10; jal BankMove BankMove: add $t0,$a0,$zero; add $t1,$a1,$zero; add $t2,$a2,$zero; Loop1:lw $t3,0($t0); sw $t3,0($t1); addi $t0,$t0,1; addi $t1,$t1,1; addi $t2,$t2,-1; bne $t2,$zero,Loop1; jr $ra 友情提示 #书上的机器码存在错误，读者可以自行对比，纠正机器码，博主用的汇编程序是将存储器1-10位搬到20-30位\n代码地址 #代码地址\n","date":"26 December 2020","permalink":"/blogs/hdu_computer_organization_and_architecture_experiment/tenth_experiment/","section":"Blog","summary":"实验内容 # 掌握MIPS R型、I型和J型指令的综合数据通路设计，掌握各种转移类指令的控制流和指令流的多路选通控制方法 掌握J型、I型和R型转移指令的指令格式和寻址方式，学习转移地址的产生方法，掌握无条件转移指令和条件转移指令的实现方法 编程实现MIPS的部分J型、I型和R型转移指令的功能 解决方法 # 分析MIPS J型指令的特点，由6位OP字段和26位的address字段构成 分析转移指令的数据通路，转移地址的产生有三种方式，转移地址产生后，要送入PC，才能完成跳转 R型指令还添加了一条无条件跳转指令，要在原来的PC模块判断R型指令的地方进行修改，不能在I型指令下判断，这样会产生冲突 对于条件转移指令beq和bne要使用ALU做减法，判断是否全为零，也就是用ZF判断是否转移 J型指令可以接着I型指令的case结构写下来，与J型case结构无冲突 由于实验九和实验十想法十分接近，主要是控制信号的改变，及其译码模块的改变 涉及实验：具体用到的实验是 多功能ALU设计实验、 寄存器堆设计实验 、 取指令与指令译码实验 代码展示 顶层模块","title":"杭电计算机组成实验 实验10-实现R-I-J型指令的CPU设计实验"},{"content":"","date":null,"permalink":"/tags/architecture/","section":"Tags","summary":"","title":"architecture"},{"content":"","date":null,"permalink":"/tags/fpga/","section":"Tags","summary":"","title":"fpga"},{"content":"","date":null,"permalink":"/tags/r-i%E5%9E%8B%E6%8C%87%E4%BB%A4/","section":"Tags","summary":"","title":"R-I型指令"},{"content":"实验内容 # 掌握MIPS R型和I型指令的综合数据通路设计，掌握数据流的多路选通控制方法 掌握取数指令lw和存数指令sw的寻址方式及其有效地址产生的方法 实现MIPS的部分I型和 R型指令的功能 解决方法 # 分析MIPS I型指令的特点，与R型指令有明显的不同：没有rd寄存器，使用rt作为目的寄存器；源操作数中有一个为立即数，位于指令的低16位 在寄存器堆模块的写地址输入端口设置二选一选择器，由于R型和I型的目的寄存器不同，由rd_rt_s控制 16位的立即数imm需要经过扩展才能与rs执行运算操作，对于有符号数的操作，执行的是符号扩展，对于无符号数的操作，执行的是0扩展 R型指令执行rs和rt运算，结果送rd；而I型立即数即数寻址指令则执行rs和扩展后的立即数imm运算，结果送rt。因此ALU的输入数据B端有两个选择：rt或者imm，仍可以通过二选一数据选择器，用rt_imm_s控制信号 需要添加一个数据存储器RAM存放指令访问的数据，读出的数据，意味着要在寄存器堆的写端口加个选择器，用alu_mem_s控制信号，其中要注意一点就是数据存储器的clk至少是CPU频率的2倍以上，我使用了两个clk输入解决这个问题 在实际写代码时，要注意顶层模块中，实例下层模块的顺序，由于译码模块变量多，我将其抽离出来，为了使顶层模块看起来简洁 涉及实验： 具体用到的实验是 多功能ALU设计实验、 寄存器堆设计实验 、 取指令与指令译码实验 代码展示 顶层模块\nmodule CPU(clk,rst,OF,ZF,F,ALU_OP,M_R_Data,rd_rt_s,imm_s,rt_imm_s,Mem_Write,alu_mem_s,Write_Reg,clk_M,R_Data_B,Inst_code); input clk,rst,clk_M; wire [31:0]Inst_code; wire [5:0]op_code,funct; wire [4:0]rs_addr,rt_addr,rd_addr,shamt; output [31:0]F; output OF,ZF; output [31:0]M_R_Data; output [2:0]ALU_OP; wire [31:0]Mem_Addr; wire [4:0]W_Addr; output rd_rt_s,imm_s,rt_imm_s,Mem_Write,alu_mem_s,Write_Reg; output [31:0]Inst_code; wire [31:0]imm_data; wire [31:0]R_Data_A; output [31:0] R_Data_B; wire [15:0]imm; wire [31:0]ALU_B; wire [31:0]W_Data; PC pc1(clk,rst,Inst_code); assign op_code = Inst_code[31:26]; assign rs_addr = Inst_code[25:21]; assign rt_addr = Inst_code[20:16]; assign rd_addr = Inst_code[15:11]; assign shamt = Inst_code[10:6]; assign funct = Inst_code[5:0]; assign imm = Inst_code[15:0]; OP_Func op(op_code,funct,Write_Reg,ALU_OP,rd_rt_s,imm_s,rt_imm_s,Mem_Write,alu_mem_s); assign W_Addr = (rd_rt_s)?rt_addr:rd_addr; assign imm_data = (imm_s)?{{16{imm[15]}},imm}:{{16{1\u0026#39;b0}},imm}; assign W_Data = alu_mem_s?M_R_Data:F; Fourth_experiment_first F1(rs_addr,rt_addr,Write_Reg,R_Data_A,R_Data_B,rst,clk,W_Addr,W_Data); assign ALU_B = (rt_imm_s)?imm_data:R_Data_B;\tThird_experiment_first T1(OF,ZF,ALU_OP,R_Data_A,ALU_B,F); RAM RAM_B ( .clka(clk_M), // input clka .wea(Mem_Write), // input [0 : 0] wea .addra(F[5:0]), // input [5 : 0] addra .dina(R_Data_B), // input [31 : 0] dina .douta(M_R_Data) // output [31 : 0] douta ); endmodule PC(取指令模块)\nmodule PC(clk,rst,Inst_code); input clk,rst; wire [31:0]PC_new; reg[31:0]PC; initial PC = 32\u0026#39;h0000_0000; output [31:0]Inst_code; assign PC_new = PC +4; Inst_Rom rom( .clka(clk), // input clka .addra(PC[7:2]), // input [5 : 0] addra .douta(Inst_code) // output [31 : 0] douta ); always@(negedge clk or posedge rst) begin if(rst) begin PC \u0026lt;= 32\u0026#39;h0000_0000; end else begin PC \u0026lt;= PC_new; end end endmodule OP_Func(译码模块)\nmodule OP_Func(op_code,funct,Write_Reg,ALU_OP,rd_rt_s,imm_s,rt_imm_s,Mem_Write,alu_mem_s); input [5:0]op_code; input [5:0]funct; output reg[2:0]ALU_OP; output reg Write_Reg; output reg rd_rt_s; output reg imm_s; output reg rt_imm_s; output reg Mem_Write; output reg alu_mem_s; always@(*) begin\tWrite_Reg=1; ALU_OP=0; rd_rt_s=0; imm_s=0; rt_imm_s=0; Mem_Write=0; alu_mem_s=0; if(op_code==0) begin case(funct) 6\u0026#39;b100000:begin ALU_OP=3\u0026#39;b100; end 6\u0026#39;b100010:begin ALU_OP=3\u0026#39;b101; end 6\u0026#39;b100100:begin ALU_OP=3\u0026#39;b000;end 6\u0026#39;b100101:begin ALU_OP=3\u0026#39;b001;end 6\u0026#39;b100110:begin ALU_OP=3\u0026#39;b010;end 6\u0026#39;b100111:begin ALU_OP=3\u0026#39;b011;end 6\u0026#39;b101011:begin ALU_OP=3\u0026#39;b110;end 6\u0026#39;b000100:begin ALU_OP=3\u0026#39;b111;end endcase end else begin case(op_code) 6\u0026#39;b001000:begin rd_rt_s=1;imm_s=1;rt_imm_s=1;ALU_OP=100;end 6\u0026#39;b001100:begin rd_rt_s=1;rt_imm_s=1;ALU_OP=000; end 6\u0026#39;b001110:begin rd_rt_s=1;rt_imm_s=1;ALU_OP=010;end 6\u0026#39;b001011:begin rd_rt_s=1;rt_imm_s=1;ALU_OP=110; end 6\u0026#39;b100011:begin rd_rt_s=1;imm_s=1;rt_imm_s=1;alu_mem_s=1;ALU_OP=100; end 6\u0026#39;b101011:begin imm_s=1;rt_imm_s=1;ALU_OP=100;Write_Reg=0;Mem_Write=1; end endcase end end endmodule Fourth_experiment_first（寄存器堆模块）\nmodule Fourth_experiment_first(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,W_Addr,W_Data); input [4:0]R_Addr_A,R_Addr_B,W_Addr; input Write_Reg,Reset,Clk; input[31:0] W_Data; output [31:0] R_Data_A,R_Data_B; reg [31:0] REG_Files[0:31]; integer i=0; initial for(i=0;i\u0026lt;32;i=i+1) REG_Files[i]\u0026lt;=0; always @ (posedge Clk or posedge Reset) begin if(Reset) begin for(i=0;i\u0026lt;=31;i=i+1) REG_Files[i]\u0026lt;=0; end else begin if(Write_Reg) REG_Files[W_Addr]\u0026lt;=W_Data; end end assign R_Data_A = REG_Files[R_Addr_A]; assign R_Data_B = REG_Files[R_Addr_B]; endmodule Third_experiment_first（ALU模块）\nmodule Third_experiment_first(OF,ZF,ALU_OP,A,B,F); input [2:0]ALU_OP; input [31:0]A,B; output reg[31:0]F; reg C32; output reg OF; output reg ZF; always @(ALU_OP or A or B) begin OF = 0; C32 = 0; case(ALU_OP) 3\u0026#39;b000:F\u0026lt;=A\u0026amp;B; 3\u0026#39;b001:F\u0026lt;=A|B; 3\u0026#39;b010:F\u0026lt;=A^B; 3\u0026#39;b011:F\u0026lt;=A~^B; 3\u0026#39;b100:{C32,F}\u0026lt;=A+B; 3\u0026#39;b101:{C32,F}\u0026lt;=A-B; 3\u0026#39;b110:begin if(A\u0026lt;B) F\u0026lt;=32\u0026#39;h0000_0001;else F\u0026lt;=32\u0026#39;h0000_0000;end 3\u0026#39;b111:begin F\u0026lt;=B\u0026lt;\u0026lt;A;end endcase if(F==32\u0026#39;h0000_0000)\tZF\u0026lt;=1; else ZF\u0026lt;=0; if(ALU_OP == 3\u0026#39;b100 || ALU_OP == 3\u0026#39;b101) OF\u0026lt;=C32^F[31]^A[31]^B[31];\telse OF \u0026lt;=0; end endmodule MIPS32.coe\nmemory_initialization_radix=16; memory_initialization_vector=38011234,20026789,20039000,38040010,00822804,00253025,00833804,00464020,00414822,00225022,206b7fff,206c8000,314dffff,2c4e6788,2c4f678a,ac8b0000,ac0c0014,ac8d0010,ac8e0014,8c100010,8c910004,02119025,8c930010,8c940014,0274a827,8c96fff0,8c97fff4,02d7c02b; 数据coe\nmemory_initialization_radix=16; memory_initialization_vector=88888888,99999999,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999, aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff, 20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb, 00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,12345678,23456789,3456789a,6789abcd; 测试模块\nmodule test; reg clk; reg rst; reg clk_M; wire OF; wire ZF; wire [31:0] F; wire [2:0] ALU_OP; wire [31:0] M_R_Data; wire rd_rt_s; wire imm_s; wire rt_imm_s; wire Mem_Write; wire alu_mem_s; wire Write_Reg; wire [31:0] R_Data_B; wire [31:0] Inst_code; CPU uut ( .clk(clk), .rst(rst), .OF(OF), .ZF(ZF), .F(F), .ALU_OP(ALU_OP), .M_R_Data(M_R_Data), .rd_rt_s(rd_rt_s), .imm_s(imm_s), .rt_imm_s(rt_imm_s), .Mem_Write(Mem_Write), .alu_mem_s(alu_mem_s), .Write_Reg(Write_Reg), .clk_M(clk_M), .R_Data_B(R_Data_B), .Inst_code(Inst_code) ); always #9 clk_M = ~clk_M; always #20 clk =~clk; initial begin clk = 0; rst = 1; clk_M = 0; #2; rst = 0; end endmodule 友情提示 #1.有的同学会把在顶层模块存数据存储器的地址和PC的地址弄混，大家会问为什么PC的存储器是取[7:2],而顶层模块存数据存储器的地址[5:0] ,主要原因就在PC=PC+4这个语句上，我们的存储器还是按照字节去寻址的，如果我们不取[7:2]的地址就会导致中间几条指令跳过，而顶层数据模块就是逐一增加的\n2.数据存储器的clk至少是CPU频率的2倍以上\n3.开始的时候，rst一定要拉高哦\n代码地址 #代码地址\n","date":"25 December 2020","permalink":"/blogs/hdu_computer_organization_and_architecture_experiment/ninth_experiment/","section":"Blog","summary":"实验内容 # 掌握MIPS R型和I型指令的综合数据通路设计，掌握数据流的多路选通控制方法 掌握取数指令lw和存数指令sw的寻址方式及其有效地址产生的方法 实现MIPS的部分I型和 R型指令的功能 解决方法 # 分析MIPS I型指令的特点，与R型指令有明显的不同：没有rd寄存器，使用rt作为目的寄存器；源操作数中有一个为立即数，位于指令的低16位 在寄存器堆模块的写地址输入端口设置二选一选择器，由于R型和I型的目的寄存器不同，由rd_rt_s控制 16位的立即数imm需要经过扩展才能与rs执行运算操作，对于有符号数的操作，执行的是符号扩展，对于无符号数的操作，执行的是0扩展 R型指令执行rs和rt运算，结果送rd；而I型立即数即数寻址指令则执行rs和扩展后的立即数imm运算，结果送rt。因此ALU的输入数据B端有两个选择：rt或者imm，仍可以通过二选一数据选择器，用rt_imm_s控制信号 需要添加一个数据存储器RAM存放指令访问的数据，读出的数据，意味着要在寄存器堆的写端口加个选择器，用alu_mem_s控制信号，其中要注意一点就是数据存储器的clk至少是CPU频率的2倍以上，我使用了两个clk输入解决这个问题 在实际写代码时，要注意顶层模块中，实例下层模块的顺序，由于译码模块变量多，我将其抽离出来，为了使顶层模块看起来简洁 涉及实验： 具体用到的实验是 多功能ALU设计实验、 寄存器堆设计实验 、 取指令与指令译码实验 代码展示 顶层模块","title":"杭电计算机组成实验 实验9-实现R-I型指令的CPU设计实验"},{"content":"","date":null,"permalink":"/tags/r%E5%9E%8B%E6%8C%87%E4%BB%A4/","section":"Tags","summary":"","title":"R型指令"},{"content":"实验内容 # 掌握MIPS R型指令的数据通路设计，掌握指令流和数据流的控制方法 掌握完整的单周期CPU顶层模块的设计方法 实现MIPS R型指令的功能 解决方法 # 分析MIPS R型指令的特点，OP均为000000b，可作为判断R型指令的依据 两个源操作数分别在rs和rt字段所指定的寄存器中，而目的操作数则是在rd字段所指定的寄存器 3.分析数据通路是从指令存储器取出的指令经过初级译码，将分解出的源寄存器rs、rt直接与寄存器堆的两个读端口A和B的寄存器地址连接，而将目的寄存器rd字段与寄存器堆的写端口地址相连，寄存器读出的A口数据和B口数据则直接连接到ALU的输入端A和B，ALU计算后的结果则送入寄存器堆的写数据端口 分析时序，首先是取指令，然后进行指令译码，最后将运算结果送到目的寄存器，PC自增，指向下一条指令 实验八中除译码模块，其他模块都已经前几个实验中完成，只需要将其连接，然后在译码模块中通过OP判断是否为R型，且将funct翻译成ALU的控制信号ALU_OP以及指定ALU的运算功能，由于此译码模块较为简单，我就在顶层模块实现了 具体用到的实验是 多功能ALU设计实验、 寄存器堆设计实验、 取指令与指令译码实验 代码实现: 顶层模块\nmodule CPU(clk,rst,op_code,funct,rs_addr,rt_addr,rd_addr,shamt,OF,ZF,F,ALU_OP,Inst_code); input clk,rst; output [31:0]Inst_code; output [5:0]op_code,funct; output [4:0]rs_addr,rt_addr,rd_addr,shamt; output [31:0]F; output OF,ZF; output reg [2:0]ALU_OP; reg Write_Reg; wire [31:0]R_Data_A,R_Data_B; PC pc1(clk,rst,Inst_code); assign op_code = Inst_code[31:26]; assign rs_addr = Inst_code[25:21]; assign rt_addr = Inst_code[20:16]; assign rd_addr = Inst_code[15:11]; assign shamt = Inst_code[10:6]; assign funct = Inst_code[5:0]; Fourth_experiment_first F1(rs_addr,rt_addr,Write_Reg,R_Data_A,R_Data_B,rst,~clk,rd_addr,F); Third_experiment_first T1(OF,ZF,ALU_OP,R_Data_A,R_Data_B,F); always@(*) begin\tWrite_Reg\u0026lt;=0; ALU_OP=0; if(op_code==0) Write_Reg\u0026lt;=1; begin case(funct) 6\u0026#39;b100000:ALU_OP=3\u0026#39;b100; 6\u0026#39;b100010:ALU_OP=3\u0026#39;b101; 6\u0026#39;b100100:ALU_OP=3\u0026#39;b000; 6\u0026#39;b100101:ALU_OP=3\u0026#39;b001; 6\u0026#39;b100110:ALU_OP=3\u0026#39;b010; 6\u0026#39;b100111:ALU_OP=3\u0026#39;b011; 6\u0026#39;b101011:ALU_OP=3\u0026#39;b110; 6\u0026#39;b000100:ALU_OP=3\u0026#39;b111; endcase end end endmodule PC（取指令模块）\nmodule PC(clk,rst,Inst_code); input clk,rst; wire [31:0]PC_new; reg[31:0]PC; initial PC = 32\u0026#39;h0000_0000; output [31:0]Inst_code; assign PC_new = PC +4; Inst_Rom your_instance_name( .clka(clk), // input clka .addra(PC[7:2]), // input [5 : 0] addra .douta(Inst_code) // output [31 : 0] douta ); always@(negedge clk or posedge rst) begin if(rst) begin PC \u0026lt;= 32\u0026#39;h0000_0000; end else begin PC \u0026lt;= PC_new; end end endmodule Fourth_experiment_first模块（寄存器堆模块）\nmodule Fourth_experiment_first(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,W_Addr,W_Data); input [4:0]R_Addr_A,R_Addr_B,W_Addr; input Write_Reg,Reset,Clk; input[31:0] W_Data; output [31:0] R_Data_A,R_Data_B; reg [31:0] REG_Files[0:31]; integer i=0; initial for(i=0;i\u0026lt;32;i=i+1) REG_Files[i]\u0026lt;=0; always @ (posedge Clk or posedge Reset) begin if(Reset) begin for(i=0;i\u0026lt;=31;i=i+1) REG_Files[i]\u0026lt;=0; end else begin if(Write_Reg) REG_Files[W_Addr]\u0026lt;=W_Data; end end assign R_Data_A = REG_Files[R_Addr_A]; assign R_Data_B = REG_Files[R_Addr_B]; endmodule Third_experiment_first（ALU模块）\nmodule Third_experiment_first(OF,ZF,ALU_OP,A,B,F); input [2:0]ALU_OP; input [31:0]A,B; output reg[31:0]F; reg C32; output reg OF; output reg ZF; always @(ALU_OP or A or B) begin OF = 0; C32 = 0; case(ALU_OP) 3\u0026#39;b000:F\u0026lt;=A\u0026amp;B; 3\u0026#39;b001:F\u0026lt;=A|B; 3\u0026#39;b010:F\u0026lt;=A^B; 3\u0026#39;b011:F\u0026lt;=A~^B; 3\u0026#39;b100:{C32,F}\u0026lt;=A+B; 3\u0026#39;b101:{C32,F}\u0026lt;=A-B; 3\u0026#39;b110:begin if(A\u0026lt;B) F\u0026lt;=32\u0026#39;h0000_0001;else F\u0026lt;=32\u0026#39;h0000_0000;end 3\u0026#39;b111:begin F\u0026lt;=B\u0026lt;\u0026lt;A;end endcase if(F==32\u0026#39;h0000_0000)\tZF\u0026lt;=1; else ZF\u0026lt;=0; if(ALU_OP == 3\u0026#39;b100 || ALU_OP == 3\u0026#39;b101) OF\u0026lt;=C32^F[31]^A[31]^B[31];\telse OF \u0026lt;=0; end endmodule MIPS32.coe\nmemory_initialization_radix=16; memory_initialization_vector=00000827 0001102b 00421820 00622020 00832820 00a33020 00463804 00a64820 01264004 00284826 01215020 01075822 00e86022 012c6824 012c7025 00c77825 00c78027 00e38820 02289004 02239804 00f3a004 0281a820 0255b025 0296b820 0296c022 02d4c822 0241d026 02d4d82b 0354e02b 02c2e820 0282f022 017af820; 测试模块\nmodule test; // Inputs reg clk; reg rst; // Outputs wire [5:0] op_code; wire [5:0] funct; wire [4:0] rs_addr; wire [4:0] rt_addr; wire [4:0] rd_addr; wire [4:0] shamt; wire OF; wire ZF; wire [31:0] F; wire [2:0] ALU_OP; wire [31:0] Inst_code; CPU uut ( .clk(clk), .rst(rst), .op_code(op_code), .funct(funct), .rs_addr(rs_addr), .rt_addr(rt_addr), .rd_addr(rd_addr), .shamt(shamt), .OF(OF), .ZF(ZF), .F(F), .ALU_OP(ALU_OP), .Inst_code(Inst_code) ); always #20 clk = ~clk; initial begin clk = 0; rst = 1; #2; rst = 0; end endmodule 友情提示：开始不拉高rst，第一条指令取不到噢，解释可以看实验七，顶上有链接\n代码地址 #代码地址\n","date":"23 December 2020","permalink":"/blogs/hdu_computer_organization_and_architecture_experiment/eighth_experiment/","section":"Blog","summary":"实验内容 # 掌握MIPS R型指令的数据通路设计，掌握指令流和数据流的控制方法 掌握完整的单周期CPU顶层模块的设计方法 实现MIPS R型指令的功能 解决方法 # 分析MIPS R型指令的特点，OP均为000000b，可作为判断R型指令的依据 两个源操作数分别在rs和rt字段所指定的寄存器中，而目的操作数则是在rd字段所指定的寄存器 3.","title":"杭电计算机组成实验 实验8-实现R型指令的CPU设计实验"},{"content":"","date":null,"permalink":"/tags/mips/","section":"Tags","summary":"","title":"MIPS"},{"content":"","date":null,"permalink":"/tags/%E5%8F%96%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%8C%87%E4%BB%A4%E8%AF%91%E7%A0%81/","section":"Tags","summary":"","title":"取指令与指令译码"},{"content":"","date":null,"permalink":"/tags/%E5%AD%98%E5%82%A8%E5%99%A8/","section":"Tags","summary":"","title":"存储器"},{"content":"实验内容 # 掌握灵活运用 Verilog HDL 进行各种描述与建模的技巧和方法 学习在 ISE 中设计生成 Memory IP 核的方法 学习存储器的结构及读写原理，掌握存储器的设计方法 解决方法 # 分析一个 256x8 位的物理存储器，具有读 写功能，按字节编址，按字访问， 即 64x32 位。\n首先，给出的 8 位存储器地址，只按照高 6 位访问存储器，而低 2 位必须为 00\n我采用了两种方法进行设计存储器，首先是 MemoryIP 核\nMemoryIP核只需按照书上步骤下来，贴几张步骤图，大家按照步骤下来 这里我选择的是同步存储器，由时钟控制；另一种是分布式存储器，不带时钟同步，也就是异步控制\n5. MemoryIP代码展示：\nmodule RAM( input [7:2]Mem_Addr, input [1:0]MUX,\tinput Mem_Write,\tinput Clk,\toutput reg [7:0]LED); wire [31:0]M_R_Data;\treg [31:0]M_W_Data;\tRAM_B your_instance_name ( .clka(Clk), // input clka .wea(Mem_Write), // input [0 : 0] wea .addra(Mem_Addr), // input [5 : 0] addra .dina(M_W_Data), // input [31 : 0] dina .douta(M_R_Data) // output [31 : 0] douta ); always @(*) begin LED = 0; M_W_Data = 0; if(Mem_Write) begin case(MUX) 2\u0026#39;b00:\tM_W_Data = 32\u0026#39;h0000_000F; 2\u0026#39;b01:\tM_W_Data = 32\u0026#39;h0000_0DB0; 2\u0026#39;b10:\tM_W_Data = 32\u0026#39;h003C_C381; 2\u0026#39;b11:\tM_W_Data = 32\u0026#39;hFFFF_FFFF;\tendcase end else begin case(MUX) 2\u0026#39;b00:\tLED = M_R_Data[7:0]; 2\u0026#39;b01:\tLED = M_R_Data[15:8]; 2\u0026#39;b10:\tLED = M_R_Data[23:16]; 2\u0026#39;b11:\tLED = M_R_Data[31:24];\tendcase end end endmodule Test_Mem.coe\nmemory_initialization_radix = 16; memory_initialization_vector = 00000820,00632020,00010fff,20006789,ffff0000,0000ffff,88888888,99999999,aaaaaaaa,bbbbbbbb; 测试模块\nmodule test; // Inputs reg [7:2] Mem_Addr; reg [1:0] MUX; reg Mem_Write; reg Clk; // Outputs wire [7:0] LED; RAM uut ( .Mem_Addr(Mem_Addr), .MUX(MUX), .Mem_Write(Mem_Write), .Clk(Clk), .LED(LED) ); always #20 Clk=~Clk; initial begin // Initialize Inputs Mem_Addr = 0; MUX = 0; Mem_Write = 1; Clk = 0; #100; Mem_Addr = 6\u0026#39;b000000; MUX = 0; Mem_Write = 0; end endmodule 6. 自己实现同步存储器核心代码展示（这自己实现的代码欢迎大家指正错误）：\n存储器模块\nmodule RAMA(Mem_Read,Mem_Write,Mem_Addr,M_W_Data,M_R_Data,clk); input Mem_Read,Mem_Write,clk; input [5:0]Mem_Addr; input [31:0]M_W_Data; output reg[31:0]M_R_Data; reg [0:31]memory[0:63]; always@(posedge clk) if(Mem_Write) memory[Mem_Addr]\u0026lt;=M_W_Data; else if(Mem_Read) M_R_Data \u0026lt;= memory[Mem_Addr]; endmodule 顶层模块\nmodule RAM( input [5:0]Mem_Addr, input [1:0]MUX,\tinput Mem_Write, input Mem_Read, input clk,\toutput reg [7:0]LED); wire [31:0]M_R_Data;\treg [31:0]M_W_Data;\tRAMA ram (Mem_Read,Mem_Write,Mem_Addr,M_W_Data,M_R_Data,clk); always @(*) begin LED = 0; M_W_Data = 0; if(Mem_Write) begin case(MUX) 2\u0026#39;b00:\tM_W_Data = 32\u0026#39;h0000_000F; 2\u0026#39;b01:\tM_W_Data = 32\u0026#39;h0000_0DB0; 2\u0026#39;b10:\tM_W_Data = 32\u0026#39;h003C_C381; 2\u0026#39;b11:\tM_W_Data = 32\u0026#39;hFFFF_FFFF;\tendcase end else if(Mem_Read) begin case(MUX) 2\u0026#39;b00:\tLED = M_R_Data[7:0]; 2\u0026#39;b01:\tLED = M_R_Data[15:8]; 2\u0026#39;b10:\tLED = M_R_Data[23:16]; 2\u0026#39;b11:\tLED = M_R_Data[31:24];\tendcase end end endmodule 测试模块\nmodule test; // Inputs reg [5:0] Mem_Addr; reg [1:0] MUX; reg Mem_Write; reg Mem_Read; reg clk; // Outputs wire [7:0] LED; RAM uut ( .Mem_Addr(Mem_Addr), .MUX(MUX), .Mem_Write(Mem_Write), .Mem_Read(Mem_Read), .clk(clk), .LED(LED) ); always #20 clk = ~clk; initial begin // Initialize Inputs Mem_Addr = 0; MUX = 0; Mem_Write = 1; Mem_Read = 0; clk = 0; #100; Mem_Addr = 0; MUX = 0; Mem_Write = 0; Mem_Read = 1; end endmodule 7. 自己实现异步存储器核心代码展示（这自己实现的代码欢迎大家指正错误）：\n存储器模块\nmodule RAMA(Mem_Read,Mem_Write,Mem_Addr,M_W_Data,M_R_Data); input Mem_Read,Mem_Write; input [5:0]Mem_Addr; input [31:0]M_W_Data; output reg[31:0]M_R_Data; reg [0:31]memory[0:63]; //M_R_Data \u0026lt;= Mem_Read?memory[Mem_Addr]:32\u0026#39;bz; always@(*) if(Mem_Write) memory[Mem_Addr]\u0026lt;=M_W_Data; else if(Mem_Read) M_R_Data \u0026lt;= memory[Mem_Addr]; endmodule 顶层模块\nmodule RAM( input [5:0]Mem_Addr, input [1:0]MUX,\tinput Mem_Write, input Mem_Read,\toutput reg [7:0]LED); wire [31:0]M_R_Data;\treg [31:0]M_W_Data;\tRAMA ram (Mem_Read,Mem_Write,Mem_Addr,M_W_Data,M_R_Data); always @(*) begin LED = 0; M_W_Data = 0; if(Mem_Write) begin case(MUX) 2\u0026#39;b00:\tM_W_Data = 32\u0026#39;h0000_000F; 2\u0026#39;b01:\tM_W_Data = 32\u0026#39;h0000_0DB0; 2\u0026#39;b10:\tM_W_Data = 32\u0026#39;h003C_C381; 2\u0026#39;b11:\tM_W_Data = 32\u0026#39;hFFFF_FFFF;\tendcase end else if(Mem_Read) begin case(MUX) 2\u0026#39;b00:\tLED = M_R_Data[7:0]; 2\u0026#39;b01:\tLED = M_R_Data[15:8]; 2\u0026#39;b10:\tLED = M_R_Data[23:16]; 2\u0026#39;b11:\tLED = M_R_Data[31:24];\tendcase end end endmodule 测试模块\nmodule test; reg [5:0] Mem_Addr; reg [1:0] MUX; reg Mem_Write; reg Mem_Read; wire [7:0] LED; RAM uut ( .Mem_Addr(Mem_Addr), .MUX(MUX), .Mem_Write(Mem_Write), .Mem_Read(Mem_Read), .LED(LED) ); initial begin Mem_Addr = 0; MUX = 0; Mem_Write = 1; Mem_Read = 0; #100; Mem_Addr = 0; MUX = 0; Mem_Write = 0; Mem_Read = 1; end endmodule 代码地址 #代码地址-1\n代码地址-2\n代码地址-3\n","date":"22 December 2020","permalink":"/blogs/hdu_computer_organization_and_architecture_experiment/fifth_experiment/","section":"Blog","summary":"实验内容 # 掌握灵活运用 Verilog HDL 进行各种描述与建模的技巧和方法 学习在 ISE 中设计生成 Memory IP 核的方法 学习存储器的结构及读写原理，掌握存储器的设计方法 解决方法 # 分析一个 256x8 位的物理存储器，具有读 写功能，按字节编址，按字访问， 即 64x32 位。","title":"杭电计算机组成实验 实验5-存储器设计实验"},{"content":"实验内容 # 学习 MIPS指令系统，熟悉 MIPS指令格式及其汇编指令助记符，掌握机器 指令编码方法 学习 MIPS汇编程序设计，学会使用 MIPS 汇编器将汇编语言程序翻译成二 进制文件 了解使用 MIPS教学系统模拟器运行程序的方法 解决方法 # 下载 PCSpim 软件 给大家一个下载的地方，只要关注我，就可以下载到PCSpim下载地址 按照书上的要求，在文本编辑器中输入汇编程序，然后装入PCSpim 左侧内为指令地址，中间是十六进制的指令编码，右侧是相应的标准汇编指 令，主要注意的是第二个程序，必须在裸机执行方式 书上的汇编和结果展示： test.asm\nmain:\tli $v0 , 5 syscall move $t0,$v0 li $v0,5 syscall\tmove $t1 , $v0 bgt $t0,$t1,t0_bigger move $t2,$t1 b endif t0_bigger : move $t2,$t0 endif :move $a0,$t2 li $v0,1 syscall jr $ra R_CPU_Test.asm\nmain:nor $1,$0,$0;\t#$1 = FFFF_FFFF\tsltu $2,$0,$1;\t#$2 = 0000_0001 if($2\u0026lt;$3) $1=1 else $1=0 add $3,$2,$2;\t#$3 = 0000_0002 add $4,$3,$2;\t#$4 = 0000_0003 add $5,$4,$3;\t#$5 = 0000_0005 add $6,$5,$3;\t#$6 = 0000_0007 sllv $7,$6,$2;\t#$7 = 0000_000E $1=$2\u0026lt;\u0026lt;$3 add $9,$5,$6;\t#$9 = 0000_000C sllv $8,$6,$9;\t#$8 = 0000_7000 xor $9,$1,$8;\t#$9 = FFFF_8FFF add $10,$9,$1;\t#$10 = FFFF_8FFE sub $11,$8,$7; #$11 = 0000_6FF2 sub $12,$7,$8;\t#$12 = FFFF_900E and $13,$9,$12; #$13 = FFFF_800E or $14,$9,$12;\t#$14 = FFFF_9FFF or $15,$6,$7;\t#$15 = 0000_000F nor $16,$6,$7;\t#$16 = FFFF_FFF0 add $17,$7,$3;\t#$17 = 0000_0010 sllv $18,$8,$17;\t#$18 = 7000_0000 sllv $19,$3,$17;\t#$19 = 0002_0000 sllv $20,$19,$7;\t#$20 = 8000_0000 add $21,$20,$1; #$21 = 7FFF_FFFF or $22,$18,$21\t#$22 = 7FFF_FFFF add $23,$20,$22;\t#$23 = FFFF_FFFF sub $24,$20,$22;\t#$24 = 0000_0001 sub $25,$22,$20;\t#$25 = FFFF_FFFF xor $26,$18,$1;\t#$26 = 8FFF_FFFF sltu $27,$22,$20;\t#$27 = 0000_0001 sltu $28,$26,$20;\t#$28 = 0000_0000 add $29,$22,$2;\t#$29 = 8000_0000 sub $30,$20,$2;\t#$30 = 7FFF_FFFF add $31,$11,$26;\t#$31 = 9000_6FF1 结果机器码展示\n00000827 0001102b 00421820 00622020 00832820 00a33020 00463804 00a64820 01264004 00284826 01215020 01075822 00e86022 012c6824 012c7025 00c77825 00c78027 00e38820 02289004 02239804 00f3a004 0281a820 0255b025 0296b820 0296c022 02d4c822 0241d026 02d4d82b 0354e02b 02c2e820 0282f022 017af820 代码地址 #代码地址\n","date":"22 December 2020","permalink":"/blogs/hdu_computer_organization_and_architecture_experiment/sixth_experiment/","section":"Blog","summary":"实验内容 # 学习 MIPS指令系统，熟悉 MIPS指令格式及其汇编指令助记符，掌握机器 指令编码方法 学习 MIPS汇编程序设计，学会使用 MIPS 汇编器将汇编语言程序翻译成二 进制文件 了解使用 MIPS教学系统模拟器运行程序的方法 解决方法 # 下载 PCSpim 软件 给大家一个下载的地方，只要关注我，就可以下载到PCSpim下载地址 按照书上的要求，在文本编辑器中输入汇编程序，然后装入PCSpim 左侧内为指令地址，中间是十六进制的指令编码，右侧是相应的标准汇编指 令，主要注意的是第二个程序，必须在裸机执行方式 书上的汇编和结果展示： test.","title":"杭电计算机组成实验 实验6-MIPS汇编器与模拟器实验"},{"content":"实验内容 # 学习指令存储器的设计 掌握CPU取指令操作与指令译码的方法和过程 解决方法 # 本次实验设计采用哈佛结构设计存储器模块，需要设计一个只读存储器作为指令存储器，采用Memory IP核实现（不会用Memory IP核，可以看我这个博文 存储器实验 程序计数器PC与PC自增加法器组合成一个模块，由于指令存储器只有64个32位单元，所以PC的32位指令地址的高24位可直接在设计中清零 需要注意在指令周期clk的上升沿执行取指令操作，在clk下降沿更新PC值 代码展示: 顶层模块\nmodule Fetch_Inst_Code(clk,rst,LED,MUX,op_code,funct,rs_addr,rt_addr,rd_addr,shamt,Inst_code); input clk,rst; input [1:0]MUX; output [31:0]Inst_code; output reg[7:0]LED; reg [31:0]PC; wire [31:0]PC_new; output [5:0]op_code,funct; output [4:0]rs_addr,rt_addr,rd_addr,shamt; PC pc1(clk,rst,Inst_code); always@(*) begin case(MUX) 2\u0026#39;b00:LED = Inst_code[7:0]; 2\u0026#39;b01:LED = Inst_code[15:8]; 2\u0026#39;b10:LED = Inst_code[23:16]; 2\u0026#39;b11:LED = Inst_code[31:25]; endcase end assign op_code = Inst_code[31:26]; assign rs_addr = Inst_code[25:21]; assign rt_addr = Inst_code[20:16]; assign rd_addr = Inst_code[15:11]; assign shamt = Inst_code[10:6]; assign funct = Inst_code[5:0]; endmodule PC(取指令模块)\nmodule PC(clk,rst,Inst_code); input clk,rst; wire [31:0]PC_new; reg[31:0]PC; initial PC = 32\u0026#39;h0000_0000; output [31:0]Inst_code; assign PC_new = PC +4; Inst_Rom your_instance_name ( .clka(clk), // input clka .addra(PC[7:2]), // input [5 : 0] addra .douta(Inst_code) // output [31 : 0] douta ); always@(negedge clk or posedge rst) begin if(rst) begin PC \u0026lt;= 32\u0026#39;h0000_0000; end else begin PC \u0026lt;=PC_new; end end endmodule 友情提示：PC一定要初始化，否则结果会有所偏差\n测试模块\nmodule test; // Inputs reg clk; reg rst; reg [1:0] MUX; // Outputs wire [7:0] LED; wire [5:0] op_code; wire [5:0] funct; wire [4:0] rs_addr; wire [4:0] rt_addr; wire [4:0] rd_addr; wire [4:0] shamt; wire [31:0] Inst_code; Fetch_Inst_Code uut ( .clk(clk), .rst(rst), .LED(LED), .MUX(MUX), .op_code(op_code), .funct(funct), .rs_addr(rs_addr), .rt_addr(rt_addr), .rd_addr(rd_addr), .shamt(shamt), .Inst_code(Inst_code) ); always #33 clk = ~clk; initial begin clk = 0; rst = 1; MUX = 0; #2; rst = 0; end endmodule MIPS32.coe\nmemory_initialization_radix=16; memory_initialization_vector=00000827 0001102b 00421820 00622020 00832820 00a33020 00463804 00a64820 01264004 00284826 01215020 01075822 00e86022 012c6824 012c7025 00c77825 00c78027 00e38820 02289004 02239804 00f3a004 0281a820 0255b025 0296b820 0296c022 02d4c822 0241d026 02d4d82b 0354e02b 02c2e820 0282f022 017af820; 友情提示：如果rst不先开始拉高，就会导致第一条指令取不到，我一个朋友就因为这个写了一个下午，重构了很久；根据我个人分析，是因为clk的上升沿的到来，但是PC地址还没准备好，导致第一条指令没有取到\n询问了研究生学长，证实自己的想法\n代码地址 #代码地址\n","date":"22 December 2020","permalink":"/blogs/hdu_computer_organization_and_architecture_experiment/seventh_experiment/","section":"Blog","summary":"实验内容 # 学习指令存储器的设计 掌握CPU取指令操作与指令译码的方法和过程 解决方法 # 本次实验设计采用哈佛结构设计存储器模块，需要设计一个只读存储器作为指令存储器，采用Memory IP核实现（不会用Memory IP核，可以看我这个博文 存储器实验 程序计数器PC与PC自增加法器组合成一个模块，由于指令存储器只有64个32位单元，所以PC的32位指令地址的高24位可直接在设计中清零 需要注意在指令周期clk的上升沿执行取指令操作，在clk下降沿更新PC值 代码展示: 顶层模块","title":"杭电计算机组成实验 实验7-取指令与指令译码实验"},{"content":"","date":null,"permalink":"/tags/%E5%85%A8%E5%8A%A0%E5%99%A8/","section":"Tags","summary":"","title":"全加器"},{"content":"","date":null,"permalink":"/tags/%E5%A4%9A%E5%8A%9F%E8%83%BDalu/","section":"Tags","summary":"","title":"多功能ALU"},{"content":"","date":null,"permalink":"/tags/%E5%AF%84%E5%AD%98%E5%99%A8%E5%A0%86/","section":"Tags","summary":"","title":"寄存器堆"},{"content":"实验内容 # 学习ISE工具软件的使用及仿真方法 学习FPGA程序的下载方式 熟悉Nexys3实验板 掌握运用Verilog HDL 进行结构描述与建模的技术和方法 掌握二进制全加器的原理与设计 解决方法 # 分析二进制全加器的输入输出，然后得出两个输出端口的门电路。 使用ISE内部门级电路进行组合，最后实现实验所需的效果 代码展示： 顶层模块：\nmodule First_Experiment_Add(A,B,Ci,F,C); input A,B,Ci; output F,C; xor\tXU1(F,A,B,Ci), XU2(Q,A,B); and\tAN1(W,Q,Ci), AN2(E,A,B); or\tOR1(C,W,E); endmodule 测试模块：\nmodule test; // Inputs reg A; reg B; reg Ci; // Outputs wire F; wire C; First_Experiment_Add uut ( .A(A), .B(B), .Ci(Ci), .F(F), .C(C) ); initial begin A = 0; B = 0; Ci = 0; #100; A = 1; B = 0; Ci = 0; #100; A = 1; B = 1; Ci = 0; #100; A = 1; B = 1; Ci = 1; end endmodule 代码地址 #代码地址\n","date":"21 December 2020","permalink":"/blogs/hdu_computer_organization_and_architecture_experiment/first_experiment/","section":"Blog","summary":"实验内容 # 学习ISE工具软件的使用及仿真方法 学习FPGA程序的下载方式 熟悉Nexys3实验板 掌握运用Verilog HDL 进行结构描述与建模的技术和方法 掌握二进制全加器的原理与设计 解决方法 # 分析二进制全加器的输入输出，然后得出两个输出端口的门电路。 使用ISE内部门级电路进行组合，最后实现实验所需的效果 代码展示： 顶层模块：","title":"杭电计算机组成实验 实验1-全加器设计实验"},{"content":"实验内容 # 掌握运用Verilog HDL进行数据流描述与建模的技巧和方法，掌握模块调用与实例引用的方法 掌握超前进位加法器的原理与设计方法 解决方法 # 分析4位的二进制全加器的输入输出，内部为超前进位逻辑 首先，要知道超前进位逻辑与行波进位加法器的区别 行波进位加法器需要像链子一样，等第一位算完，再算第二位，而超前进位加法器是四位同时，第二位包括了第一位的计算部分，从而达到消除依赖的关系 代码展示： 顶层模块\nmodule second_experiment_first(A,B,F,C4,C0); input [3:0]A,B; input C0; output [3:0]F; output C4; assign G0 = A[0] \u0026amp; B[0]; assign P0 = A[0] | B[0]; assign G1 = A[1] \u0026amp; B[1]; assign P1 = A[1] | B[1]; assign G2 = A[2] \u0026amp; B[2]; assign P2 = A[2] | B[2]; assign G3 = A[3] \u0026amp; B[3]; assign P3 = A[3] | B[3]; assign C1 = G0 | P0\u0026amp;C0; assign C2 = G1 | P1\u0026amp;G0 | P0\u0026amp;P1\u0026amp;C0; assign C3 = G2 | P2\u0026amp;G1 | P2\u0026amp;P1\u0026amp;G0 | P2\u0026amp;P1\u0026amp;P0\u0026amp;C0; assign C4 = G3 | P3\u0026amp;G2 | P3\u0026amp;P2\u0026amp;G1 | P3\u0026amp;P2\u0026amp;P1\u0026amp;G0 | P3\u0026amp;P2\u0026amp;P1\u0026amp;P0\u0026amp;C0; assign F[0] = A[0]^B[0]^C0; assign F[1] = A[1]^B[1]^C1; assign F[2] = A[2]^B[2]^C2; assign F[3] = A[3]^B[3]^C3; endmodule 测试模块\nmodule second_experiment_test; // Inputs reg [3:0] A; reg [3:0] B; reg C0; // Outputs wire [3:0] F; wire C4; second_experiment_first uut ( .A(A), .B(B), .F(F), .C4(C4), .C0(C0) ); initial begin A = 4\u0026#39;b1000; B = 4\u0026#39;b1000; C0 = 1; #100; A = 4\u0026#39;b1001; B = 4\u0026#39;b1001; C0 = 1; #100; A = 4\u0026#39;b1011; B = 4\u0026#39;b1011; C0 = 1; end endmodule 特别注意 #题主在网上看到一份报告中的代码并不是把所有的运算拿过来的，而是把C1赋给C2这样做的，assign这种组合逻辑电路，是并行执行，这样的方法不一定可行\n代码地址 #代码地址\n","date":"21 December 2020","permalink":"/blogs/hdu_computer_organization_and_architecture_experiment/second_experiment/","section":"Blog","summary":"实验内容 # 掌握运用Verilog HDL进行数据流描述与建模的技巧和方法，掌握模块调用与实例引用的方法 掌握超前进位加法器的原理与设计方法 解决方法 # 分析4位的二进制全加器的输入输出，内部为超前进位逻辑 首先，要知道超前进位逻辑与行波进位加法器的区别 行波进位加法器需要像链子一样，等第一位算完，再算第二位，而超前进位加法器是四位同时，第二位包括了第一位的计算部分，从而达到消除依赖的关系 代码展示： 顶层模块","title":"杭电计算机组成实验 实验2-超前进位加法器设计实验"},{"content":"实验内容 # 学习多功能ALU的工作原理，掌握运算器的设计方法 掌握运用Verilog HDL 进行行为描述与建模的技巧和方法 解决方法 # 分析一个具有8种运算功能的32位ALU，并能够产生运算结果的标志：结果位零标志（ZF）和溢出标志（OF） 首先，分析出ZF只会在加减运算中出现溢出情况，然后分析出ALU 8种计算如何表达，如果使用“-”，就不用考虑如何减法 代码展示： 顶层模块：\nmodule ALU(AB_SW,ALU_OP,F_LED_SW,LED); input[2:0]AB_SW,ALU_OP,F_LED_SW; output[7:0]LED; wire [31:0]A,B,F; wire ZF,OF; Third_experiment_second T2(AB_SW,A,B); Third_experiment_first T1(OF,ZF,ALU_OP,A,B,F); Third_experiment_third T3(F_LED_SW,LED,F,ZF,OF); endmodule Third_experiment_second模块（作为数据输入）\nmodule Third_experiment_second(AB_SW,A,B); input[2:0]AB_SW; output reg[31:0]A,B; always @(*) begin case(AB_SW) 3\u0026#39;b000:begin A=32\u0026#39;h0000_0000;B=32\u0026#39;h0000_0000;end 3\u0026#39;b001:begin A=32\u0026#39;h0000_0003;B=32\u0026#39;h0000_0607;end 3\u0026#39;b010:begin A=32\u0026#39;h8000_0000;B=32\u0026#39;h8000_0000;end 3\u0026#39;b011:begin A=32\u0026#39;h7FFF_FFFF;B=32\u0026#39;h7FFF_FFFF;end 3\u0026#39;b100:begin A=32\u0026#39;hFFFF_FFFF;B=32\u0026#39;hFFFF_FFFF;end 3\u0026#39;b101:begin A=32\u0026#39;h8000_0000;B=32\u0026#39;hFFFF_FFFF;end 3\u0026#39;b110:begin A=32\u0026#39;hFFFF_FFFF;B=32\u0026#39;h8000_0000;end 3\u0026#39;b111:begin A=32\u0026#39;h1234_5678;B=32\u0026#39;h3333_2222;end default:begin A=32\u0026#39;h9ABC_DEF0;B=32\u0026#39;h1111_2222;end endcase end endmodule Third_experiment_first模块（运算）\nmodule Third_experiment_first(OF,ZF,ALU_OP,A,B,F); input [2:0]ALU_OP; input [31:0]A,B; output reg[31:0]F; reg C32; output reg OF=0; output reg ZF=0; always @(ALU_OP or A or B) begin case(ALU_OP) 3\u0026#39;b000:F\u0026lt;=A\u0026amp;B; 3\u0026#39;b001:F\u0026lt;=A|B; 3\u0026#39;b010:F\u0026lt;=A^B; 3\u0026#39;b011:F\u0026lt;=A~^B; 3\u0026#39;b100:{C32,F}\u0026lt;=A+B; 3\u0026#39;b101:{C32,F}\u0026lt;=A-B; 3\u0026#39;b110:begin if(A\u0026lt;B) F\u0026lt;=32\u0026#39;h0000_0001;else F\u0026lt;=32\u0026#39;h0000_0000;end 3\u0026#39;b111:begin F\u0026lt;=B\u0026lt;\u0026lt;A;end endcase if(F==32\u0026#39;h0000_0000)\tZF\u0026lt;=1; else ZF\u0026lt;=0; OF=C32^F[31]^A[31]^B[31];\tend endmodule Third_experiment_third模块（作为LED显示）\nmodule Third_experiment_third(F_LED_SW,LED,F,ZF,OF); input[31:0]F; input ZF,OF; input[2:0] F_LED_SW; output reg[7:0] LED; always@(*) begin case(F_LED_SW) 3\u0026#39;b000:LED=F[7:0]; 3\u0026#39;b001:LED=F[15:8]; 3\u0026#39;b010:LED=F[23:16]; 3\u0026#39;b011:LED=F[31:24]; default:begin LED[7]=ZF;LED[0]=OF;LED[6:1]=6\u0026#39;b0;end endcase end endmodule 测试模块\nmodule ALU_TEST; // Inputs reg [2:0] AB_SW; reg [2:0] ALU_OP; reg [2:0] F_LED_SW; // Outputs wire [7:0] LED; ALU uut ( .AB_SW(AB_SW), .ALU_OP(ALU_OP), .F_LED_SW(F_LED_SW), .LED(LED) ); initial begin AB_SW = 3\u0026#39;b001; ALU_OP = 3\u0026#39;b000; F_LED_SW = 3\u0026#39;b000; #100; AB_SW = 3\u0026#39;b001; ALU_OP = 3\u0026#39;b001; F_LED_SW = 3\u0026#39;b000; #100; AB_SW = 3\u0026#39;b001; ALU_OP = 3\u0026#39;b010; F_LED_SW = 3\u0026#39;b000; end endmodule 特别注意 #当时在做实验的时候，有的朋友问我begin\u0026hellip;end是干什么用，其实就是相当于C语言中的大括号\n代码地址 #代码地址\n","date":"21 December 2020","permalink":"/blogs/hdu_computer_organization_and_architecture_experiment/third_experiment/","section":"Blog","summary":"实验内容 # 学习多功能ALU的工作原理，掌握运算器的设计方法 掌握运用Verilog HDL 进行行为描述与建模的技巧和方法 解决方法 # 分析一个具有8种运算功能的32位ALU，并能够产生运算结果的标志：结果位零标志（ZF）和溢出标志（OF） 首先，分析出ZF只会在加减运算中出现溢出情况，然后分析出ALU 8种计算如何表达，如果使用“-”，就不用考虑如何减法 代码展示： 顶层模块：","title":"杭电计算机组成实验 实验3-多功能ALU设计实验"},{"content":"实验内容 # 学习使用Verilog HDL 进行时序电路的设计方法 掌握灵活运用Verilog HDL进行各种描述与建模的技巧和方法 学习寄存器堆的数据传送与读/写工作原理，掌握寄存器堆的设计方法 解决方法 # 分析一个32x32位的寄存器堆，即含有32个寄存器，每个寄存器32位。该寄存器堆有2个读端口、1个写端口，即能够同时读出2个寄存器的值，写入1个寄存器 首先，分析出两个端口读入是5位的地址，读出的数据是32位的两个，该寄存器堆只有一个写端口，还要配合控制信号Write_Reg，且写操作是边沿触发的，所有写入操作的输入信号必须在时钟边沿来临时已经有效 寄存器堆的读操作和写操作的地址译码，只需引用寄存器地址作为数组的下标即可；读只需要组合逻辑，给出寄存器地址，读出数据 代码展示： 顶层模块（需要数据输入在板子上操作）：\nmodule RegisterFile(Addr,Write_Reg,Opt,Clk,Reset,A_B,LED); input [1:0]Opt; input [4:0]Addr; input Write_Reg,Clk,Reset,A_B; output reg [7:0]LED; wire [31:0]R_Data_A,R_Data_B; reg [4:0]R_Addr_A,R_Addr_B; reg [31:0]W_Data; initial LED \u0026lt;= 0; Fourth_experiment_first F1(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,Addr,W_Data); always@(Addr or Write_Reg or Opt or A_B or R_Data_A or R_Data_B) begin if(Write_Reg) begin case(Opt) 2\u0026#39;b00: begin W_Data=32\u0026#39;h000f_000f; end 2\u0026#39;b01: begin W_Data=32\u0026#39;h0f0f_0f00; end 2\u0026#39;b10: begin W_Data=32\u0026#39;hf0f0_f0f0; end 2\u0026#39;b11: begin W_Data=32\u0026#39;hffff_ffff; end endcase end else if(A_B) begin R_Addr_A=Addr; case(Opt) 2\u0026#39;b00: LED=R_Data_A[7:0]; 2\u0026#39;b01: LED=R_Data_A[15:8]; 2\u0026#39;b10: LED=R_Data_A[23:16]; 2\u0026#39;b11: LED=R_Data_A[31:24]; endcase end else begin R_Addr_B=Addr; case(Opt) 2\u0026#39;b00: LED=R_Data_B[7:0]; 2\u0026#39;b01: LED=R_Data_B[15:8]; 2\u0026#39;b10: LED=R_Data_B[23:16]; 2\u0026#39;b11: LED=R_Data_B[31:24]; endcase end end endmodule 寄存器堆实现的Fourth_experiment_first模块\nmodule Fourth_experiment_first(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,W_Addr,W_Data); input [4:0]R_Addr_A,R_Addr_B,W_Addr; input Write_Reg,Reset,Clk; input[31:0] W_Data; output [31:0] R_Data_A,R_Data_B; reg [31:0] REG_Files[0:31]; integer i=0; always @ (posedge Clk or posedge Reset) begin if(Reset) begin for(i=0;i\u0026lt;=31;i=i+1) REG_Files[i]\u0026lt;=0; end else begin if(Write_Reg) REG_Files[W_Addr]\u0026lt;=W_Data; end end assign R_Data_A = REG_Files[R_Addr_A]; assign R_Data_B = REG_Files[R_Addr_B]; endmodule 测试模块\nmodule Fourth_experiment_test; // Inputs reg [4:0] Addr; reg Write_Reg; reg [1:0] Opt; reg Clk; reg Reset; reg A_B; // Outputs wire [7:0] LED; RegisterFile uut ( .Addr(Addr), .Write_Reg(Write_Reg), .Opt(Opt), .Clk(Clk), .Reset(Reset), .A_B(A_B), .LED(LED) ); always #20 Clk = ~Clk; initial begin Addr = 5\u0026#39;b00001; Write_Reg = 1; Opt = 0; Clk = 1; Reset = 0; A_B = 0; #100; Addr = 5\u0026#39;b00001; Write_Reg = 0; Opt = 0; A_B = 0; end endmodule 代码地址 #代码地址\n","date":"21 December 2020","permalink":"/blogs/hdu_computer_organization_and_architecture_experiment/fourth_experiment/","section":"Blog","summary":"实验内容 # 学习使用Verilog HDL 进行时序电路的设计方法 掌握灵活运用Verilog HDL进行各种描述与建模的技巧和方法 学习寄存器堆的数据传送与读/写工作原理，掌握寄存器堆的设计方法 解决方法 # 分析一个32x32位的寄存器堆，即含有32个寄存器，每个寄存器32位。该寄存器堆有2个读端口、1个写端口，即能够同时读出2个寄存器的值，写入1个寄存器 首先，分析出两个端口读入是5位的地址，读出的数据是32位的两个，该寄存器堆只有一个写端口，还要配合控制信号Write_Reg，且写操作是边沿触发的，所有写入操作的输入信号必须在时钟边沿来临时已经有效 寄存器堆的读操作和写操作的地址译码，只需引用寄存器地址作为数组的下标即可；读只需要组合逻辑，给出寄存器地址，读出数据 代码展示： 顶层模块（需要数据输入在板子上操作）：","title":"杭电计算机组成实验 实验4-寄存器堆设计实验"},{"content":"","date":null,"permalink":"/tags/%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8/","section":"Tags","summary":"","title":"超前进位加法器"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":" 2022年从杭州不知名院校本科毕业 本科前两年一直研究嵌入式，参加过智能车竞赛、电子设计竞赛，获得了一些奖项 后面随着大流，接触Java，那时候不知道自己要做什么样的工作，要成为什么样的人 机缘巧合入职后，将自己的技术栈转换到Golang 虽然现在我的依然不知道自己想要做什么样的工作，想要成为什么样的人，但我一直在寻找自己真正感兴趣的方向 Contact # GitHub Email ","date":null,"permalink":"/about/","section":"Welcome to XdpCs’s blog!","summary":" 2022年从杭州不知名院校本科毕业 本科前两年一直研究嵌入式，参加过智能车竞赛、电子设计竞赛，获得了一些奖项 后面随着大流，接触Java，那时候不知道自己要做什么样的工作，要成为什么样的人 机缘巧合入职后，将自己的技术栈转换到Golang 虽然现在我的依然不知道自己想要做什么样的工作，想要成为什么样的人，但我一直在寻找自己真正感兴趣的方向 Contact # GitHub Email ","title":"关于我"}]