[{"content":"","date":"18 November 2022","permalink":"/projects/solidity-learning/","section":"Projects","summary":"","title":"Solidity-Learning"},{"content":"","date":"25 December 2020","permalink":"/projects/hdu-computer-organization-and-architecture-experiment/","section":"Projects","summary":"","title":"杭电计算机组成实验"},{"content":"","date":"29 November 2022","permalink":"/posts/","section":"Blog","summary":"","title":"Blog"},{"content":"","date":"29 November 2022","permalink":"/tags/hugo/","section":"Tags","summary":"","title":"hugo"},{"content":"问题1 # found no layout file for \u0026#34;HTML\u0026#34; for kind \u0026#34;page\u0026#34;: You should create a template file which matches Hugo Layouts Lookup Rules for this combination. 解决方法 # hugo mod clean hugo server ","date":"29 November 2022","permalink":"/posts/hugo/hugo_error/","section":"Blog","summary":"问题1 # found no layout file for \u0026#34;HTML\u0026#34; for kind \u0026#34;page\u0026#34;: You should create a template file which matches Hugo Layouts Lookup Rules for this combination.","title":"hugo 遇到的问题"},{"content":"","date":"29 November 2022","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"18 November 2022","permalink":"/tags/git/","section":"Tags","summary":"","title":"git"},{"content":"原理 # 本地仓库由git维护三棵\u0026quot;树\u0026quot; 第一个是工作目录,它拥有实际的文件 第二个是暂存区，它类似于缓存的存在，临时保存你的改动 第三个是HEAD,它指向最后一次提交的结果 概念 # 分支 # 分支是用来将特性开发隔离开。在你创建仓库的时候，master或main是默认的分支。我们一般在其他分支上进行开发，完成后再将它们合并到主分支上 你在本地创建的分支，如果不推送到远端仓库，这个分支就只能在本地可见 命令 # 命令只介绍在开发过程中，常用的命令 创建新的git仓库 # git init 添加到暂存区 # git add \u0026lt;filename\u0026gt; git add . git add \u0026lt;filename\u0026gt; ,添加具体文件到暂存区 git add .,将所有变动添加到暂存区 这是git基本工作流程的第一步，将文件添加到暂存区 提交 # git commit -m \u0026#34;提交信息\u0026#34; 将改动提交到本地仓库的HEAD中 这是git基本工作流程的第二步，将文件提交到本地仓库的HEAD中 推送 # git push origin master 将改动提交到远端仓库，可以将master换成任何你想要推送的分支 这是git基本工作流程的第三步，推送到远端仓库 git remote add origin \u0026lt;server\u0026gt; 将你的仓库连接到远端仓库，若你本地仓库未和远端仓库建立关系 分支 # git checkout -b feature_xdp 创建一个叫做feature_xdp的分支 git checkout master 切换到主分支 更新与合并 # git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; 标准格式 以当前工作目录进行获取（fetch）并合并（merge）远端的改动 git pull git pull origin 将远端仓库的origin的master分支拉取到本地，并与本地的当前分支进行合并 git pull origin master:feature_xdp 将远端仓库的origin的master分支拉取过来，与本地的feature_xdp分支合并 git pull origin master 如果远端仓库的分支是与当前分支合并，则冒号后面的部分可以省略 git merge \u0026lt;branch\u0026gt; 合并其他分支到当前分支 冲突 # git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; 和 git merge \u0026lt;branch\u0026gt;,在两种情况下，git 会尝试自动合并改动，但是并不是每一次都会成功，可能会出现冲突。这个时候，需要你手动修改来合并这些冲突 git add \u0026lt;filename\u0026gt; 合并完成后，需要将它们添加到暂存区 git diff \u0026lt;source_branch\u0026gt; \u0026lt;target_branch\u0026gt; 可以使用该命令预览差异，在合并改动之前 log # git log 查看本地仓库历史记录 git log --author=XdpCs 只看XdpCs的提交记录 git log --pretty=oneline 每一条提交记录只占一行输出 git log --graph --oneline --decorate --all 通过树形结构来展示所有的分支，每个分支都标明它的名字和标签 git log --name-status 查看哪些文件发生改变 标签 # 通过创建标签，发布软件是一个不错的方法 git tag 1.0.0 1fd11181114 创建一个叫1.0.0的标签，1fd11181114是你想要标记的提交ID 提交ID可以通过上面的git log获取 只要提交ID具有指向唯一性，提交ID可以少几位 替换本地改动 # git checkout -- \u0026lt;filename\u0026gt; 使用HEAD中最新的内容替换掉你工作目录中的文件 已添加到暂存区的改动和新文件不会受到影响 git fetch origin git reset --hard origin/master 丢弃本地的所有改动和提交，从远端服务器获取最新的版本历史，并将本地分支指向它 克隆仓库 # git clone ../xdpcs.github.io 创建一个本地仓库的克隆版本 git clone git@github.com:XdpCs/Solidity-Learning.git 克隆一个远端服务器上的仓库 ","date":"18 November 2022","permalink":"/posts/git/git_study/","section":"Blog","summary":"原理 # 本地仓库由git维护三棵\u0026quot;树\u0026quot; 第一个是工作目录,它拥有实际的文件 第二个是暂存区，它类似于缓存的存在，临时保存你的改动 第三个是HEAD,它指向最后一次提交的结果 概念 # 分支 # 分支是用来将特性开发隔离开。在你创建仓库的时候，master或main是默认的分支。我们一般在其他分支上进行开发，完成后再将它们合并到主分支上 你在本地创建的分支，如果不推送到远端仓库，这个分支就只能在本地可见 命令 # 命令只介绍在开发过程中，常用的命令 创建新的git仓库 # git init 添加到暂存区 # git add \u0026lt;filename\u0026gt; git add .","title":"Git 学习"},{"content":"","date":"18 November 2022","permalink":"/projects/","section":"Projects","summary":"","title":"Projects"},{"content":"","date":"18 November 2022","permalink":"/tags/solidity/","section":"Tags","summary":"","title":"solidity"},{"content":"","date":"18 November 2022","permalink":"/tags/web3/","section":"Tags","summary":"","title":"web3"},{"content":"基础知识 # 以太币单位 单位 Wei Wei值 Wei 1 1 Wei Kwei (babbage) 1,000 1e3 Wei Mwei (lovelace) 1,000,000 1e6 Wei Gwei (shannon) 1,000,000,000 1e9 Wei microether (szabo) 1,000,000,000,000 1e12 Wei milliether (finney) 1,000,000,000,000,000 1e15 Wei ether 1,000,000,000,000,000,000 1e18 Wei 交易需要支付ether 在Solidity中，单位之间的换算是在数字后加上 wei，gwei 或 ether 来实现的 在Solidity中，后面没有单位，缺省为 wei 从Solidity0.7.0版本开始， finney 和 szabo 被移除了 gwei 在solidity 0.6.11版本中添加，因此在0.6.11之前的版本中不可用 例子 # 该例子是测试以太币的单位换算\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract EtherUnits { uint public oneWei = 1 wei; bool public isOneWei = 1 wei == 1; uint public oneEther = 1 ether; bool public isOneEther = 1 ether == 1e18; uint public oneGwei = 1 gwei; bool public isOneGwei = 1 gwei == 1e9; } 程序解析 # uint public oneWei = 1 wei; bool public isOneWei = 1 wei == 1; 1 wei 等于 1，若没填写单位，默认是以wei为单位 uint public oneEther = 1 ether; bool public isOneEther = 1 ether == 1e18; 1 ether 等于 10^18 wei uint public oneGwei = 1 gwei; bool public isOneGwei = 1 gwei == 1e9; 1 gwei 等于 10^9 wei ","date":"18 September 2022","permalink":"/posts/solidity/ether_and_wei/","section":"Blog","summary":"基础知识 # 以太币单位 单位 Wei Wei值 Wei 1 1 Wei Kwei (babbage) 1,000 1e3 Wei Mwei (lovelace) 1,000,000 1e6 Wei Gwei (shannon) 1,000,000,000 1e9 Wei microether (szabo) 1,000,000,000,000 1e12 Wei milliether (finney) 1,000,000,000,000,000 1e15 Wei ether 1,000,000,000,000,000,000 1e18 Wei 交易需要支付ether 在Solidity中，单位之间的换算是在数字后加上 wei，gwei 或 ether 来实现的 在Solidity中，后面没有单位，缺省为 wei 从Solidity0.","title":"8-以太币单位"},{"content":"基础知识 # 写入和更新状态变量需要发送一笔交易 读取状态变量是免费的，无需任何交易费用 例子 # 例子\n该例子是读写一个状态变量的例子\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract SimpleStorage { uint public num; function set(uint _num) public { num = _num; } function get() public view returns (uint) { return num; } } 程序解析 # uint public num; 存储一个uint的状态变量 function set(uint _num) public { num = _num; } 需要发送一笔交易才能写入状态变量 function get() public view returns (uint) { return num; } 读取状态变量时，不需要发送一笔交易 ","date":"17 September 2022","permalink":"/posts/solidity/read_and_write_state/","section":"Blog","summary":"基础知识 # 写入和更新状态变量需要发送一笔交易 读取状态变量是免费的，无需任何交易费用 例子 # 例子","title":"7-读取和写入状态变量"},{"content":"基础知识 # 不可变变量就像常量 不可变变量的值可以在构造函数中初始化或在声明时初始化，但初始化后就不能被修改了,这样可以节省gas,提高合约的安全性 数值变量可以声明为immutable string和bytes不可以声明为immutable,这不同于constant 例子 # 例子\n该例子是如何对不可变变量进行赋值\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Immutable { address public immutable MY_ADDRESS; uint public immutable MY_UINT; uint public immutable MY_LOVE = 1118; constructor(uint _myUint){ MY_ADDRESS = msg.sender; MY_UINT = _myUint; } } 程序解析 # address public immutable MY_ADDRESS; uint public immutable MY_UINT; uint public immutable MY_LOVE = 1118; 大写不可变变量的名称是一种编码习惯 constructor(uint _myUint){ MY_ADDRESS = msg.sender; MY_UINT = _myUint; } 不可变变量必须在构造函数的时候就赋值，构造函数只会在合约部署的时候调用一次 ","date":"16 September 2022","permalink":"/posts/solidity/immutable/","section":"Blog","summary":"基础知识 # 不可变变量就像常量 不可变变量的值可以在构造函数中初始化或在声明时初始化，但初始化后就不能被修改了,这样可以节省gas,提高合约的安全性 数值变量可以声明为immutable string和bytes不可以声明为immutable,这不同于constant 例子 # 例子","title":"6-不可变变量"},{"content":"基础知识 # 常量是不可修改的变量 它们的值是硬编码的，使用常量可以节省gas成本,还可以提高合约安全性 例子 # 例子\n该例子是常量的使用方法的例子\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Constants { address public constant MY_ADDRESS = 0x0000000000000000000000000000000000001118; uint public constant MY_UINT = 1118; string public constant MY_STRING = \u0026#34;0x1118\u0026#34;; bytes public constant MY_BYTES = \u0026#34;FYY\u0026#34;; } 程序解析 # address public constant MY_ADDRESS = 0x0000000000000000000000000000000000001118; uint public constant MY_UINT = 1118; string public constant MY_STRING = \u0026#34;0x1118\u0026#34;; bytes public constant MY_BYTES = \u0026#34;FYY\u0026#34;; 大写常量变量的名称是一种编码习惯 常量必须在声明的时候，进行初始化，之后便不能再改变了 数值变量、string和bytes可以声明为constant ","date":"15 September 2022","permalink":"/posts/solidity/constants/","section":"Blog","summary":"基础知识 # 常量是不可修改的变量 它们的值是硬编码的，使用常量可以节省gas成本,还可以提高合约安全性 例子 # 例子","title":"5-常量"},{"content":"基础知识 # 在Solidity中有3种类型的变量 局部变量 声明在函数内部 不存储在区块链上 状态变量 声明在函数外部 存储在区块链上 全局变量 提供关于区块链上的信息 可以在函数内不声明直接使用 全局变量列举 blockhash(uint blockNumber) returns (bytes32): 指定区块的哈希值\u0026ndash;仅可用于最新的256个区块且不包括当前区块，否则返回0 block.basefee (uint): 当前区块的基础费用 block.chainid (uint): 当前链 id block.coinbase(address): 挖出当前区块矿工的地址 block.difficulty(uint): 当前区块难度 block.gaslimit(uint): 当前区块的gas限额 block.number(uint): 当前区块号 block.timestamp(uint): 当前区块的时间戳，自unix纪元以来的秒数 gasleft() returns (uint256): 剩余的gas msg.data(bytes): 完整的calldata msg.sender(address): 消息发送者 (当前调用者) msg.sig(bytes4)：calldata的前四个字节 (也就是函数标识符) msg.value(uint): 当前交易发送的wei的数量 tx.gasprice(uint): 交易的gas价格 tx.origin(address): 交易发起者(完全的调用链） 例子 # 例子\n该例子是局部变量、状态变量和全局变量使用的例子\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Variables { string public text = \u0026#34;hello,fyy\u0026#34;; uint public num = 1118; uint public gasLeft; address public origin; uint public timestamp; function doSomething() public { uint i = 1114; text = \u0026#34;hello,xdp\u0026#34;; gasLeft = gasleft(); origin = tx.origin; timestamp = block.timestamp; } } 程序解析 # string public text = \u0026#34;hello,fyy\u0026#34;; uint public num = 1118; uint public gasLeft; address public origin; uint public timestamp; 状态变量存储在区块链上，会更加消耗gas uint i = 1114; 局部变量不存储在区块链上，仅在函数执行过程中变量才有效，相比状态变量更加节省gas text = \u0026#34;hello,xdp\u0026#34;; gasLeft = gasleft(); origin = tx.origin; timestamp = block.timestamp; 修改状态变量值 gasLeft = gasleft(); origin = tx.origin; timestamp = block.timestamp; 全局变量的使用方法 ","date":"14 September 2022","permalink":"/posts/solidity/variables/","section":"Blog","summary":"基础知识 # 在Solidity中有3种类型的变量 局部变量 声明在函数内部 不存储在区块链上 状态变量 声明在函数外部 存储在区块链上 全局变量 提供关于区块链上的信息 可以在函数内不声明直接使用 全局变量列举 blockhash(uint blockNumber) returns (bytes32): 指定区块的哈希值\u0026ndash;仅可用于最新的256个区块且不包括当前区块，否则返回0 block.","title":"4-变量"},{"content":"基础知识 # 我将介绍四种在Solidity中可用的原始数据类型，它们都是值类型 bool uint、int address bytes(定长数组) 布尔型(bool) 布尔型的取值只有两种：true和false 布尔型的运算符包括： 比较运算符：\u0026gt;，\u0026gt;=，\u0026lt;，\u0026lt;=，==，!= 与运算 \u0026amp;\u0026amp; 或运算 || 非运算 ! \u0026amp;\u0026amp;和||运算符遵循短路规则，a||b，如果a是true,b不会被计算;a\u0026amp;\u0026amp;b,如果a是false,b不会被计算 短路规则会更加节省gas费用 整数型(uint、int) uint代表无符号整数，也就是说没有负数的整数 有不同字节数的无符号整数，可供使用 uint8 范围 从 0 到 2 ** 8 - 1 uint16 范围 从 0 到 2 ** 16 - 1 \u0026hellip; 以8位为递增 uint256 范围 从 0 到 2 ** 256 - 1 int表示有符号整数，在int中允许有负数存在 int表示的范围与uint表示的范围不同 int8 范围 从 -2 ** 7 到 2 ** 7 - 1 int16 范围 从 -2 ** 15 到 2 ** 15 - 1 \u0026hellip; 以8位为递增 int256 范围 从 -2 ** 255 到 2 ** 255 - 1 整型的运算符 比较运算符： \u0026lt;=,\u0026lt;,==,!=,\u0026gt;=,\u0026gt; 算数运算符： +,-,-（一元运算符),*,/,%（取余）,**（幂） 地址类型(address) address类型是一个20个字节的值 有单纯的地址和可以进行ETH转账的地址(payable)两种类型 payable的地址拥有balance和transfer() balance用于查询余额 transfer()用于转账 字节类型(bytes) bytes表示一个字节序列 Solidity 提供了2种字节类型： 固定大小的字节数组 固定大小的字节数组属于原始数据类型(值类型) 固定大小的字节数组存储数据会更节省gas费用 动态大小的字节数组 动态大小的字节数组不属于此类型(值类型)，在后面会讲 默认值 未赋值的变量有一个默认值 布尔型(bool)为false 整数型(uint、int)为0 地址类型(address)为0x0000000000000000000000000000000000000000 字节类型(bytes)为0 例子 # 例子\n该例子是原始类型使用的例子\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Primitives { bool public b = false; bool public b1 = 1118 \u0026gt; 1114; // true bool public b2 = 1118 \u0026gt;= 1114; // true bool public b3 = 1118 \u0026lt; 1114; // false bool public b4 = 1118 \u0026lt;= 1114; // false bool public b5 = 1118 == 1114; // false bool public b6 = 1118 != 1114; // true bool public b7 = !b; // true bool public b8 = b1 \u0026amp;\u0026amp; b2; // true bool public b9 = b3 \u0026amp;\u0026amp; b1; // false,发生短路运算 bool public b10 = b3 || b4; // false bool public b11 = b1 || b3; // true,发生短路运算 uint8 public u8 = 18; uint24 public u24 = 1118; uint public u256 = 1114; // uint是uint256的别称 int8 public i8 = - 18; int24 public i24 = 1118; int public i256 = - 1114; // int是int256的别称 int public minInt = type(int).min; int public maxInt = type(int).max; int public int_1 = - 1114; int public int_2 = 1118 + 1114; int public int_3 = 1118 - 1114; int public int_4 = 18 * 14; int public int_5 = 18 / 18; int public int_6 = 1118 % 1114; int public int_7 = 2 ** 10; address public addr; constructor ()payable{ } function getEth() public { addr = msg.sender; address payable _addr = payable(addr); _addr.transfer(1 ether); } bytes1 public a1 = 0xb5; // [10110101] bytes2 public a2 = 0xb556; // [1011010101010110] bytes1 public a3 = a1[0]; // [10110101] bool public defaultBoo; // false uint public defaultUint; // 0 int public defaultInt; // 0 address public defaultAddr; // 0x0000000000000000000000000000000000000000 bytes2 public defaultBytes; // 0x0000 } 程序解析 # bool public b = false; bool public b1 = 1118 \u0026gt; 1114; // true bool public b2 = 1118 \u0026gt;= 1114; // true bool public b3 = 1118 \u0026lt; 1114; // false bool public b4 = 1118 \u0026lt;= 1114; // false bool public b5 = 1118 == 1114; // false bool public b6 = 1118 != 1114; // true bool public b7 = !b; // true bool public b8 = b1 \u0026amp;\u0026amp; b2; // true bool public b9 = b3 \u0026amp;\u0026amp; b1; // false,发生短路运算 bool public b10 = b3 || b4; // false bool public b11 = b1 || b3; // true,发生短路运算 布尔型(bool)使用的例子 uint8 public u8 = 18; uint24 public u24 = 1118; uint public u256 = 1114; // uint是uint256的别称 int8 public i8 = - 18; int24 public i24 = 1118; int public i256 = - 1114; // int是int256的别称 整数型(uint、int)使用的例子 int public minInt = type(int).min; int public maxInt = type(int).max; int的最大值和最小值 int public int_1 = - 1114; int public int_2 = 1118 + 1114; int public int_3 = 1118 - 1114; int public int_4 = 18 * 14; int public int_5 = 18 / 18; int public int_6 = 1118 % 1114; int public int_7 = 2 ** 10; 算术运算符的例子，如果想看比较运算符的例子，可以看上面布尔值的例子 address public addr; 地址类型(address)使用的例子 constructor ()payable{ } 在部署合约的时候，需要向合约中转入eth,否则会调用失败 构造函数用payable修饰，保证部署合约的时候，能打入eth function getEth() public { addr = msg.sender; address payable _addr = payable(addr); _addr.transfer(1 ether); } 用户调用此函数，可以从合约中提取1个ether到自己的账户 bytes1 public a1 = 0xb5; // [10110101] bytes2 public a2 = 0xb556; // [1011010101010110] bytes1 public a3 = a1[0]; // [10110101] 字节类型(bytes)使用的例子 bool public defaultBoo; // false uint public defaultUint; // 0 int public defaultInt; // 0 address public defaultAddr; // 0x0000000000000000000000000000000000000000 bytes2 public defaultBytes; // 0x0000 默认值使用的例子 ","date":"13 September 2022","permalink":"/posts/solidity/primitives/","section":"Blog","summary":"基础知识 # 我将介绍四种在Solidity中可用的原始数据类型，它们都是值类型 bool uint、int address bytes(定长数组) 布尔型(bool) 布尔型的取值只有两种：true和false 布尔型的运算符包括： 比较运算符：\u0026gt;，\u0026gt;=，\u0026lt;，\u0026lt;=，==，!","title":"3-原始数据类型"},{"content":"这是一个简单的计数器合约,在合约中存储一个数，你可以增加和减少此数\n例子 # 该例子是一个链上计数器合约\n例子\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Counter { uint public count; function getCount() public view returns (uint) { return count; } function inc() public { count++; } function dec() public { count--; } } 程序解析 # uint public count; 存储在链上合约中的count变量,用public修饰可见性，在后面可以知道，public修饰的变量，会自动生成一个get函数 function getCount() public view returns (uint) { return count; } 该函数用于获取当前count的值，其实此函数是多此一举hhh function inc() public { count++; } 该函数用于增加count的值 function dec() public { count--; } 该函数用于减少count的值，但是在刚开始部署合约的时候，不能先调用此函数 因为在Solidity 8.0版本之后，如果溢出，会将交易回滚，显示交易失败 ","date":"12 September 2022","permalink":"/posts/solidity/first_app/","section":"Blog","summary":"这是一个简单的计数器合约,在合约中存储一个数，你可以增加和减少此数","title":"2-第一个App"},{"content":"任何一个程序教学，开头都会教你如何写Hello World，我也不例外\n例子 # 该例子是在链上存储\u0026quot;Hello World!\u0026quot;的字符串\n例子\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract HelloWorld { string public greet = \u0026#34;Hello World!\u0026#34;; } 程序解析 # // SPDX-License-Identifier: MIT 如果不加此行，编译的时候，编译器会警告，但程序可以编译成功 如果你不想指定一个许可证，或者源代码不开源，请使用特殊值UNLICENSED 注意，UNLICENSED(不存在于SPDX许可证列表中)与UNLICENSE(授予所有人所有权利)不同 每个源文件都应该注释最上面一行，以说明版权许可证 版权注释在文件的任何位置都可以被编译器识别，但建议把它放在文件的顶部 编译器不会验证许可证是否属于SPDX版权许可列表,但它会在bytecode metadata中包含提供的字符串 pragma solidity ^0.8.0; 源文件不允许使用低于0.8.0版本并且不高于0.9.0的编译器编译,^表示高于 contract HelloWorld contract声明了一个合约名字，名字叫HelloWorld string public greet = \u0026#34;Hello World!\u0026#34;; 声明了一个string变量，并且可见性是public ","date":"11 September 2022","permalink":"/posts/solidity/hello_world/","section":"Blog","summary":"任何一个程序教学，开头都会教你如何写Hello World，我也不例外","title":"1-你好，世界"},{"content":"Hi! My name is Alan Xu. # I am interested in all golang\u0026rsquo;s project. # ","date":"18 June 2022","permalink":"/","section":"Welcome to XdpCs’s blog!","summary":"Hi! My name is Alan Xu.","title":"Welcome to XdpCs’s blog!"},{"content":"","date":"26 December 2020","permalink":"/tags/r-i-j%E5%9E%8B%E6%8C%87%E4%BB%A4/","section":"Tags","summary":"","title":"R-I-J型指令"},{"content":"实验内容 # 掌握MIPS R型、I型和J型指令的综合数据通路设计，掌握各种转移类指令的控制流和指令流的多路选通控制方法 掌握J型、I型和R型转移指令的指令格式和寻址方式，学习转移地址的产生方法，掌握无条件转移指令和条件转移指令的实现方法 编程实现MIPS的部分J型、I型和R型转移指令的功能 解决方法 # 分析MIPS J型指令的特点，由6位OP字段和26位的address字段构成 分析转移指令的数据通路，转移地址的产生有三种方式，转移地址产生后，要送入PC，才能完成跳转 R型指令还添加了一条无条件跳转指令，要在原来的PC模块判断R型指令的地方进行修改，不能在I型指令下判断，这样会产生冲突 对于条件转移指令beq和bne要使用ALU做减法，判断是否全为零，也就是用ZF判断是否转移 J型指令可以接着I型指令的case结构写下来，与J型case结构无冲突 由于实验九和实验十想法十分接近，主要是控制信号的改变，及其译码模块的改变 涉及实验：具体用到的实验是多功能ALU设计实验、寄存器堆设计实验 、取指令与指令译码实验 代码展示 顶层模块\nmodule CPU(clk,rst,OF,ZF,F,ALU_OP,M_R_Data,w_r_s,imm_s,rt_imm_s,Mem_Write,Write_Reg,PC,PC_s,clk_M,R_Data_B,Inst_code); input clk,rst,clk_M; output [31:0]Inst_code; wire [5:0]op_code,funct; wire [4:0]rs_addr,rt_addr,rd_addr,shamt; output [31:0]F; output OF,ZF; output [31:0]M_R_Data; output [2:0]ALU_OP; wire [31:0]Mem_Addr; wire [4:0]W_Addr; output imm_s,rt_imm_s,Mem_Write,Write_Reg; output [1:0]w_r_s; wire [31:0]imm_data; wire [31:0]R_Data_A; output [31:0]R_Data_B; wire [15:0]imm; wire [31:0]ALU_B; wire [31:0]W_Data; output [1:0]PC_s; wire [25:0]address; wire [1:0]wr_data_s; wire [31:0]PC_new; output [31:0]PC; PC pc1(clk,rst,Inst_code,PC_s,R_Data_A,address,PC,imm_data,PC_new); assign op_code = Inst_code[31:26]; assign rs_addr = Inst_code[25:21]; assign rt_addr = Inst_code[20:16]; assign rd_addr = Inst_code[15:11]; assign shamt = Inst_code[10:6]; assign funct = Inst_code[5:0]; assign imm = Inst_code[15:0]; assign address = Inst_code[25:0]; OP_Func op(op_code,funct,Write_Reg,ALU_OP,w_r_s,imm_s,rt_imm_s,Mem_Write,wr_data_s,PC_s,ZF); assign W_Addr = (w_r_s[1])?5\u0026#39;b11111:((w_r_s[0])?rt_addr:rd_addr); assign imm_data = (imm_s)?{{16{imm[15]}},imm}:{{16{1\u0026#39;b0}},imm}; Fourth_experiment_first F1(rs_addr,rt_addr,Write_Reg,R_Data_A,R_Data_B,rst,~clk,W_Addr,W_Data); assign ALU_B = (rt_imm_s)?imm_data:R_Data_B; Third_experiment_first T1(OF,ZF,ALU_OP,R_Data_A,ALU_B,F); RAM RAM_B ( .clka(clk_M), // input clka .wea(Mem_Write), // input [0 : 0] wea .addra(F[5:0]), // input [5 : 0] addra .dina(R_Data_B), // input [31 : 0] dina .douta(M_R_Data) // output [31 : 0] douta ); assign W_Data = (wr_data_s[1])?PC_new:((wr_data_s[0])? M_R_Data:F); endmodule PC（取指令模块）\nmodule PC(clk,rst,Inst_code,PC_s,R_Data_A,address,PC,imm_data,PC_new); input clk,rst; input [1:0]PC_s; input [31:0]R_Data_A; input [25:0]address; input [31:0]imm_data; output reg[31:0]PC; output [31:0]PC_new; initial PC = 32\u0026#39;h0000_0000; output [31:0]Inst_code; assign PC_new = PC +4; Inst_Rom rom( .clka(clk), // input clka .addra(PC[7:2]), // input [5 : 0] addra .douta(Inst_code) // output [31 : 0] douta ); always@(negedge clk or posedge rst) begin if(rst) begin PC \u0026lt;= 32\u0026#39;h0000_0000; end else begin case (PC_s) 2\u0026#39;b00:\tPC \u0026lt;= PC_new; 2\u0026#39;b01:\tPC \u0026lt;= R_Data_A;\t2\u0026#39;b10: PC \u0026lt;= PC_new + (imm_data\u0026lt;\u0026lt;2);\t2\u0026#39;b11:\tPC \u0026lt;= {PC_new[31:28],address,2\u0026#39;b00}; endcase end end endmodule OP_Func（译码模块）\nmodule OP_Func(op_code,funct,Write_Reg,ALU_OP,w_r_s,imm_s,rt_imm_s,Mem_Write,wr_data_s,PC_s,ZF); input [5:0]op_code; input [5:0]funct; input ZF; output reg[2:0]ALU_OP; output reg Write_Reg; output reg [1:0]wr_data_s; output reg imm_s; output reg rt_imm_s; output reg Mem_Write; output reg [1:0]w_r_s; output reg [1:0]PC_s; always@(*) begin\tWrite_Reg=1; ALU_OP=3\u0026#39;b100; wr_data_s=0; imm_s=0; rt_imm_s=0; Mem_Write=0; w_r_s=0; PC_s = 0; if(op_code==6\u0026#39;b000000) begin case(funct) 6\u0026#39;b100000:begin ALU_OP=3\u0026#39;b100; end 6\u0026#39;b100010:begin ALU_OP=3\u0026#39;b101; end 6\u0026#39;b100100:begin ALU_OP=3\u0026#39;b000;end 6\u0026#39;b100101:begin ALU_OP=3\u0026#39;b001;end 6\u0026#39;b100110:begin ALU_OP=3\u0026#39;b010;end 6\u0026#39;b100111:begin ALU_OP=3\u0026#39;b011;end 6\u0026#39;b101011:begin ALU_OP=3\u0026#39;b110;end 6\u0026#39;b000100:begin ALU_OP=3\u0026#39;b111;end 6\u0026#39;b001000:begin Write_Reg=0;Mem_Write=0;PC_s = 2\u0026#39;b01; end endcase end else begin case(op_code) 6\u0026#39;b001000:begin w_r_s=2\u0026#39;b01;imm_s=1;rt_imm_s=1;ALU_OP=3\u0026#39;b100;end 6\u0026#39;b001100:begin w_r_s=2\u0026#39;b01;rt_imm_s=1;ALU_OP=3\u0026#39;b000; end 6\u0026#39;b001110:begin w_r_s=2\u0026#39;b01;rt_imm_s=1;ALU_OP=3\u0026#39;b010;end 6\u0026#39;b001011:begin w_r_s=2\u0026#39;b01;rt_imm_s=1;ALU_OP=3\u0026#39;b110; end 6\u0026#39;b100011:begin w_r_s=2\u0026#39;b01;imm_s=1;rt_imm_s=1;wr_data_s=2\u0026#39;b01;ALU_OP=3\u0026#39;b100; end 6\u0026#39;b101011:begin imm_s=1;rt_imm_s=1;ALU_OP=3\u0026#39;b100;Write_Reg=0;Mem_Write=1; end 6\u0026#39;b000100:begin ALU_OP=3\u0026#39;b101;PC_s = (ZF)?2\u0026#39;b10:2\u0026#39;b00; Write_Reg = 1\u0026#39;b0;end 6\u0026#39;b000101:begin ALU_OP=3\u0026#39;b101;PC_s = (ZF)?2\u0026#39;b00:2\u0026#39;b10; Write_Reg = 1\u0026#39;b0;end 6\u0026#39;b000010:begin Write_Reg=0;PC_s = 2\u0026#39;b11; end 6\u0026#39;b000011:begin w_r_s=2\u0026#39;b10;wr_data_s=2\u0026#39;b10;PC_s = 2\u0026#39;b11; end endcase end end endmodule Fourth_experiment_first（寄存器堆模块）\nmodule Fourth_experiment_first(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,W_Addr,W_Data); input [4:0]R_Addr_A,R_Addr_B,W_Addr; input Write_Reg,Reset,Clk; input[31:0] W_Data; output [31:0] R_Data_A,R_Data_B; reg [31:0] REG_Files[0:31]; integer i=0; initial for(i=0;i\u0026lt;32;i=i+1) REG_Files[i]\u0026lt;=0; always @ (posedge Clk or posedge Reset) begin if(Reset) begin for(i=0;i\u0026lt;=31;i=i+1) REG_Files[i]\u0026lt;=0; end else begin if(Write_Reg) REG_Files[W_Addr]\u0026lt;=W_Data; end end assign R_Data_A = REG_Files[R_Addr_A]; assign R_Data_B = REG_Files[R_Addr_B]; endmodule Third_experiment_first（ALU模块）\nmodule Third_experiment_first(OF,ZF,ALU_OP,A,B,F); input [2:0]ALU_OP; input [31:0]A,B; output reg[31:0]F; reg C32; output reg OF; output reg ZF; always @(ALU_OP or A or B) begin OF = 0; C32 = 0; case(ALU_OP) 3\u0026#39;b000:F\u0026lt;=A\u0026amp;B; 3\u0026#39;b001:F\u0026lt;=A|B; 3\u0026#39;b010:F\u0026lt;=A^B; 3\u0026#39;b011:F\u0026lt;=A~^B; 3\u0026#39;b100:{C32,F}\u0026lt;=A+B; 3\u0026#39;b101:{C32,F}\u0026lt;=A-B; 3\u0026#39;b110:begin if(A\u0026lt;B) F\u0026lt;=32\u0026#39;h0000_0001;else F\u0026lt;=32\u0026#39;h0000_0000;end 3\u0026#39;b111:begin F\u0026lt;=B\u0026lt;\u0026lt;A;end endcase if(F==32\u0026#39;h0000_0000)\tZF\u0026lt;=1; else ZF\u0026lt;=0; if(ALU_OP == 3\u0026#39;b100 || ALU_OP == 3\u0026#39;b101) OF\u0026lt;=C32^F[31]^A[31]^B[31];\telse OF \u0026lt;=0; end endmodule 数据.coe\nmemory_initialization_radix=16; memory_initialization_vector=88888888,99999999,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999, aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff, 20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb, 00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,12345678,23456789,3456789a,6789abcd; 程序机器码.coe\nmemory_initialization_radix=16; memory_initialization_vector=00002020,20050014,2006000b,0c000004,00804020,00a04820,00c05020,8d0b0000,ad2b0000,21080001,21290001,214affff,1540fffa,03e00008; 测试模块\nmodule test; // Inputs reg clk; reg rst; reg clk_M; // Outputs wire OF; wire ZF; wire [31:0] F; wire [2:0] ALU_OP; wire [31:0] M_R_Data; wire [1:0] w_r_s; wire imm_s; wire rt_imm_s; wire Mem_Write; wire Write_Reg; wire [31:0] PC; wire [1:0] PC_s; wire [31:0] R_Data_B; wire [31:0] Inst_code; CPU uut ( .clk(clk), .rst(rst), .OF(OF), .ZF(ZF), .F(F), .ALU_OP(ALU_OP), .M_R_Data(M_R_Data), .w_r_s(w_r_s), .imm_s(imm_s), .rt_imm_s(rt_imm_s), .Mem_Write(Mem_Write), .Write_Reg(Write_Reg), .PC(PC), .PC_s(PC_s), .clk_M(clk_M), .R_Data_B(R_Data_B), .Inst_code(Inst_code) ); always #4 clk_M = ~clk_M; always #16 clk =~clk; initial begin clk = 0; rst = 1; clk_M = 0; #2; rst = 0; end endmodule 汇编程序\nmain: add $a0,$zero,$zero addi $a1,$zero,20; addi $a2,$zero,10; jal BankMove BankMove: add $t0,$a0,$zero; add $t1,$a1,$zero; add $t2,$a2,$zero; Loop1:lw $t3,0($t0); sw $t3,0($t1); addi $t0,$t0,1; addi $t1,$t1,1; addi $t2,$t2,-1; bne $t2,$zero,Loop1; jr $ra 友情提示 # 书上的机器码存在错误，读者可以自行对比，纠正机器码，博主用的汇编程序是将存储器1-10位搬到20-30位\n代码地址 # 代码地址\n","date":"26 December 2020","permalink":"/posts/hdu_computer_organization_and_architecture_experiment/tenth_experiment/","section":"Blog","summary":"实验内容 # 掌握MIPS R型、I型和J型指令的综合数据通路设计，掌握各种转移类指令的控制流和指令流的多路选通控制方法 掌握J型、I型和R型转移指令的指令格式和寻址方式，学习转移地址的产生方法，掌握无条件转移指令和条件转移指令的实现方法 编程实现MIPS的部分J型、I型和R型转移指令的功能 解决方法 # 分析MIPS J型指令的特点，由6位OP字段和26位的address字段构成 分析转移指令的数据通路，转移地址的产生有三种方式，转移地址产生后，要送入PC，才能完成跳转 R型指令还添加了一条无条件跳转指令，要在原来的PC模块判断R型指令的地方进行修改，不能在I型指令下判断，这样会产生冲突 对于条件转移指令beq和bne要使用ALU做减法，判断是否全为零，也就是用ZF判断是否转移 J型指令可以接着I型指令的case结构写下来，与J型case结构无冲突 由于实验九和实验十想法十分接近，主要是控制信号的改变，及其译码模块的改变 涉及实验：具体用到的实验是多功能ALU设计实验、寄存器堆设计实验 、取指令与指令译码实验 代码展示 顶层模块","title":"杭电计算机组成实验 实验10-实现R-I-J型指令的CPU设计实验"},{"content":"","date":"25 December 2020","permalink":"/tags/architecture/","section":"Tags","summary":"","title":"architecture"},{"content":"","date":"25 December 2020","permalink":"/tags/fpga/","section":"Tags","summary":"","title":"fpga"},{"content":"","date":"25 December 2020","permalink":"/tags/r-i%E5%9E%8B%E6%8C%87%E4%BB%A4/","section":"Tags","summary":"","title":"R-I型指令"},{"content":"实验内容 # 掌握MIPS R型和I型指令的综合数据通路设计，掌握数据流的多路选通控制方法 掌握取数指令lw和存数指令sw的寻址方式及其有效地址产生的方法 实现MIPS的部分I型和 R型指令的功能 解决方法 # 分析MIPS I型指令的特点，与R型指令有明显的不同：没有rd寄存器，使用rt作为目的寄存器；源操作数中有一个为立即数，位于指令的低16位 在寄存器堆模块的写地址输入端口设置二选一选择器，由于R型和I型的目的寄存器不同，由rd_rt_s控制 16位的立即数imm需要经过扩展才能与rs执行运算操作，对于有符号数的操作，执行的是符号扩展，对于无符号数的操作，执行的是0扩展 R型指令执行rs和rt运算，结果送rd；而I型立即数即数寻址指令则执行rs和扩展后的立即数imm运算，结果送rt。因此ALU的输入数据B端有两个选择：rt或者imm，仍可以通过二选一数据选择器，用rt_imm_s控制信号 需要添加一个数据存储器RAM存放指令访问的数据，读出的数据，意味着要在寄存器堆的写端口加个选择器，用alu_mem_s控制信号，其中要注意一点就是数据存储器的clk至少是CPU频率的2倍以上，我使用了两个clk输入解决这个问题 在实际写代码时，要注意顶层模块中，实例下层模块的顺序，由于译码模块变量多，我将其抽离出来，为了使顶层模块看起来简洁 涉及实验： 具体用到的实验是多功能ALU设计实验、寄存器堆设计实验 、取指令与指令译码实验 代码展示 顶层模块\nmodule CPU(clk,rst,OF,ZF,F,ALU_OP,M_R_Data,rd_rt_s,imm_s,rt_imm_s,Mem_Write,alu_mem_s,Write_Reg,clk_M,R_Data_B,Inst_code); input clk,rst,clk_M; wire [31:0]Inst_code; wire [5:0]op_code,funct; wire [4:0]rs_addr,rt_addr,rd_addr,shamt; output [31:0]F; output OF,ZF; output [31:0]M_R_Data; output [2:0]ALU_OP; wire [31:0]Mem_Addr; wire [4:0]W_Addr; output rd_rt_s,imm_s,rt_imm_s,Mem_Write,alu_mem_s,Write_Reg; output [31:0]Inst_code; wire [31:0]imm_data; wire [31:0]R_Data_A; output [31:0] R_Data_B; wire [15:0]imm; wire [31:0]ALU_B; wire [31:0]W_Data; PC pc1(clk,rst,Inst_code); assign op_code = Inst_code[31:26]; assign rs_addr = Inst_code[25:21]; assign rt_addr = Inst_code[20:16]; assign rd_addr = Inst_code[15:11]; assign shamt = Inst_code[10:6]; assign funct = Inst_code[5:0]; assign imm = Inst_code[15:0]; OP_Func op(op_code,funct,Write_Reg,ALU_OP,rd_rt_s,imm_s,rt_imm_s,Mem_Write,alu_mem_s); assign W_Addr = (rd_rt_s)?rt_addr:rd_addr; assign imm_data = (imm_s)?{{16{imm[15]}},imm}:{{16{1\u0026#39;b0}},imm}; assign W_Data = alu_mem_s?M_R_Data:F; Fourth_experiment_first F1(rs_addr,rt_addr,Write_Reg,R_Data_A,R_Data_B,rst,clk,W_Addr,W_Data); assign ALU_B = (rt_imm_s)?imm_data:R_Data_B;\tThird_experiment_first T1(OF,ZF,ALU_OP,R_Data_A,ALU_B,F); RAM RAM_B ( .clka(clk_M), // input clka .wea(Mem_Write), // input [0 : 0] wea .addra(F[5:0]), // input [5 : 0] addra .dina(R_Data_B), // input [31 : 0] dina .douta(M_R_Data) // output [31 : 0] douta ); endmodule PC(取指令模块)\nmodule PC(clk,rst,Inst_code); input clk,rst; wire [31:0]PC_new; reg[31:0]PC; initial PC = 32\u0026#39;h0000_0000; output [31:0]Inst_code; assign PC_new = PC +4; Inst_Rom rom( .clka(clk), // input clka .addra(PC[7:2]), // input [5 : 0] addra .douta(Inst_code) // output [31 : 0] douta ); always@(negedge clk or posedge rst) begin if(rst) begin PC \u0026lt;= 32\u0026#39;h0000_0000; end else begin PC \u0026lt;= PC_new; end end endmodule OP_Func(译码模块)\nmodule OP_Func(op_code,funct,Write_Reg,ALU_OP,rd_rt_s,imm_s,rt_imm_s,Mem_Write,alu_mem_s); input [5:0]op_code; input [5:0]funct; output reg[2:0]ALU_OP; output reg Write_Reg; output reg rd_rt_s; output reg imm_s; output reg rt_imm_s; output reg Mem_Write; output reg alu_mem_s; always@(*) begin\tWrite_Reg=1; ALU_OP=0; rd_rt_s=0; imm_s=0; rt_imm_s=0; Mem_Write=0; alu_mem_s=0; if(op_code==0) begin case(funct) 6\u0026#39;b100000:begin ALU_OP=3\u0026#39;b100; end 6\u0026#39;b100010:begin ALU_OP=3\u0026#39;b101; end 6\u0026#39;b100100:begin ALU_OP=3\u0026#39;b000;end 6\u0026#39;b100101:begin ALU_OP=3\u0026#39;b001;end 6\u0026#39;b100110:begin ALU_OP=3\u0026#39;b010;end 6\u0026#39;b100111:begin ALU_OP=3\u0026#39;b011;end 6\u0026#39;b101011:begin ALU_OP=3\u0026#39;b110;end 6\u0026#39;b000100:begin ALU_OP=3\u0026#39;b111;end endcase end else begin case(op_code) 6\u0026#39;b001000:begin rd_rt_s=1;imm_s=1;rt_imm_s=1;ALU_OP=100;end 6\u0026#39;b001100:begin rd_rt_s=1;rt_imm_s=1;ALU_OP=000; end 6\u0026#39;b001110:begin rd_rt_s=1;rt_imm_s=1;ALU_OP=010;end 6\u0026#39;b001011:begin rd_rt_s=1;rt_imm_s=1;ALU_OP=110; end 6\u0026#39;b100011:begin rd_rt_s=1;imm_s=1;rt_imm_s=1;alu_mem_s=1;ALU_OP=100; end 6\u0026#39;b101011:begin imm_s=1;rt_imm_s=1;ALU_OP=100;Write_Reg=0;Mem_Write=1; end endcase end end endmodule Fourth_experiment_first（寄存器堆模块）\nmodule Fourth_experiment_first(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,W_Addr,W_Data); input [4:0]R_Addr_A,R_Addr_B,W_Addr; input Write_Reg,Reset,Clk; input[31:0] W_Data; output [31:0] R_Data_A,R_Data_B; reg [31:0] REG_Files[0:31]; integer i=0; initial for(i=0;i\u0026lt;32;i=i+1) REG_Files[i]\u0026lt;=0; always @ (posedge Clk or posedge Reset) begin if(Reset) begin for(i=0;i\u0026lt;=31;i=i+1) REG_Files[i]\u0026lt;=0; end else begin if(Write_Reg) REG_Files[W_Addr]\u0026lt;=W_Data; end end assign R_Data_A = REG_Files[R_Addr_A]; assign R_Data_B = REG_Files[R_Addr_B]; endmodule Third_experiment_first（ALU模块）\nmodule Third_experiment_first(OF,ZF,ALU_OP,A,B,F); input [2:0]ALU_OP; input [31:0]A,B; output reg[31:0]F; reg C32; output reg OF; output reg ZF; always @(ALU_OP or A or B) begin OF = 0; C32 = 0; case(ALU_OP) 3\u0026#39;b000:F\u0026lt;=A\u0026amp;B; 3\u0026#39;b001:F\u0026lt;=A|B; 3\u0026#39;b010:F\u0026lt;=A^B; 3\u0026#39;b011:F\u0026lt;=A~^B; 3\u0026#39;b100:{C32,F}\u0026lt;=A+B; 3\u0026#39;b101:{C32,F}\u0026lt;=A-B; 3\u0026#39;b110:begin if(A\u0026lt;B) F\u0026lt;=32\u0026#39;h0000_0001;else F\u0026lt;=32\u0026#39;h0000_0000;end 3\u0026#39;b111:begin F\u0026lt;=B\u0026lt;\u0026lt;A;end endcase if(F==32\u0026#39;h0000_0000)\tZF\u0026lt;=1; else ZF\u0026lt;=0; if(ALU_OP == 3\u0026#39;b100 || ALU_OP == 3\u0026#39;b101) OF\u0026lt;=C32^F[31]^A[31]^B[31];\telse OF \u0026lt;=0; end endmodule MIPS32.coe\nmemory_initialization_radix=16; memory_initialization_vector=38011234,20026789,20039000,38040010,00822804,00253025,00833804,00464020,00414822,00225022,206b7fff,206c8000,314dffff,2c4e6788,2c4f678a,ac8b0000,ac0c0014,ac8d0010,ac8e0014,8c100010,8c910004,02119025,8c930010,8c940014,0274a827,8c96fff0,8c97fff4,02d7c02b; 数据coe\nmemory_initialization_radix=16; memory_initialization_vector=88888888,99999999,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999, aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff, 20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb, 00000820,00632020,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,12345678,23456789,3456789a,6789abcd; 测试模块\nmodule test; reg clk; reg rst; reg clk_M; wire OF; wire ZF; wire [31:0] F; wire [2:0] ALU_OP; wire [31:0] M_R_Data; wire rd_rt_s; wire imm_s; wire rt_imm_s; wire Mem_Write; wire alu_mem_s; wire Write_Reg; wire [31:0] R_Data_B; wire [31:0] Inst_code; CPU uut ( .clk(clk), .rst(rst), .OF(OF), .ZF(ZF), .F(F), .ALU_OP(ALU_OP), .M_R_Data(M_R_Data), .rd_rt_s(rd_rt_s), .imm_s(imm_s), .rt_imm_s(rt_imm_s), .Mem_Write(Mem_Write), .alu_mem_s(alu_mem_s), .Write_Reg(Write_Reg), .clk_M(clk_M), .R_Data_B(R_Data_B), .Inst_code(Inst_code) ); always #9 clk_M = ~clk_M; always #20 clk =~clk; initial begin clk = 0; rst = 1; clk_M = 0; #2; rst = 0; end endmodule 友情提示 # 1.有的同学会把在顶层模块存数据存储器的地址和PC的地址弄混，大家会问为什么PC的存储器是取[7:2],而顶层模块存数据存储器的地址[5:0] ,主要原因就在PC=PC+4这个语句上，我们的存储器还是按照字节去寻址的，如果我们不取[7:2]的地址就会导致中间几条指令跳过，而顶层数据模块就是逐一增加的\n2.数据存储器的clk至少是CPU频率的2倍以上\n3.开始的时候，rst一定要拉高哦\n代码地址 # 代码地址\n","date":"25 December 2020","permalink":"/posts/hdu_computer_organization_and_architecture_experiment/ninth_experiment/","section":"Blog","summary":"实验内容 # 掌握MIPS R型和I型指令的综合数据通路设计，掌握数据流的多路选通控制方法 掌握取数指令lw和存数指令sw的寻址方式及其有效地址产生的方法 实现MIPS的部分I型和 R型指令的功能 解决方法 # 分析MIPS I型指令的特点，与R型指令有明显的不同：没有rd寄存器，使用rt作为目的寄存器；源操作数中有一个为立即数，位于指令的低16位 在寄存器堆模块的写地址输入端口设置二选一选择器，由于R型和I型的目的寄存器不同，由rd_rt_s控制 16位的立即数imm需要经过扩展才能与rs执行运算操作，对于有符号数的操作，执行的是符号扩展，对于无符号数的操作，执行的是0扩展 R型指令执行rs和rt运算，结果送rd；而I型立即数即数寻址指令则执行rs和扩展后的立即数imm运算，结果送rt。因此ALU的输入数据B端有两个选择：rt或者imm，仍可以通过二选一数据选择器，用rt_imm_s控制信号 需要添加一个数据存储器RAM存放指令访问的数据，读出的数据，意味着要在寄存器堆的写端口加个选择器，用alu_mem_s控制信号，其中要注意一点就是数据存储器的clk至少是CPU频率的2倍以上，我使用了两个clk输入解决这个问题 在实际写代码时，要注意顶层模块中，实例下层模块的顺序，由于译码模块变量多，我将其抽离出来，为了使顶层模块看起来简洁 涉及实验： 具体用到的实验是多功能ALU设计实验、寄存器堆设计实验 、取指令与指令译码实验 代码展示 顶层模块","title":"杭电计算机组成实验 实验9-实现R-I型指令的CPU设计实验"},{"content":"","date":"23 December 2020","permalink":"/tags/r%E5%9E%8B%E6%8C%87%E4%BB%A4/","section":"Tags","summary":"","title":"R型指令"},{"content":"实验内容 # 掌握MIPS R型指令的数据通路设计，掌握指令流和数据流的控制方法 掌握完整的单周期CPU顶层模块的设计方法 实现MIPS R型指令的功能 解决方法 # 分析MIPS R型指令的特点，OP均为000000b，可作为判断R型指令的依据 两个源操作数分别在rs和rt字段所指定的寄存器中，而目的操作数则是在rd字段所指定的寄存器 3.分析数据通路是从指令存储器取出的指令经过初级译码，将分解出的源寄存器rs、rt直接与寄存器堆的两个读端口A和B的寄存器地址连接，而将目的寄存器rd字段与寄存器堆的写端口地址相连，寄存器读出的A口数据和B口数据则直接连接到ALU的输入端A和B，ALU计算后的结果则送入寄存器堆的写数据端口 分析时序，首先是取指令，然后进行指令译码，最后将运算结果送到目的寄存器，PC自增，指向下一条指令 实验八中除译码模块，其他模块都已经前几个实验中完成，只需要将其连接，然后在译码模块中通过OP判断是否为R型，且将funct翻译成ALU的控制信号ALU_OP以及指定ALU的运算功能，由于此译码模块较为简单，我就在顶层模块实现了 具体用到的实验是多功能ALU设计实验、寄存器堆设计实验、取指令与指令译码实验 代码实现: 顶层模块\nmodule CPU(clk,rst,op_code,funct,rs_addr,rt_addr,rd_addr,shamt,OF,ZF,F,ALU_OP,Inst_code); input clk,rst; output [31:0]Inst_code; output [5:0]op_code,funct; output [4:0]rs_addr,rt_addr,rd_addr,shamt; output [31:0]F; output OF,ZF; output reg [2:0]ALU_OP; reg Write_Reg; wire [31:0]R_Data_A,R_Data_B; PC pc1(clk,rst,Inst_code); assign op_code = Inst_code[31:26]; assign rs_addr = Inst_code[25:21]; assign rt_addr = Inst_code[20:16]; assign rd_addr = Inst_code[15:11]; assign shamt = Inst_code[10:6]; assign funct = Inst_code[5:0]; Fourth_experiment_first F1(rs_addr,rt_addr,Write_Reg,R_Data_A,R_Data_B,rst,~clk,rd_addr,F); Third_experiment_first T1(OF,ZF,ALU_OP,R_Data_A,R_Data_B,F); always@(*) begin\tWrite_Reg\u0026lt;=0; ALU_OP=0; if(op_code==0) Write_Reg\u0026lt;=1; begin case(funct) 6\u0026#39;b100000:ALU_OP=3\u0026#39;b100; 6\u0026#39;b100010:ALU_OP=3\u0026#39;b101; 6\u0026#39;b100100:ALU_OP=3\u0026#39;b000; 6\u0026#39;b100101:ALU_OP=3\u0026#39;b001; 6\u0026#39;b100110:ALU_OP=3\u0026#39;b010; 6\u0026#39;b100111:ALU_OP=3\u0026#39;b011; 6\u0026#39;b101011:ALU_OP=3\u0026#39;b110; 6\u0026#39;b000100:ALU_OP=3\u0026#39;b111; endcase end end endmodule PC（取指令模块）\nmodule PC(clk,rst,Inst_code); input clk,rst; wire [31:0]PC_new; reg[31:0]PC; initial PC = 32\u0026#39;h0000_0000; output [31:0]Inst_code; assign PC_new = PC +4; Inst_Rom your_instance_name( .clka(clk), // input clka .addra(PC[7:2]), // input [5 : 0] addra .douta(Inst_code) // output [31 : 0] douta ); always@(negedge clk or posedge rst) begin if(rst) begin PC \u0026lt;= 32\u0026#39;h0000_0000; end else begin PC \u0026lt;= PC_new; end end endmodule Fourth_experiment_first模块（寄存器堆模块）\nmodule Fourth_experiment_first(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,W_Addr,W_Data); input [4:0]R_Addr_A,R_Addr_B,W_Addr; input Write_Reg,Reset,Clk; input[31:0] W_Data; output [31:0] R_Data_A,R_Data_B; reg [31:0] REG_Files[0:31]; integer i=0; initial for(i=0;i\u0026lt;32;i=i+1) REG_Files[i]\u0026lt;=0; always @ (posedge Clk or posedge Reset) begin if(Reset) begin for(i=0;i\u0026lt;=31;i=i+1) REG_Files[i]\u0026lt;=0; end else begin if(Write_Reg) REG_Files[W_Addr]\u0026lt;=W_Data; end end assign R_Data_A = REG_Files[R_Addr_A]; assign R_Data_B = REG_Files[R_Addr_B]; endmodule Third_experiment_first（ALU模块）\nmodule Third_experiment_first(OF,ZF,ALU_OP,A,B,F); input [2:0]ALU_OP; input [31:0]A,B; output reg[31:0]F; reg C32; output reg OF; output reg ZF; always @(ALU_OP or A or B) begin OF = 0; C32 = 0; case(ALU_OP) 3\u0026#39;b000:F\u0026lt;=A\u0026amp;B; 3\u0026#39;b001:F\u0026lt;=A|B; 3\u0026#39;b010:F\u0026lt;=A^B; 3\u0026#39;b011:F\u0026lt;=A~^B; 3\u0026#39;b100:{C32,F}\u0026lt;=A+B; 3\u0026#39;b101:{C32,F}\u0026lt;=A-B; 3\u0026#39;b110:begin if(A\u0026lt;B) F\u0026lt;=32\u0026#39;h0000_0001;else F\u0026lt;=32\u0026#39;h0000_0000;end 3\u0026#39;b111:begin F\u0026lt;=B\u0026lt;\u0026lt;A;end endcase if(F==32\u0026#39;h0000_0000)\tZF\u0026lt;=1; else ZF\u0026lt;=0; if(ALU_OP == 3\u0026#39;b100 || ALU_OP == 3\u0026#39;b101) OF\u0026lt;=C32^F[31]^A[31]^B[31];\telse OF \u0026lt;=0; end endmodule MIPS32.coe\nmemory_initialization_radix=16; memory_initialization_vector=00000827 0001102b 00421820 00622020 00832820 00a33020 00463804 00a64820 01264004 00284826 01215020 01075822 00e86022 012c6824 012c7025 00c77825 00c78027 00e38820 02289004 02239804 00f3a004 0281a820 0255b025 0296b820 0296c022 02d4c822 0241d026 02d4d82b 0354e02b 02c2e820 0282f022 017af820; 测试模块\nmodule test; // Inputs reg clk; reg rst; // Outputs wire [5:0] op_code; wire [5:0] funct; wire [4:0] rs_addr; wire [4:0] rt_addr; wire [4:0] rd_addr; wire [4:0] shamt; wire OF; wire ZF; wire [31:0] F; wire [2:0] ALU_OP; wire [31:0] Inst_code; CPU uut ( .clk(clk), .rst(rst), .op_code(op_code), .funct(funct), .rs_addr(rs_addr), .rt_addr(rt_addr), .rd_addr(rd_addr), .shamt(shamt), .OF(OF), .ZF(ZF), .F(F), .ALU_OP(ALU_OP), .Inst_code(Inst_code) ); always #20 clk = ~clk; initial begin clk = 0; rst = 1; #2; rst = 0; end endmodule 友情提示：开始不拉高rst，第一条指令取不到噢，解释可以看实验七，顶上有链接\n代码地址 # 代码地址\n","date":"23 December 2020","permalink":"/posts/hdu_computer_organization_and_architecture_experiment/eighth_experiment/","section":"Blog","summary":"实验内容 # 掌握MIPS R型指令的数据通路设计，掌握指令流和数据流的控制方法 掌握完整的单周期CPU顶层模块的设计方法 实现MIPS R型指令的功能 解决方法 # 分析MIPS R型指令的特点，OP均为000000b，可作为判断R型指令的依据 两个源操作数分别在rs和rt字段所指定的寄存器中，而目的操作数则是在rd字段所指定的寄存器 3.","title":"杭电计算机组成实验 实验8-实现R型指令的CPU设计实验"},{"content":"","date":"22 December 2020","permalink":"/tags/mips/","section":"Tags","summary":"","title":"MIPS"},{"content":"","date":"22 December 2020","permalink":"/tags/%E5%8F%96%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%8C%87%E4%BB%A4%E8%AF%91%E7%A0%81/","section":"Tags","summary":"","title":"取指令与指令译码"},{"content":"","date":"22 December 2020","permalink":"/tags/%E5%AD%98%E5%82%A8%E5%99%A8/","section":"Tags","summary":"","title":"存储器"},{"content":"实验内容 # 掌握灵活运用 Verilog HDL 进行各种描述与建模的技巧和方法 学习在 ISE 中设计生成 Memory IP 核的方法 学习存储器的结构及读写原理，掌握存储器的设计方法 解决方法 # 分析一个 256x8 位的物理存储器，具有读 写功能，按字节编址，按字访问， 即 64x32 位。\n首先，给出的 8 位存储器地址，只按照高 6 位访问存储器，而低 2 位必须为 00\n我采用了两种方法进行设计存储器，首先是 MemoryIP 核\nMemoryIP核只需按照书上步骤下来，贴几张步骤图，大家按照步骤下来 这里我选择的是同步存储器，由时钟控制；另一种是分布式存储器，不带时钟同步，也就是异步控制\n5. MemoryIP代码展示：\nmodule RAM( input [7:2]Mem_Addr, input [1:0]MUX,\tinput Mem_Write,\tinput Clk,\toutput reg [7:0]LED); wire [31:0]M_R_Data;\treg [31:0]M_W_Data;\tRAM_B your_instance_name ( .clka(Clk), // input clka .wea(Mem_Write), // input [0 : 0] wea .addra(Mem_Addr), // input [5 : 0] addra .dina(M_W_Data), // input [31 : 0] dina .douta(M_R_Data) // output [31 : 0] douta ); always @(*) begin LED = 0; M_W_Data = 0; if(Mem_Write) begin case(MUX) 2\u0026#39;b00:\tM_W_Data = 32\u0026#39;h0000_000F; 2\u0026#39;b01:\tM_W_Data = 32\u0026#39;h0000_0DB0; 2\u0026#39;b10:\tM_W_Data = 32\u0026#39;h003C_C381; 2\u0026#39;b11:\tM_W_Data = 32\u0026#39;hFFFF_FFFF;\tendcase end else begin case(MUX) 2\u0026#39;b00:\tLED = M_R_Data[7:0]; 2\u0026#39;b01:\tLED = M_R_Data[15:8]; 2\u0026#39;b10:\tLED = M_R_Data[23:16]; 2\u0026#39;b11:\tLED = M_R_Data[31:24];\tendcase end end endmodule Test_Mem.coe\nmemory_initialization_radix = 16; memory_initialization_vector = 00000820,00632020,00010fff,20006789,ffff0000,0000ffff,88888888,99999999,aaaaaaaa,bbbbbbbb; 测试模块\nmodule test; // Inputs reg [7:2] Mem_Addr; reg [1:0] MUX; reg Mem_Write; reg Clk; // Outputs wire [7:0] LED; RAM uut ( .Mem_Addr(Mem_Addr), .MUX(MUX), .Mem_Write(Mem_Write), .Clk(Clk), .LED(LED) ); always #20 Clk=~Clk; initial begin // Initialize Inputs Mem_Addr = 0; MUX = 0; Mem_Write = 1; Clk = 0; #100; Mem_Addr = 6\u0026#39;b000000; MUX = 0; Mem_Write = 0; end endmodule 6. 自己实现同步存储器核心代码展示（这自己实现的代码欢迎大家指正错误）：\n存储器模块\nmodule RAMA(Mem_Read,Mem_Write,Mem_Addr,M_W_Data,M_R_Data,clk); input Mem_Read,Mem_Write,clk; input [5:0]Mem_Addr; input [31:0]M_W_Data; output reg[31:0]M_R_Data; reg [0:31]memory[0:63]; always@(posedge clk) if(Mem_Write) memory[Mem_Addr]\u0026lt;=M_W_Data; else if(Mem_Read) M_R_Data \u0026lt;= memory[Mem_Addr]; endmodule 顶层模块\nmodule RAM( input [5:0]Mem_Addr, input [1:0]MUX,\tinput Mem_Write, input Mem_Read, input clk,\toutput reg [7:0]LED); wire [31:0]M_R_Data;\treg [31:0]M_W_Data;\tRAMA ram (Mem_Read,Mem_Write,Mem_Addr,M_W_Data,M_R_Data,clk); always @(*) begin LED = 0; M_W_Data = 0; if(Mem_Write) begin case(MUX) 2\u0026#39;b00:\tM_W_Data = 32\u0026#39;h0000_000F; 2\u0026#39;b01:\tM_W_Data = 32\u0026#39;h0000_0DB0; 2\u0026#39;b10:\tM_W_Data = 32\u0026#39;h003C_C381; 2\u0026#39;b11:\tM_W_Data = 32\u0026#39;hFFFF_FFFF;\tendcase end else if(Mem_Read) begin case(MUX) 2\u0026#39;b00:\tLED = M_R_Data[7:0]; 2\u0026#39;b01:\tLED = M_R_Data[15:8]; 2\u0026#39;b10:\tLED = M_R_Data[23:16]; 2\u0026#39;b11:\tLED = M_R_Data[31:24];\tendcase end end endmodule 测试模块\nmodule test; // Inputs reg [5:0] Mem_Addr; reg [1:0] MUX; reg Mem_Write; reg Mem_Read; reg clk; // Outputs wire [7:0] LED; RAM uut ( .Mem_Addr(Mem_Addr), .MUX(MUX), .Mem_Write(Mem_Write), .Mem_Read(Mem_Read), .clk(clk), .LED(LED) ); always #20 clk = ~clk; initial begin // Initialize Inputs Mem_Addr = 0; MUX = 0; Mem_Write = 1; Mem_Read = 0; clk = 0; #100; Mem_Addr = 0; MUX = 0; Mem_Write = 0; Mem_Read = 1; end endmodule 7. 自己实现异步存储器核心代码展示（这自己实现的代码欢迎大家指正错误）：\n存储器模块\nmodule RAMA(Mem_Read,Mem_Write,Mem_Addr,M_W_Data,M_R_Data); input Mem_Read,Mem_Write; input [5:0]Mem_Addr; input [31:0]M_W_Data; output reg[31:0]M_R_Data; reg [0:31]memory[0:63]; //M_R_Data \u0026lt;= Mem_Read?memory[Mem_Addr]:32\u0026#39;bz; always@(*) if(Mem_Write) memory[Mem_Addr]\u0026lt;=M_W_Data; else if(Mem_Read) M_R_Data \u0026lt;= memory[Mem_Addr]; endmodule 顶层模块\nmodule RAM( input [5:0]Mem_Addr, input [1:0]MUX,\tinput Mem_Write, input Mem_Read,\toutput reg [7:0]LED); wire [31:0]M_R_Data;\treg [31:0]M_W_Data;\tRAMA ram (Mem_Read,Mem_Write,Mem_Addr,M_W_Data,M_R_Data); always @(*) begin LED = 0; M_W_Data = 0; if(Mem_Write) begin case(MUX) 2\u0026#39;b00:\tM_W_Data = 32\u0026#39;h0000_000F; 2\u0026#39;b01:\tM_W_Data = 32\u0026#39;h0000_0DB0; 2\u0026#39;b10:\tM_W_Data = 32\u0026#39;h003C_C381; 2\u0026#39;b11:\tM_W_Data = 32\u0026#39;hFFFF_FFFF;\tendcase end else if(Mem_Read) begin case(MUX) 2\u0026#39;b00:\tLED = M_R_Data[7:0]; 2\u0026#39;b01:\tLED = M_R_Data[15:8]; 2\u0026#39;b10:\tLED = M_R_Data[23:16]; 2\u0026#39;b11:\tLED = M_R_Data[31:24];\tendcase end end endmodule 测试模块\nmodule test; reg [5:0] Mem_Addr; reg [1:0] MUX; reg Mem_Write; reg Mem_Read; wire [7:0] LED; RAM uut ( .Mem_Addr(Mem_Addr), .MUX(MUX), .Mem_Write(Mem_Write), .Mem_Read(Mem_Read), .LED(LED) ); initial begin Mem_Addr = 0; MUX = 0; Mem_Write = 1; Mem_Read = 0; #100; Mem_Addr = 0; MUX = 0; Mem_Write = 0; Mem_Read = 1; end endmodule 代码地址 # 代码地址-1\n代码地址-2\n代码地址-3\n","date":"22 December 2020","permalink":"/posts/hdu_computer_organization_and_architecture_experiment/fifth_experiment/","section":"Blog","summary":"实验内容 # 掌握灵活运用 Verilog HDL 进行各种描述与建模的技巧和方法 学习在 ISE 中设计生成 Memory IP 核的方法 学习存储器的结构及读写原理，掌握存储器的设计方法 解决方法 # 分析一个 256x8 位的物理存储器，具有读 写功能，按字节编址，按字访问， 即 64x32 位。","title":"杭电计算机组成实验 实验5-存储器设计实验"},{"content":"实验内容 # 学习 MIPS指令系统，熟悉 MIPS指令格式及其汇编指令助记符，掌握机器 指令编码方法 学习 MIPS汇编程序设计，学会使用 MIPS 汇编器将汇编语言程序翻译成二 进制文件 了解使用 MIPS教学系统模拟器运行程序的方法 解决方法 # 下载 PCSpim 软件 给大家一个下载的地方，只要关注我，就可以下载到PCSpim下载地址 按照书上的要求，在文本编辑器中输入汇编程序，然后装入PCSpim 左侧内为指令地址，中间是十六进制的指令编码，右侧是相应的标准汇编指 令，主要注意的是第二个程序，必须在裸机执行方式 书上的汇编和结果展示： test.asm\nmain:\tli $v0 , 5 syscall move $t0,$v0 li $v0,5 syscall\tmove $t1 , $v0 bgt $t0,$t1,t0_bigger move $t2,$t1 b endif t0_bigger : move $t2,$t0 endif :move $a0,$t2 li $v0,1 syscall jr $ra R_CPU_Test.asm\nmain:nor $1,$0,$0;\t#$1 = FFFF_FFFF\tsltu $2,$0,$1;\t#$2 = 0000_0001 if($2\u0026lt;$3) $1=1 else $1=0 add $3,$2,$2;\t#$3 = 0000_0002 add $4,$3,$2;\t#$4 = 0000_0003 add $5,$4,$3;\t#$5 = 0000_0005 add $6,$5,$3;\t#$6 = 0000_0007 sllv $7,$6,$2;\t#$7 = 0000_000E $1=$2\u0026lt;\u0026lt;$3 add $9,$5,$6;\t#$9 = 0000_000C sllv $8,$6,$9;\t#$8 = 0000_7000 xor $9,$1,$8;\t#$9 = FFFF_8FFF add $10,$9,$1;\t#$10 = FFFF_8FFE sub $11,$8,$7; #$11 = 0000_6FF2 sub $12,$7,$8;\t#$12 = FFFF_900E and $13,$9,$12; #$13 = FFFF_800E or $14,$9,$12;\t#$14 = FFFF_9FFF or $15,$6,$7;\t#$15 = 0000_000F nor $16,$6,$7;\t#$16 = FFFF_FFF0 add $17,$7,$3;\t#$17 = 0000_0010 sllv $18,$8,$17;\t#$18 = 7000_0000 sllv $19,$3,$17;\t#$19 = 0002_0000 sllv $20,$19,$7;\t#$20 = 8000_0000 add $21,$20,$1; #$21 = 7FFF_FFFF or $22,$18,$21\t#$22 = 7FFF_FFFF add $23,$20,$22;\t#$23 = FFFF_FFFF sub $24,$20,$22;\t#$24 = 0000_0001 sub $25,$22,$20;\t#$25 = FFFF_FFFF xor $26,$18,$1;\t#$26 = 8FFF_FFFF sltu $27,$22,$20;\t#$27 = 0000_0001 sltu $28,$26,$20;\t#$28 = 0000_0000 add $29,$22,$2;\t#$29 = 8000_0000 sub $30,$20,$2;\t#$30 = 7FFF_FFFF add $31,$11,$26;\t#$31 = 9000_6FF1 结果机器码展示\n00000827 0001102b 00421820 00622020 00832820 00a33020 00463804 00a64820 01264004 00284826 01215020 01075822 00e86022 012c6824 012c7025 00c77825 00c78027 00e38820 02289004 02239804 00f3a004 0281a820 0255b025 0296b820 0296c022 02d4c822 0241d026 02d4d82b 0354e02b 02c2e820 0282f022 017af820 代码地址 # 代码地址\n","date":"22 December 2020","permalink":"/posts/hdu_computer_organization_and_architecture_experiment/sixth_experiment/","section":"Blog","summary":"实验内容 # 学习 MIPS指令系统，熟悉 MIPS指令格式及其汇编指令助记符，掌握机器 指令编码方法 学习 MIPS汇编程序设计，学会使用 MIPS 汇编器将汇编语言程序翻译成二 进制文件 了解使用 MIPS教学系统模拟器运行程序的方法 解决方法 # 下载 PCSpim 软件 给大家一个下载的地方，只要关注我，就可以下载到PCSpim下载地址 按照书上的要求，在文本编辑器中输入汇编程序，然后装入PCSpim 左侧内为指令地址，中间是十六进制的指令编码，右侧是相应的标准汇编指 令，主要注意的是第二个程序，必须在裸机执行方式 书上的汇编和结果展示： test.","title":"杭电计算机组成实验 实验6-MIPS汇编器与模拟器实验"},{"content":"实验内容 # 学习指令存储器的设计 掌握CPU取指令操作与指令译码的方法和过程 解决方法 # 本次实验设计采用哈佛结构设计存储器模块，需要设计一个只读存储器作为指令存储器，采用Memory IP核实现（不会用Memory IP核，可以看我这个博文存储器实验 程序计数器PC与PC自增加法器组合成一个模块，由于指令存储器只有64个32位单元，所以PC的32位指令地址的高24位可直接在设计中清零 需要注意在指令周期clk的上升沿执行取指令操作，在clk下降沿更新PC值 代码展示: 顶层模块\nmodule Fetch_Inst_Code(clk,rst,LED,MUX,op_code,funct,rs_addr,rt_addr,rd_addr,shamt,Inst_code); input clk,rst; input [1:0]MUX; output [31:0]Inst_code; output reg[7:0]LED; reg [31:0]PC; wire [31:0]PC_new; output [5:0]op_code,funct; output [4:0]rs_addr,rt_addr,rd_addr,shamt; PC pc1(clk,rst,Inst_code); always@(*) begin case(MUX) 2\u0026#39;b00:LED = Inst_code[7:0]; 2\u0026#39;b01:LED = Inst_code[15:8]; 2\u0026#39;b10:LED = Inst_code[23:16]; 2\u0026#39;b11:LED = Inst_code[31:25]; endcase end assign op_code = Inst_code[31:26]; assign rs_addr = Inst_code[25:21]; assign rt_addr = Inst_code[20:16]; assign rd_addr = Inst_code[15:11]; assign shamt = Inst_code[10:6]; assign funct = Inst_code[5:0]; endmodule PC(取指令模块)\nmodule PC(clk,rst,Inst_code); input clk,rst; wire [31:0]PC_new; reg[31:0]PC; initial PC = 32\u0026#39;h0000_0000; output [31:0]Inst_code; assign PC_new = PC +4; Inst_Rom your_instance_name ( .clka(clk), // input clka .addra(PC[7:2]), // input [5 : 0] addra .douta(Inst_code) // output [31 : 0] douta ); always@(negedge clk or posedge rst) begin if(rst) begin PC \u0026lt;= 32\u0026#39;h0000_0000; end else begin PC \u0026lt;=PC_new; end end endmodule 友情提示：PC一定要初始化，否则结果会有所偏差\n测试模块\nmodule test; // Inputs reg clk; reg rst; reg [1:0] MUX; // Outputs wire [7:0] LED; wire [5:0] op_code; wire [5:0] funct; wire [4:0] rs_addr; wire [4:0] rt_addr; wire [4:0] rd_addr; wire [4:0] shamt; wire [31:0] Inst_code; Fetch_Inst_Code uut ( .clk(clk), .rst(rst), .LED(LED), .MUX(MUX), .op_code(op_code), .funct(funct), .rs_addr(rs_addr), .rt_addr(rt_addr), .rd_addr(rd_addr), .shamt(shamt), .Inst_code(Inst_code) ); always #33 clk = ~clk; initial begin clk = 0; rst = 1; MUX = 0; #2; rst = 0; end endmodule MIPS32.coe\nmemory_initialization_radix=16; memory_initialization_vector=00000827 0001102b 00421820 00622020 00832820 00a33020 00463804 00a64820 01264004 00284826 01215020 01075822 00e86022 012c6824 012c7025 00c77825 00c78027 00e38820 02289004 02239804 00f3a004 0281a820 0255b025 0296b820 0296c022 02d4c822 0241d026 02d4d82b 0354e02b 02c2e820 0282f022 017af820; 友情提示：如果rst不先开始拉高，就会导致第一条指令取不到，我一个朋友就因为这个写了一个下午，重构了很久；根据我个人分析，是因为clk的上升沿的到来，但是PC地址还没准备好，导致第一条指令没有取到\n询问了研究生学长，证实自己的想法\n代码地址 # 代码地址\n","date":"22 December 2020","permalink":"/posts/hdu_computer_organization_and_architecture_experiment/seventh_experiment/","section":"Blog","summary":"实验内容 # 学习指令存储器的设计 掌握CPU取指令操作与指令译码的方法和过程 解决方法 # 本次实验设计采用哈佛结构设计存储器模块，需要设计一个只读存储器作为指令存储器，采用Memory IP核实现（不会用Memory IP核，可以看我这个博文存储器实验 程序计数器PC与PC自增加法器组合成一个模块，由于指令存储器只有64个32位单元，所以PC的32位指令地址的高24位可直接在设计中清零 需要注意在指令周期clk的上升沿执行取指令操作，在clk下降沿更新PC值 代码展示: 顶层模块","title":"杭电计算机组成实验 实验7-取指令与指令译码实验"},{"content":"","date":"21 December 2020","permalink":"/tags/%E5%85%A8%E5%8A%A0%E5%99%A8/","section":"Tags","summary":"","title":"全加器"},{"content":"","date":"21 December 2020","permalink":"/tags/%E5%A4%9A%E5%8A%9F%E8%83%BDalu/","section":"Tags","summary":"","title":"多功能ALU"},{"content":"","date":"21 December 2020","permalink":"/tags/%E5%AF%84%E5%AD%98%E5%99%A8%E5%A0%86/","section":"Tags","summary":"","title":"寄存器堆"},{"content":"实验内容 # 学习ISE工具软件的使用及仿真方法 学习FPGA程序的下载方式 熟悉Nexys3实验板 掌握运用Verilog HDL 进行结构描述与建模的技术和方法 掌握二进制全加器的原理与设计 解决方法 # 分析二进制全加器的输入输出，然后得出两个输出端口的门电路。 使用ISE内部门级电路进行组合，最后实现实验所需的效果 代码展示： 顶层模块：\nmodule First_Experiment_Add(A,B,Ci,F,C); input A,B,Ci; output F,C; xor\tXU1(F,A,B,Ci), XU2(Q,A,B); and\tAN1(W,Q,Ci), AN2(E,A,B); or\tOR1(C,W,E); endmodule 测试模块：\nmodule test; // Inputs reg A; reg B; reg Ci; // Outputs wire F; wire C; First_Experiment_Add uut ( .A(A), .B(B), .Ci(Ci), .F(F), .C(C) ); initial begin A = 0; B = 0; Ci = 0; #100; A = 1; B = 0; Ci = 0; #100; A = 1; B = 1; Ci = 0; #100; A = 1; B = 1; Ci = 1; end endmodule 代码地址 # 代码地址\n","date":"21 December 2020","permalink":"/posts/hdu_computer_organization_and_architecture_experiment/first_experiment/","section":"Blog","summary":"实验内容 # 学习ISE工具软件的使用及仿真方法 学习FPGA程序的下载方式 熟悉Nexys3实验板 掌握运用Verilog HDL 进行结构描述与建模的技术和方法 掌握二进制全加器的原理与设计 解决方法 # 分析二进制全加器的输入输出，然后得出两个输出端口的门电路。 使用ISE内部门级电路进行组合，最后实现实验所需的效果 代码展示： 顶层模块：","title":"杭电计算机组成实验 实验1-全加器设计实验"},{"content":"实验内容 # 掌握运用Verilog HDL进行数据流描述与建模的技巧和方法，掌握模块调用与实例引用的方法 掌握超前进位加法器的原理与设计方法 解决方法 # 分析4位的二进制全加器的输入输出，内部为超前进位逻辑 首先，要知道超前进位逻辑与行波进位加法器的区别 行波进位加法器需要像链子一样，等第一位算完，再算第二位，而超前进位加法器是四位同时，第二位包括了第一位的计算部分，从而达到消除依赖的关系 代码展示： 顶层模块\nmodule second_experiment_first(A,B,F,C4,C0); input [3:0]A,B; input C0; output [3:0]F; output C4; assign G0 = A[0] \u0026amp; B[0]; assign P0 = A[0] | B[0]; assign G1 = A[1] \u0026amp; B[1]; assign P1 = A[1] | B[1]; assign G2 = A[2] \u0026amp; B[2]; assign P2 = A[2] | B[2]; assign G3 = A[3] \u0026amp; B[3]; assign P3 = A[3] | B[3]; assign C1 = G0 | P0\u0026amp;C0; assign C2 = G1 | P1\u0026amp;G0 | P0\u0026amp;P1\u0026amp;C0; assign C3 = G2 | P2\u0026amp;G1 | P2\u0026amp;P1\u0026amp;G0 | P2\u0026amp;P1\u0026amp;P0\u0026amp;C0; assign C4 = G3 | P3\u0026amp;G2 | P3\u0026amp;P2\u0026amp;G1 | P3\u0026amp;P2\u0026amp;P1\u0026amp;G0 | P3\u0026amp;P2\u0026amp;P1\u0026amp;P0\u0026amp;C0; assign F[0] = A[0]^B[0]^C0; assign F[1] = A[1]^B[1]^C1; assign F[2] = A[2]^B[2]^C2; assign F[3] = A[3]^B[3]^C3; endmodule 测试模块\nmodule second_experiment_test; // Inputs reg [3:0] A; reg [3:0] B; reg C0; // Outputs wire [3:0] F; wire C4; second_experiment_first uut ( .A(A), .B(B), .F(F), .C4(C4), .C0(C0) ); initial begin A = 4\u0026#39;b1000; B = 4\u0026#39;b1000; C0 = 1; #100; A = 4\u0026#39;b1001; B = 4\u0026#39;b1001; C0 = 1; #100; A = 4\u0026#39;b1011; B = 4\u0026#39;b1011; C0 = 1; end endmodule 特别注意 # 题主在网上看到一份报告中的代码并不是把所有的运算拿过来的，而是把C1赋给C2这样做的，assign这种组合逻辑电路，是并行执行，这样的方法不一定可行\n代码地址 # 代码地址\n","date":"21 December 2020","permalink":"/posts/hdu_computer_organization_and_architecture_experiment/second_experiment/","section":"Blog","summary":"实验内容 # 掌握运用Verilog HDL进行数据流描述与建模的技巧和方法，掌握模块调用与实例引用的方法 掌握超前进位加法器的原理与设计方法 解决方法 # 分析4位的二进制全加器的输入输出，内部为超前进位逻辑 首先，要知道超前进位逻辑与行波进位加法器的区别 行波进位加法器需要像链子一样，等第一位算完，再算第二位，而超前进位加法器是四位同时，第二位包括了第一位的计算部分，从而达到消除依赖的关系 代码展示： 顶层模块","title":"杭电计算机组成实验 实验2-超前进位加法器设计实验"},{"content":"实验内容 # 学习多功能ALU的工作原理，掌握运算器的设计方法 掌握运用Verilog HDL 进行行为描述与建模的技巧和方法 解决方法 # 分析一个具有8种运算功能的32位ALU，并能够产生运算结果的标志：结果位零标志（ZF）和溢出标志（OF） 首先，分析出ZF只会在加减运算中出现溢出情况，然后分析出ALU 8种计算如何表达，如果使用“-”，就不用考虑如何减法 代码展示： 顶层模块：\nmodule ALU(AB_SW,ALU_OP,F_LED_SW,LED); input[2:0]AB_SW,ALU_OP,F_LED_SW; output[7:0]LED; wire [31:0]A,B,F; wire ZF,OF; Third_experiment_second T2(AB_SW,A,B); Third_experiment_first T1(OF,ZF,ALU_OP,A,B,F); Third_experiment_third T3(F_LED_SW,LED,F,ZF,OF); endmodule Third_experiment_second模块（作为数据输入）\nmodule Third_experiment_second(AB_SW,A,B); input[2:0]AB_SW; output reg[31:0]A,B; always @(*) begin case(AB_SW) 3\u0026#39;b000:begin A=32\u0026#39;h0000_0000;B=32\u0026#39;h0000_0000;end 3\u0026#39;b001:begin A=32\u0026#39;h0000_0003;B=32\u0026#39;h0000_0607;end 3\u0026#39;b010:begin A=32\u0026#39;h8000_0000;B=32\u0026#39;h8000_0000;end 3\u0026#39;b011:begin A=32\u0026#39;h7FFF_FFFF;B=32\u0026#39;h7FFF_FFFF;end 3\u0026#39;b100:begin A=32\u0026#39;hFFFF_FFFF;B=32\u0026#39;hFFFF_FFFF;end 3\u0026#39;b101:begin A=32\u0026#39;h8000_0000;B=32\u0026#39;hFFFF_FFFF;end 3\u0026#39;b110:begin A=32\u0026#39;hFFFF_FFFF;B=32\u0026#39;h8000_0000;end 3\u0026#39;b111:begin A=32\u0026#39;h1234_5678;B=32\u0026#39;h3333_2222;end default:begin A=32\u0026#39;h9ABC_DEF0;B=32\u0026#39;h1111_2222;end endcase end endmodule Third_experiment_first模块（运算）\nmodule Third_experiment_first(OF,ZF,ALU_OP,A,B,F); input [2:0]ALU_OP; input [31:0]A,B; output reg[31:0]F; reg C32; output reg OF=0; output reg ZF=0; always @(ALU_OP or A or B) begin case(ALU_OP) 3\u0026#39;b000:F\u0026lt;=A\u0026amp;B; 3\u0026#39;b001:F\u0026lt;=A|B; 3\u0026#39;b010:F\u0026lt;=A^B; 3\u0026#39;b011:F\u0026lt;=A~^B; 3\u0026#39;b100:{C32,F}\u0026lt;=A+B; 3\u0026#39;b101:{C32,F}\u0026lt;=A-B; 3\u0026#39;b110:begin if(A\u0026lt;B) F\u0026lt;=32\u0026#39;h0000_0001;else F\u0026lt;=32\u0026#39;h0000_0000;end 3\u0026#39;b111:begin F\u0026lt;=B\u0026lt;\u0026lt;A;end endcase if(F==32\u0026#39;h0000_0000)\tZF\u0026lt;=1; else ZF\u0026lt;=0; OF=C32^F[31]^A[31]^B[31];\tend endmodule Third_experiment_third模块（作为LED显示）\nmodule Third_experiment_third(F_LED_SW,LED,F,ZF,OF); input[31:0]F; input ZF,OF; input[2:0] F_LED_SW; output reg[7:0] LED; always@(*) begin case(F_LED_SW) 3\u0026#39;b000:LED=F[7:0]; 3\u0026#39;b001:LED=F[15:8]; 3\u0026#39;b010:LED=F[23:16]; 3\u0026#39;b011:LED=F[31:24]; default:begin LED[7]=ZF;LED[0]=OF;LED[6:1]=6\u0026#39;b0;end endcase end endmodule 测试模块\nmodule ALU_TEST; // Inputs reg [2:0] AB_SW; reg [2:0] ALU_OP; reg [2:0] F_LED_SW; // Outputs wire [7:0] LED; ALU uut ( .AB_SW(AB_SW), .ALU_OP(ALU_OP), .F_LED_SW(F_LED_SW), .LED(LED) ); initial begin AB_SW = 3\u0026#39;b001; ALU_OP = 3\u0026#39;b000; F_LED_SW = 3\u0026#39;b000; #100; AB_SW = 3\u0026#39;b001; ALU_OP = 3\u0026#39;b001; F_LED_SW = 3\u0026#39;b000; #100; AB_SW = 3\u0026#39;b001; ALU_OP = 3\u0026#39;b010; F_LED_SW = 3\u0026#39;b000; end endmodule 特别注意 # 当时在做实验的时候，有的朋友问我begin\u0026hellip;end是干什么用，其实就是相当于C语言中的大括号\n代码地址 # 代码地址\n","date":"21 December 2020","permalink":"/posts/hdu_computer_organization_and_architecture_experiment/third_experiment/","section":"Blog","summary":"实验内容 # 学习多功能ALU的工作原理，掌握运算器的设计方法 掌握运用Verilog HDL 进行行为描述与建模的技巧和方法 解决方法 # 分析一个具有8种运算功能的32位ALU，并能够产生运算结果的标志：结果位零标志（ZF）和溢出标志（OF） 首先，分析出ZF只会在加减运算中出现溢出情况，然后分析出ALU 8种计算如何表达，如果使用“-”，就不用考虑如何减法 代码展示： 顶层模块：","title":"杭电计算机组成实验 实验3-多功能ALU设计实验"},{"content":"实验内容 # 学习使用Verilog HDL 进行时序电路的设计方法 掌握灵活运用Verilog HDL进行各种描述与建模的技巧和方法 学习寄存器堆的数据传送与读/写工作原理，掌握寄存器堆的设计方法 解决方法 # 分析一个32x32位的寄存器堆，即含有32个寄存器，每个寄存器32位。该寄存器堆有2个读端口、1个写端口，即能够同时读出2个寄存器的值，写入1个寄存器 首先，分析出两个端口读入是5位的地址，读出的数据是32位的两个，该寄存器堆只有一个写端口，还要配合控制信号Write_Reg，且写操作是边沿触发的，所有写入操作的输入信号必须在时钟边沿来临时已经有效 寄存器堆的读操作和写操作的地址译码，只需引用寄存器地址作为数组的下标即可；读只需要组合逻辑，给出寄存器地址，读出数据 代码展示： 顶层模块（需要数据输入在板子上操作）：\nmodule RegisterFile(Addr,Write_Reg,Opt,Clk,Reset,A_B,LED); input [1:0]Opt; input [4:0]Addr; input Write_Reg,Clk,Reset,A_B; output reg [7:0]LED; wire [31:0]R_Data_A,R_Data_B; reg [4:0]R_Addr_A,R_Addr_B; reg [31:0]W_Data; initial LED \u0026lt;= 0; Fourth_experiment_first F1(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,Addr,W_Data); always@(Addr or Write_Reg or Opt or A_B or R_Data_A or R_Data_B) begin if(Write_Reg) begin case(Opt) 2\u0026#39;b00: begin W_Data=32\u0026#39;h000f_000f; end 2\u0026#39;b01: begin W_Data=32\u0026#39;h0f0f_0f00; end 2\u0026#39;b10: begin W_Data=32\u0026#39;hf0f0_f0f0; end 2\u0026#39;b11: begin W_Data=32\u0026#39;hffff_ffff; end endcase end else if(A_B) begin R_Addr_A=Addr; case(Opt) 2\u0026#39;b00: LED=R_Data_A[7:0]; 2\u0026#39;b01: LED=R_Data_A[15:8]; 2\u0026#39;b10: LED=R_Data_A[23:16]; 2\u0026#39;b11: LED=R_Data_A[31:24]; endcase end else begin R_Addr_B=Addr; case(Opt) 2\u0026#39;b00: LED=R_Data_B[7:0]; 2\u0026#39;b01: LED=R_Data_B[15:8]; 2\u0026#39;b10: LED=R_Data_B[23:16]; 2\u0026#39;b11: LED=R_Data_B[31:24]; endcase end end endmodule 寄存器堆实现的Fourth_experiment_first模块\nmodule Fourth_experiment_first(R_Addr_A,R_Addr_B,Write_Reg,R_Data_A,R_Data_B,Reset,Clk,W_Addr,W_Data); input [4:0]R_Addr_A,R_Addr_B,W_Addr; input Write_Reg,Reset,Clk; input[31:0] W_Data; output [31:0] R_Data_A,R_Data_B; reg [31:0] REG_Files[0:31]; integer i=0; always @ (posedge Clk or posedge Reset) begin if(Reset) begin for(i=0;i\u0026lt;=31;i=i+1) REG_Files[i]\u0026lt;=0; end else begin if(Write_Reg) REG_Files[W_Addr]\u0026lt;=W_Data; end end assign R_Data_A = REG_Files[R_Addr_A]; assign R_Data_B = REG_Files[R_Addr_B]; endmodule 测试模块\nmodule Fourth_experiment_test; // Inputs reg [4:0] Addr; reg Write_Reg; reg [1:0] Opt; reg Clk; reg Reset; reg A_B; // Outputs wire [7:0] LED; RegisterFile uut ( .Addr(Addr), .Write_Reg(Write_Reg), .Opt(Opt), .Clk(Clk), .Reset(Reset), .A_B(A_B), .LED(LED) ); always #20 Clk = ~Clk; initial begin Addr = 5\u0026#39;b00001; Write_Reg = 1; Opt = 0; Clk = 1; Reset = 0; A_B = 0; #100; Addr = 5\u0026#39;b00001; Write_Reg = 0; Opt = 0; A_B = 0; end endmodule 代码地址 # 代码地址\n","date":"21 December 2020","permalink":"/posts/hdu_computer_organization_and_architecture_experiment/fourth_experiment/","section":"Blog","summary":"实验内容 # 学习使用Verilog HDL 进行时序电路的设计方法 掌握灵活运用Verilog HDL进行各种描述与建模的技巧和方法 学习寄存器堆的数据传送与读/写工作原理，掌握寄存器堆的设计方法 解决方法 # 分析一个32x32位的寄存器堆，即含有32个寄存器，每个寄存器32位。该寄存器堆有2个读端口、1个写端口，即能够同时读出2个寄存器的值，写入1个寄存器 首先，分析出两个端口读入是5位的地址，读出的数据是32位的两个，该寄存器堆只有一个写端口，还要配合控制信号Write_Reg，且写操作是边沿触发的，所有写入操作的输入信号必须在时钟边沿来临时已经有效 寄存器堆的读操作和写操作的地址译码，只需引用寄存器地址作为数组的下标即可；读只需要组合逻辑，给出寄存器地址，读出数据 代码展示： 顶层模块（需要数据输入在板子上操作）：","title":"杭电计算机组成实验 实验4-寄存器堆设计实验"},{"content":"","date":"21 December 2020","permalink":"/tags/%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8/","section":"Tags","summary":"","title":"超前进位加法器"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"我深怕自己本非美玉，故而不敢加以刻苦琢磨，却又半信自己是块美玉，故又不肯庸庸碌碌，与瓦砾为伍。\nContact # GitHub Email ","date":"1 January 0001","permalink":"/about/","section":"Welcome to XdpCs’s blog!","summary":"我深怕自己本非美玉，故而不敢加以刻苦琢磨，却又半信自己是块美玉，故又不肯庸庸碌碌，与瓦砾为伍。","title":"关于我"}]