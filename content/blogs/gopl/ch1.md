---
title: "第1章-入门-笔记"
description: "Welcome to XdpCs’s blog!"
date: "2023-08-07"
tags: ["gopl"]
showComments: true
---

## 1.1 hello,world

* Go是编译型语言
* Go的工具链将程序的源文件转变成为机器相关的原生二进制指令
* `go run` 将一个或多个以`.go`为后缀的源文件进行编译、链接，然后运行生成的可执行文件
* Go原生地支持`Unicode`，所以可以处理所有国家地语言
* `go build` 可以编译输出成一个可复用的二进制程序文件，它可以直接执行
* Go 代码是用包进行组织的，一个包由一个或多个`.go`源文件组成，放在一个文件夹中，文件夹的名字描述了包的作用
* 每个源文件都以一条`package`声明语句开始，表示该文件属于哪个包
* `main包`是用来定义可独立执行的程序
* `import`声明语句用来导入其他包，并且必须跟在`package`声明之后，且不能缺失导入或存在不需要的导入
* 一个函数的声明由func关键字、函数名、参数列表、返回值列表和函数体组成
* Go不需要使用分号进行结尾，除非一行上有多条语句或声明，在特定符号后面的换行符会被转换为分号，所以换行会影响对Go代码的解析
* `gofmt` 工具可以以标准格式去格式化代码，并按照字母顺序表进行排序
* `goimports` 工具可以自动添加或删除`import`声明

## 1.2 命令行参数

* `os` 包提供了与平台无关的操作系统函数和类型
* `os.Args` 是一个字符串的切片，用来存储所有的命令行参数，第一个参数是命令本身，另外的元素是程序开始执行时的参数
* 注释以`//` 开头 或者 `/* */` 包裹，编译器会忽略注释
* 习惯上，每个包都有一个包注释，位于包声明语句之前，用一个或多个完整句子对包的整体功能进行描述
* `var s string = “”` 变量可以在声明时初始化，如果没有初始化，则变量隐式初始化为该类型的空值，数值类型为0，字符串为“”，布尔类型为false，指针为nil
* `:=` 为短变量声明，用于声明并初始化变量值，给予合适的类型，`:=` 左侧的变量不应该是已经声明过的，否则会导致编译错误
* `i++`,`i--` 为语句，不是表达式，所以不能赋值给另一个变量，自增自减仅支持后缀形式
* Go中没有`while`语句，只有`for`循环语句，`for`循环语句的三个组成部分都是可选的，如果省略第一个分号和第二个分号之间的表达式，那么该循环就变成了一个无限循环，如果省略第二个分号后面的表达式，那么该循环就变成了C语言中的`while`循环
* `range` 关键字用于`for`循环中迭代数组、切片、字符串、map和通道，每次迭代都会返回两个值，第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本
* 使用空标识符`_`可以把不需要的值赋值给它，这样可以避免声明未使用的变量而导致编译错误
* `s := ""`  通常在一个函数内部使用，不适合包级别的变量
* `var s string` 默认初始化为空字符串“”
* 日常实践中，应当使用这两种形式`s := ""`, `var s string` ，使用显式初始化来说明初始化变量的重要性，使用隐式初始化来表明初始化变量不重要
* [例子](https://github.com/XdpCs/the-go-programming-language-learning/blob/master/demos/ch1/echo2/main.go) 通过`+=`语句追加旧的字符串，会生成一个新的字符串，然后新字符串赋值给变量s，旧的字符串会被垃圾回收器回收，如果有大量的数据需要处理，代价会非常大，推荐使用`strings.Join`函数来拼接字符串

## 1.3 找出重复行

* `map` 存储了一组无序的键值对，其中所有的键都是不同的，并提供常量的操作来存储、获取或测试集合中的某个元素，键可以是其值能够进行相等比较的任意类型，值可以是任意类型的，可以使用内置函数`make`来创建一个`map`
* `bufio` 包用于创建带缓冲的读取器，它可以包装任何`io.Reader`对象，简便且高效地处理输入和输出，`bufio.NewScanner`函数可以创建一个从指定`io.Reader`对象读取数据的`Scanner`，默认的分割函数是`bufio.ScanLines`，可以使用`bufio.ScanWords`来指定按照单词来分割输入
* `fmt.Printf` 函数的第一个参数是格式化字符串，包含了两种类型的内容：普通字符和转义字符，普通字符会原样输出，转义字符以`%`开头，用于表示一些特定的格式化操作，`%s` 表示字符串，`%d` 表示十进制整数，`%f` 或 `%F` 表示浮点数，`%t` 表示布尔值，`%v` 表示通用格式，`%T` 表示值的类型，`%p` 表示指针，`%x` 或 `%X` 表示十六进制，`%b` 或 `%B` 表示二进制，`%o` 或 `%O` 表示八进制，`%q` 表示带双引号的字符串，`%c` 表示字符(Unicode码点)，`%U` 表示Unicode格式，`%e`或`%E` 表示科学计数法，`%g`或`%G` 表示通用格式，`%%` 表示百分号
* 字符串字面量可以包含类似转义序列来表示不可见字符，`\n` 表示换行符，`\t` 表示制表符，`\r` 表示回车符，`\\` 表示反斜杠，`\'` 表示单引号，`\"` 表示双引号，`\xhh` 表示一个两位的十六进制数，`\uhhhh` 表示一个四位的十六进制数，`\Uhhhhhhhh` 表示一个八位的十六进制数
* `log.Printf` 和 `fmt.Errorf` 这类的格式化函数以f结尾，`fmt.Errorf`使用和`fmt.Printf`相同的格式化字符串，但是不会将结果写入标准输出，而是将其格式化后的内容写入`error`对象，`log.Printf`函数会在每条日志消息的前面添加日期和时间的前缀
* 以`ln`结尾的函数(如`Println`)，则使用`%v`的方式来格式化参数，并在最后追加换行符
* 函数`os.Open` 会返回两个值，第一个值是被打开的文件(或者内存中的数据流)，第二个值是一个错误值，如果操作成功，错误值为nil，否则错误值表示错误的原因
* 函数和其他包级别的实体可以任意次序声明，但是在使用之前必须先声明，如果一个实体是在函数内部声明的，那么它只能在该函数内部使用，如果一个实体是在包级别声明的，那么它可以在整个包中使用，如果一个实体是以大写字母开头的，那么它可以被外部的包访问，如果一个实体是以小写字母开头的，那么它只能在同一个包内部使用
* `map`是一个使用内置函数`make`创建的引用，所以它可以被自由的传递，而不会发生复制，`map`的零值是`nil`，对一个`nil`值的`map`进行写入操作将会引发运行时错误，但是对一个`nil`值的`map`进行读取操作则是安全的
* `ioutil.ReadFile` 函数可以读取一个文件的全部内容，返回的结果是一个字节`slice`，如果读取过程中发生错误，将会返回一个非`nil`的错误值，如果读取成功，错误值为`nil`

## 1.4 GIF动画

* 使用路径的最后一段来引用包
* `const`声明用来给常量命名，常量的值必须是编译期可确定的数字、字符串、布尔值或者是一个能够在编译期调用确定值的函数，`const`声明可以出现在包级别
* `结构体`是由一组称为字段的值组成，它们一起组成单个对象，作为一个单位被对待，结构体的字段用点号来访问，结构体的字段可以是任意类型，包括数组、切片、以及其他的结构体，结构体的字段名必须是唯一的，如果结构体的字段名以大写字母开头，那么该字段是导出的，也就是说可以被外部的包访问，如果结构体的字段名以小写字母开头，那么该字段是未导出的，也就是说只能在同一个包内部使用

## 1.5 获取一个URL

* `net`包提供了可移植的`网络I/O接口`，包括TCP/IP、UDP、域名解析和Unix域socket，使用底层的网络连接，创建服务器
* `os.Exit(1)`会在程序退出时，返回一个状态码，非零状态码表示错误，零状态码表示成功，`os.Exit`会立即终止当前程序，不会执行任何的`defer`函数

## 1.6 并发获取多个URL

* `goroutine` 是一个并发执行的函数
* 通道是一种允许某一协程向另一个协程传递指定类型的值的通信机制，通道可以用`make`函数创建，通道的零值是`nil`，通道的零值没有什么用，必须使用`make`函数来创建一个真正的通道
* `main`函数在一个`goroutine`中执行，然后使用`go`语句创建额外的`goroutine`
* `ioutil.Discard` 是用来将输出流丢弃的，它实现了`Writer`接口的变量，在统计长度时候，经常使用
* 当一个`goroutine`试图在一个通道上进行发送或接收操作时，它会阻塞，直到另一个`goroutine`试图进行接收或发送操作时才会解除阻塞，对于同一个通道来说，发送操作之间是互斥的，接收操作之间也是互斥的，但是发送操作和接收操作之间则是不互斥的

## 1.7 一个Web服务器

* `if err := r.ParseForm(); err != nil` 合并的语句更短，缩小了`err`变量的作用域，这是一个好的实践
* 可以使用`go doc`查看某个函数的文档

## 1.8 其他内容

* `switch` 中的`case`语句中可以使用逗号来分隔多个表达式，`switch`语句中的表达式可以省略，这种情况下，`switch`语句等同于`switch true`语句，`switch`语句中的`case`表达式不必是常量或者整数，`case`表达式的求值顺序是从上到下，当匹配成功的`case`表达式后，执行相应的语句后就会退出整个`switch`语句，如果想要继续执行后面的`case`表达式，可以使用`fallthrough`语句，`fallthrough`语句不会判断下一条`case`表达式的求值结果是否为`true`，`fallthrough`语句应该是`case`语句的最后一条语句。没有语句匹配，会走`default`分支，如果没有`default`分支，那么`switch`语句将不做任何动作
* 无标签选择
```go
func Signum(x int) int {
    switch {
    case x > 0:
        return +1
    default:
        return 0
    case x < 0:
        return -1
    }
}
```

* `break` 和 `continue` 可以改变控制流，`break`语句会跳转到当前`switch`, `for`, `selecct` 语句的结束标签，`continue`语句会跳转到当前`switch`, `for`, `selecct`的结束标签。可以使用标签跳出多层循环
* `goto`语句可以无条件地转移到过程中指定的行，`goto`语句通常与条件语句配合使用，可以实现条件转移，`goto`语句在快速跳出循环、避免重复退出上有一定的帮助，但是在结构化程序设计中一般不主张使用`goto`语句，以免造成程序流程的混乱，使理解和调试程序都产生困难，使用`goto`语句的地方可以使用`break`或者`continue`语句代替
* `type`声明不仅仅可以给已有类型命名，还可以将其定义为一个新的类型，新的类型可以在原有类型的基础上添加一些额外的功能，但是底层的类型必须是一致的
* 指针的值是变量的地址，使用`&`操作符可以获取一个变量的地址，使用`*`操作符可以获取指针指向的变量的值，指针的零值是`nil`，指针之间可以进行比较操作，只有当两个指针指向同一个变量或者两个指针都是`nil`时候，比较的结果才为真，指针也可以指向一个结构体，指针的指针也是合法的，指针不能进行`算术运算`
* 方法是一个关联了命名类型的函数
* 接口可以用相同的方式处理不同的具体类型的抽象类型，它基于这些类型所包含的方法，而不是类型的描述或实现
* 接口可以被任意的对象实现，一个对象可以实现任意多个接口，任意类型都实现了空接口，因此空接口可以存储任意类型的数值，空接口可以用来处理未知类型的值
* `interface{}`类型可以保存任意类型的值，可以使用`switch`语句来判断空接口中的值的类型，`interface{}`类型本身是一个指针，内部存储了类型的信息，`interface{}`类型的变量只有在类型和值都为`nil`的时候才为`nil`，`interface{}`类型的变量可以作为函数的参数，通过`interface{}`类型的变量可以调用其内部包含的值的方法，但是如果没有类型信息，就无法调用其内部包含的值的方法，`interface{}`类型的变量可以使用类型断言来判断其内部包含的值的类型，类型断言的语法是`x.(T)`，其中`x`表示`interface{}`类型的变量，`T`表示断言`x`可能是的类型，如果`x`是`T`类型，那么就会返回其内部包含的值，否则就会触发`panic`，类型断言也可以用在`switch`语句中，`switch`语句中的`case`表达式中的类型断言可以将`x`的类型限制为`T`类型，如果`x`不是`T`类型，那么该`case`就不会被执行，反之
* 在声明任何函数前，写一段注释来说明它的行为是一个好的风格，且这样可以被`go doc`和`godoc`工具定位并作为文档显示
* 对跨越多行的注释，使用`/*...*/`进行注释，对于单行注释，使用`//`进行注释，两种注释不能相互嵌套
